<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Quasar">
<meta name="dcterms.date" content="2023-12-18">

<title>C++ Refresher - Part I – quantdev.blog</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;800&display=swap');
  @import url('https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400..800;1,400..800&display=swap');
  @import url('https://fonts.googleapis.com/css2?family=Fira+Code:wght@300..700&display=swap');
  @import url('https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap');
  @import url('https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&family=Source+Code+Pro:ital,wght@0,200..900;1,200..900&display=swap');
  @import url('https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&display=swap');
</style>
<script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9993009899870547" crossorigin="anonymous"></script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">quantdev.blog</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com"> <i class="bi bi-twitter" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="../../index.xml"> <i class="bi bi-rss" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <div class="quarto-title-block"><div><h1 class="title">C++ Refresher - Part I</h1><button type="button" class="btn code-tools-button" id="quarto-code-tools-source"><i class="bi"></i> Code</button></div></div>
                                <div class="quarto-categories">
                <div class="quarto-category">C++</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Quasar </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">December 18, 2023</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul class="collapse">
  <li><a href="#hazards-of-dynamic-memory-allocation." id="toc-hazards-of-dynamic-memory-allocation." class="nav-link active" data-scroll-target="#hazards-of-dynamic-memory-allocation.">Hazards of dynamic memory allocation.</a></li>
  <li><a href="#raw-pointers-and-smart-pointers." id="toc-raw-pointers-and-smart-pointers." class="nav-link" data-scroll-target="#raw-pointers-and-smart-pointers.">Raw pointers and Smart Pointers.</a></li>
  <li><a href="#references." id="toc-references." class="nav-link" data-scroll-target="#references.">References.</a></li>
  <li><a href="#function-templates." id="toc-function-templates." class="nav-link" data-scroll-target="#function-templates.">Function Templates.</a></li>
  <li><a href="#classes-and-object-oriented-programming." id="toc-classes-and-object-oriented-programming." class="nav-link" data-scroll-target="#classes-and-object-oriented-programming.">Classes and Object Oriented Programming.</a></li>
  <li><a href="#pure-virtual-functions." id="toc-pure-virtual-functions." class="nav-link" data-scroll-target="#pure-virtual-functions.">Pure virtual functions.</a></li>
  <li><a href="#abstract-classes." id="toc-abstract-classes." class="nav-link" data-scroll-target="#abstract-classes.">Abstract Classes.</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="hazards-of-dynamic-memory-allocation." class="level2">
<h2 class="anchored" data-anchor-id="hazards-of-dynamic-memory-allocation.">Hazards of dynamic memory allocation.</h2>
<section id="dangling-pointers-and-multiple-deallocations." class="level4">
<h4 class="anchored" data-anchor-id="dangling-pointers-and-multiple-deallocations.">Dangling pointers and multiple deallocations.</h4>
<p>A <em>dangling pointer</em> is a pointer variable that still contains the address to the free store memory that has already been deallocated using <code>delete</code> or <code>delete[]</code>. Dereferencing a dangling pointer makes you read from, or even worse write to memory that might already be allocated to and used by other parts of the program, resulting in all kinds of unpredictable results.</p>
<p>Multiple deallocations which occur when you deallocate an already deallocated memory (and hence dangling) pointer for a second time is a recipe for disaster.</p>
<p>One basic strategy to guard yourself against dangling pointers is to always reset a pointer to <code>nullptr</code>, after the memory it points to is released. However, in more complex programs, different parts of the code often collaborate by accessing the same memory - an object or an array of objects - all through distinct copies of the same pointer. In such cases, our simple strategy falls short. Which part of the code is going to call <code>delete</code>/<code>delete[]</code>? And when? How do you ensure that no other part of the code is still using the same dynamically allocated memory.</p>
</section>
<section id="allocationdeallocation-mismatch." class="level4">
<h4 class="anchored" data-anchor-id="allocationdeallocation-mismatch.">Allocation/Deallocation mismatch.</h4>
<p>A dynamically allocated array, allocated using <code>new[]</code>, is captured in a regular pointer cariable. But, so is a single allocated value that is allocated using <code>new</code>.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span><span class="op">*</span> single_df <span class="op">{</span><span class="kw">new</span> <span class="dt">double</span> <span class="op">{</span><span class="fl">0.95</span><span class="op">}};</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span><span class="op">*</span> array_of_dfs <span class="op">{</span><span class="kw">new</span> <span class="dt">double</span><span class="op">[</span><span class="dv">3</span><span class="op">]</span> <span class="op">{</span><span class="fl">1.00</span><span class="op">,</span> <span class="fl">0.95</span><span class="op">,</span> <span class="fl">0.90</span><span class="op">}};</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>After this the compiler has no way to distinguish between the two, especially once such a pointer gets passed around different parts of the program. This means that the following two statements will compile without error.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">delete</span><span class="op">[]</span> single_df<span class="op">;</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="kw">delete</span> array_of_dfs<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Every <code>new</code> must be paired with a single <code>delete</code>; every <code>new[]</code> must be paired with a single <code>delete[]</code>.</p>
</section>
<section id="memory-leaks." class="level4">
<h4 class="anchored" data-anchor-id="memory-leaks.">Memory Leaks.</h4>
<p>A memory leak occurs when you allocate memory using <code>new</code> or <code>new[]</code> and fail to release it. If you lose the address of free store memory you have allocated by overwriting the address in the pointer you were using to access it, for instance, you have a memory leak.</p>
<p>When it comes to scope, pointers are just like any other variable. The lifetime of a pointer extends from the point at which you define it in a block to the closing brace of the block. After that it no longer exists, the free store goes out of scope and it’s no longer possible to delete the memory.</p>
<p>It’s still relatively easy to see, where you’ve simply forgotten to use <code>delete</code> to free memory when use of the memory ceases at a point close to where you allocated it, but you’d be surprised how often programmers make mistakes like this, especially if, for instance, <code>return</code> statements creep in between allocation and deallocation of your variable. And naturally, memory leaks are even more difficult to spot in complex programs, where memory may be allocated in part of the the program and should be released in a completely separate part.</p>
<p>One basic strategy for avoiding memory leaks is to immediately add <code>delete</code> operation at an appropriate place each time you use the <code>new</code> operator. But this strategy by no means is fail-safe. Even C++ programmers are fallible creatures.</p>
</section>
<section id="fragmentation-of-the-free-store." class="level4">
<h4 class="anchored" data-anchor-id="fragmentation-of-the-free-store.">Fragmentation of the Free-Store.</h4>
<p>Memory fragmentation can arise in programs that frequently dynamically allocate and release memory blocks. Each time, the <code>new</code> operator is used, it allocates a contiguous block of bytes. If you create and destroy many memory blocks of different sizes, it’s possible to arrive at a situation in which the allocated memory is interspersed with small blocks of free memory, none of which is large enough to accomodate a new memory allocation request by your program. The aggregate of the free memory can be quite large, but if all the individual blocks are small (smaller than a current allocation request), the allocation request will fail.</p>
</section>
<section id="golden-rule-of-dynamic-memory-allocation." class="level3">
<h3 class="anchored" data-anchor-id="golden-rule-of-dynamic-memory-allocation.">Golden rule of dynamic memory allocation.</h3>
<p>Never use the operators <code>new</code>, <code>new[]</code>, <code>delete</code> and <code>delete[]</code> directly in day-to-day coding. These operators have no place in modern C++ code. Always use either the <code>std::vector&lt;T&gt;</code> container to replace dynamic arrays or a smart pointer to dynamically allocate individual objects and manage their lifetimes.</p>
</section>
</section>
<section id="raw-pointers-and-smart-pointers." class="level2">
<h2 class="anchored" data-anchor-id="raw-pointers-and-smart-pointers.">Raw pointers and Smart Pointers.</h2>
<p>Pointer types <code>int*</code>, <code>double*</code> are referred to as <em>raw pointers</em> because variables of these types contain nothing more than an address. A raw pointer can store the address of an automatic variable or a memory-block allocated in the free-store.</p>
<p>A <em>smart pointer</em> is an object that mimics a raw pointer in that, it contains an address, and you can use it in the same way in many respects. Smart pointers are normally used only to store the address of memory allocated in the free store. A smart pointer does much more than a raw pointer, though. The most notable feature of a smart pointer, is that we don’t have to worry about using the <code>delete</code> or <code>delete[]</code> operator to free memory. It will be released automatically, when it is no longer needed. This means that dangling pointers and multiple deallocations, allocation/deallocation mismatches and memory leaks will no longer be possible.</p>
<ul>
<li><p>A <code>std::unique_ptr&lt;T&gt;</code> object behaves as a pointer to type <code>T</code> and is unique in the sense that there can be only one single <code>unique_ptr&lt;&gt;</code> object containing the same address. In other words, there can never be two or more <code>unique_ptr&lt;T&gt;</code> objects pointing to the same memory address at the same time. A <code>unique_ptr&lt;&gt;</code> object is said to own the object it points to exclusively. The uniqueness is enforced by the fact, that a compiler will never allow you to copy a <code>unique_ptr&lt;&gt;</code>.</p></li>
<li><p>A <code>std::shared_ptr&lt;T&gt;</code> object also behaves as a pointer to type <code>T</code>, but in contrast with <code>unique_ptr&lt;T&gt;</code> there can be any number of <code>shared_ptr&lt;&gt;</code> objects that allow <em>shared ownership</em> of an object in the free-store. At any given moment, the number of <code>shared_ptr&lt;&gt;</code> objects that contain a given address in time is known by the runtime. This is called <em>reference counting</em>. The reference count for a <code>shared_ptr&lt;&gt;</code> containing a given free store address is incremented each time a new <code>shared_ptr</code> object is creating containing that address, and its decremented when a <code>shared_ptr</code> containing the address is destroyed or assigned to point to a different address. When there are no <code>shared_ptr</code> objects containing a given address, the reference count will have dropped to zero, and the memory for the object at that address is released automatically. All <code>shared_ptr&lt;&gt;</code> objects that point to the same address have access to the the count of how many there are.</p></li>
<li><p>A <code>weak_ptr&lt;T&gt;</code> is linked to a <code>shared_ptr&lt;T&gt;</code> and contains the same address. Creating a <code>weak_ptr&lt;&gt;</code> does not increment the reference count associated with the linked <code>shared_ptr&lt;&gt;</code> object, though, so a <code>weak_ptr&lt;&gt;</code> does not prevent the object pointed to from being destroyed. Its memory will still be released when the last <code>shared_ptr&lt;&gt;</code> referencing it is destroyed or reassigned to point to a different address, even when associated <code>weak_ptr&lt;&gt;</code> objects still exist. If this happens, the <code>weak_ptr&lt;&gt;</code> will nevertheless not contain a dangling pointer, atleast not one that you could inadvertently access. The reason is that you cannot access the address encapsulated by a <code>weak_ptr&lt;T&gt;</code> directly. The compiler forces you to first create a <code>shared_ptr&lt;T&gt;</code> object out of it that refers to the same address. If the memory address for the <code>weak_ptr&lt;&gt;</code> is still valid, forcing you to create a <code>shared_ptr&lt;&gt;</code> first ensures that the reference count is again incremented and that the pointer can be used safely again. If the memory is released already, however, this operation will result in a <code>shared_ptr&lt;T&gt;</code> containing a <code>nullptr</code>.</p></li>
</ul>
<p>One use for having <code>weak_ptr&lt;&gt;</code> objects is to avoid so called reference cycles with <code>shared_ptr&lt;&gt;</code> objects. Conceptually, a reference cycle is where a <code>shared_ptr&lt;Y&gt;</code> inside the object <code>x</code> points to some other object <code>y</code> that contains a <code>shared_ptr&lt;X&gt;</code>, which points back to <code>x</code>. With this situation, neither <code>x</code> nor <code>y</code> can be destroyed. In practice, this may occur in many ways. <code>weak_ptr</code> allows you to break such cycles. Another use of weak pointers is in the implementation of object caches.</p>
<p>In the below code snippet, the destructors <code>~A()</code> and <code>~B()</code> are not invoked even when the objects <code>shrd_a</code> and <code>shrd_b</code> go out of scope.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;memory&gt;</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A<span class="op">;</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> B<span class="op">;</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A<span class="op">{</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    shared_ptr<span class="op">&lt;</span>B<span class="op">&gt;</span> <span class="va">m_b</span><span class="op">;</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>    A<span class="op">()</span> <span class="op">{</span>cout <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">A()"</span><span class="op">;}</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">~</span>A<span class="op">()</span> <span class="op">{</span>cout <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">~A()"</span><span class="op">;}</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> B<span class="op">{</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>    shared_ptr<span class="op">&lt;</span>A<span class="op">&gt;</span> <span class="va">m_a</span><span class="op">;</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>    B <span class="op">()</span> <span class="op">{</span>cout <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">B()"</span><span class="op">;}</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">~</span>B<span class="op">()</span> <span class="op">{</span>cout <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">~B()"</span><span class="op">;}</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>        shared_ptr<span class="op">&lt;</span>A<span class="op">&gt;</span> shrd_a <span class="op">{</span>make_shared<span class="op">&lt;</span>A<span class="op">&gt;()};</span> <span class="co">//A's ref count = 1</span></span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a>        shared_ptr<span class="op">&lt;</span>B<span class="op">&gt;</span> shrd_b <span class="op">{</span>make_shared<span class="op">&lt;</span>B<span class="op">&gt;()};</span> <span class="co">//B's ref count = 1</span></span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a>        shrd_a<span class="op">-&gt;</span><span class="va">m_b</span> <span class="op">=</span> shrd_b<span class="op">;</span> <span class="co">//B's ref count = 2</span></span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a>        shrd_b<span class="op">-&gt;</span><span class="va">m_a</span> <span class="op">=</span> shrd_a<span class="op">;</span> <span class="co">//A's ref count = 2</span></span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a>    <span class="co">//shrd_a and shrd_b go out of scope and are destroyed</span></span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a>    <span class="co">// A's ref count = 1</span></span>
<span id="cb3-34"><a href="#cb3-34" aria-hidden="true" tabindex="-1"></a>    <span class="co">// B's ref count = 1</span></span>
<span id="cb3-35"><a href="#cb3-35" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ((Memory of A, B is deallocated only when ref count drops to 0))</span></span>
<span id="cb3-36"><a href="#cb3-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb3-37"><a href="#cb3-37" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>A()
B()</code></pre>
<p>To solve it, the programmer needs to be aware of the ownership relationship among the objects, or needs to invent an ownership relationship, if no such ownership exists. The above C++ code can be changed so that A owns B:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;memory&gt;</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A<span class="op">;</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> B<span class="op">;</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A<span class="op">{</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>    shared_ptr<span class="op">&lt;</span>B<span class="op">&gt;</span> <span class="va">m_b</span><span class="op">;</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>    A<span class="op">()</span> <span class="op">{</span>cout <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">A()"</span><span class="op">;}</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">~</span>A<span class="op">()</span> <span class="op">{</span>cout <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">~A()"</span><span class="op">;}</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> B<span class="op">{</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>    weak_ptr<span class="op">&lt;</span>A<span class="op">&gt;</span> <span class="va">m_a</span><span class="op">;</span></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>    B <span class="op">()</span> <span class="op">{</span>cout <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">B()"</span><span class="op">;}</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">~</span>B<span class="op">()</span> <span class="op">{</span>cout <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">~B()"</span><span class="op">;}</span></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a>        shared_ptr<span class="op">&lt;</span>A<span class="op">&gt;</span> shrd_a <span class="op">{</span>make_shared<span class="op">&lt;</span>A<span class="op">&gt;()};</span> <span class="co">//A's ref count = 1</span></span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a>        shared_ptr<span class="op">&lt;</span>B<span class="op">&gt;</span> shrd_b <span class="op">{</span>make_shared<span class="op">&lt;</span>B<span class="op">&gt;()};</span> <span class="co">//B's ref count = 1</span></span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a>        shrd_a<span class="op">-&gt;</span><span class="va">m_b</span> <span class="op">=</span> shrd_b<span class="op">;</span> <span class="co">//B's ref count = 2</span></span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true" tabindex="-1"></a>        shrd_b<span class="op">-&gt;</span><span class="va">m_a</span> <span class="op">=</span> shrd_a<span class="op">;</span> <span class="co">//A's ref count = 1</span></span>
<span id="cb5-31"><a href="#cb5-31" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-32"><a href="#cb5-32" aria-hidden="true" tabindex="-1"></a>    <span class="co">//shrd_a and shrd_b go out of scope and are destroyed</span></span>
<span id="cb5-33"><a href="#cb5-33" aria-hidden="true" tabindex="-1"></a>    <span class="co">// A's ref count = 0</span></span>
<span id="cb5-34"><a href="#cb5-34" aria-hidden="true" tabindex="-1"></a>    <span class="co">// B's ref count = 1</span></span>
<span id="cb5-35"><a href="#cb5-35" aria-hidden="true" tabindex="-1"></a>    <span class="co">// A is destroyed</span></span>
<span id="cb5-36"><a href="#cb5-36" aria-hidden="true" tabindex="-1"></a>    <span class="co">// B's ref count = 0</span></span>
<span id="cb5-37"><a href="#cb5-37" aria-hidden="true" tabindex="-1"></a>    <span class="co">// B is destroyed</span></span>
<span id="cb5-38"><a href="#cb5-38" aria-hidden="true" tabindex="-1"></a>    <span class="co">//</span></span>
<span id="cb5-39"><a href="#cb5-39" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb5-40"><a href="#cb5-40" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>A()
B()
~A()
~B()</code></pre>
<section id="using-unique_ptrt-and-shared_ptrt-pointers." class="level3">
<h3 class="anchored" data-anchor-id="using-unique_ptrt-and-shared_ptrt-pointers.">Using <code>unique_ptr&lt;T&gt;</code> and <code>shared_ptr&lt;T&gt;</code> pointers.</h3>
<p>A <code>unique_ptr&lt;T&gt;</code> object stores an address uniquely, so the value to which it points is owned exlusively by the <code>unique_ptr&lt;T&gt;</code> smart pointer. When the <code>unique_ptr&lt;T&gt;</code> is destroyed, so is the value to which it points. Like all smart pointers, a <code>unique_ptr&lt;&gt;</code> is most useful when working with dynamically allocated objects. Objects then should not be shared by multiple parts of the program, or where the lifetime of the dynamic pobject is naturally tied to a single other object in your program.</p>
<p>One common use for a <code>unique_ptr&lt;&gt;</code> is to hold something called a <em>polymorphic pointer</em>, which in essence is a pointer to a dynamically allocated object that can be of any number of related class types.</p>
<p>To create and initialize a double variable on the free-store, we write:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;memory&gt;</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>unique_ptr<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> pDiscountFactor <span class="op">{</span><span class="bu">std::</span>make_unique<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;(</span><span class="fl">0.95</span><span class="op">)};</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"Discount Factor = "</span> <span class="op">&lt;&lt;</span> <span class="op">*</span>pDiscountFactor<span class="op">;</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>Discount Factor = 0.95</code></pre>
<p>The memory allocated on the free store holding <code>0.95</code> is released once <code>pDiscountFactor</code> goes out of scope and is destroyed after the <code>return</code> statement.</p>
<p>The below code snippet shows how smart pointers work.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;memory&gt;</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> X<span class="op">{</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>        X<span class="op">()</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>          <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">X created"</span><span class="op">;</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">~</span>X<span class="op">()</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>          <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">X destroyed"</span><span class="op">;</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Y<span class="op">{</span></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>        Y<span class="op">()</span></span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a>          <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">Y created"</span><span class="op">;</span></span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a>        <span class="op">~</span>Y<span class="op">()</span></span>
<span id="cb9-26"><a href="#cb9-26" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb9-27"><a href="#cb9-27" aria-hidden="true" tabindex="-1"></a>          <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">Y destroyed"</span><span class="op">;</span></span>
<span id="cb9-28"><a href="#cb9-28" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> </span>
<span id="cb9-29"><a href="#cb9-29" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb9-30"><a href="#cb9-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-31"><a href="#cb9-31" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb9-32"><a href="#cb9-32" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb9-33"><a href="#cb9-33" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">Inside main"</span><span class="op">;</span></span>
<span id="cb9-34"><a href="#cb9-34" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>shared_ptr<span class="op">&lt;</span>Y<span class="op">&gt;</span> sPtrY1 <span class="op">{</span><span class="bu">std::</span>make_shared<span class="op">&lt;</span>Y<span class="op">&gt;()};</span></span>
<span id="cb9-35"><a href="#cb9-35" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-36"><a href="#cb9-36" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-37"><a href="#cb9-37" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb9-38"><a href="#cb9-38" aria-hidden="true" tabindex="-1"></a>        <span class="co">//inner scope</span></span>
<span id="cb9-39"><a href="#cb9-39" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">Inside inner"</span><span class="op">;</span></span>
<span id="cb9-40"><a href="#cb9-40" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb9-41"><a href="#cb9-41" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>unique_ptr<span class="op">&lt;</span>X<span class="op">&gt;</span> uPtrX1 <span class="op">{</span><span class="bu">std::</span>make_unique<span class="op">&lt;</span>X<span class="op">&gt;()};</span></span>
<span id="cb9-42"><a href="#cb9-42" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>shared_ptr<span class="op">&lt;</span>Y<span class="op">&gt;</span> sPtrY2 <span class="op">{</span>sPtrY1<span class="op">};</span></span>
<span id="cb9-43"><a href="#cb9-43" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb9-44"><a href="#cb9-44" aria-hidden="true" tabindex="-1"></a>        <span class="co">// copy assignment and copy construction is not allowed on unique_ptr objects</span></span>
<span id="cb9-45"><a href="#cb9-45" aria-hidden="true" tabindex="-1"></a>        <span class="co">//std::unique_ptr&lt;X&gt; uPtrX2 = uPtrX1;</span></span>
<span id="cb9-46"><a href="#cb9-46" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb9-47"><a href="#cb9-47" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">Exiting inner"</span><span class="op">;</span></span>
<span id="cb9-48"><a href="#cb9-48" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-49"><a href="#cb9-49" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-50"><a href="#cb9-50" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">Exiting main"</span><span class="op">;</span></span>
<span id="cb9-51"><a href="#cb9-51" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb9-52"><a href="#cb9-52" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>Inside main
Y created
Inside inner
X created
Exiting inner
X destroyed
Exiting main
Y destroyed</code></pre>
</section>
</section>
<section id="references." class="level2">
<h2 class="anchored" data-anchor-id="references.">References.</h2>
<p>A reference is a name that you can use as an alias for another variable. Unlike a pointer, you cannot declare a reference and not initialize it. Because a reference is an alias, the variable which it is an alias must be provided when the reference is initialized. Also, a reference cannot be modified to be an alias for something else.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;memory&gt;</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> swap<span class="op">(</span><span class="dt">int</span><span class="op">&amp;</span> a<span class="op">,</span> <span class="dt">int</span><span class="op">&amp;</span> b<span class="op">)</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> temp <span class="op">{</span>a<span class="op">};</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>    a <span class="op">=</span> b<span class="op">;</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>    b <span class="op">=</span> temp<span class="op">;</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> x <span class="op">{</span><span class="dv">10</span><span class="op">};</span> </span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> y <span class="op">{</span><span class="dv">15</span><span class="op">};</span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st"> Before swap:"</span><span class="op">;</span></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st"> x = "</span> <span class="op">&lt;&lt;</span> x <span class="op">;</span></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st"> y = "</span> <span class="op">&lt;&lt;</span> y<span class="op">;</span></span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a>    swap<span class="op">(</span>x<span class="op">,</span>y<span class="op">);</span></span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st"> After swap:"</span><span class="op">;</span></span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st"> x = "</span> <span class="op">&lt;&lt;</span> x <span class="op">;</span></span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st"> y = "</span> <span class="op">&lt;&lt;</span> y<span class="op">;</span></span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb11-27"><a href="#cb11-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code> Before swap:
 x = 10
 y = 15
 After swap:
 x = 15
 y = 10</code></pre>
<p>Never return a pointer or reference to an automatic stack-allocated local variable from within a function. Automatic variables are destroyed and the stack is popped, once the control goes outside the scope in which they are declared.</p>
</section>
<section id="function-templates." class="level2">
<h2 class="anchored" data-anchor-id="function-templates.">Function Templates.</h2>
<p>A function template itself is not a definition of a function; it is a blueprint or a recipe for definining an entire family of functions. A function template is a parametric function definition, where a particular function instance is created by one or more parameter values. The compiler uses a function template to generate a function definition when necessary. If it is never necessary, no code results from the template. A function definition that is generated from a template is an <em>instance</em> or <em>instantiation</em> of the template.</p>
<p>The parameters of a function template are usually data-types, where an instance can be generated for a parameter value of type <code>int</code>, for example, and another with parameter valuer of type <code>string</code>. But parameters are not necessarily types. They can be other things such as a dimension, for example.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">class</span> T<span class="op">&gt;</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>T larger<span class="op">(</span>T a<span class="op">,</span> T b<span class="op">)</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> a <span class="op">&gt;</span> b <span class="op">?</span> a <span class="op">:</span> b<span class="op">;</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The compiler creates instances of the template from any statement that uses the <code>larger()</code> function. Here’s an example:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">Larger of 1.50 and 2.50 is : "</span>  <span class="op">&lt;&lt;</span> larger<span class="op">(</span><span class="fl">1.5</span><span class="op">,</span><span class="fl">2.5</span><span class="op">);</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>Larger of 1.50 and 2.50 is : 2.5</code></pre>
<p>You just use the function in the normal way. You don’t need to specify a value for the template parameter <code>T</code>. The compiler deduces the type that is to replace <code>T</code> from the arguments in the <code>larger</code> function call. This mechanism is referred to as <em>template argument deduction</em>. The arguments to <code>larger()</code> are literals of type <code>double</code>, so this call causes the compiler to search for an existing definition of <code>larger()</code> with <code>double</code> parameters. If it doesn’t find one, the compiler creates this version of <code>larger()</code> from the template by susbstituting <code>double</code> for <code>T</code> in the template definition.</p>
<p>The resulting function accepts arguments of type <code>double</code> and returs a <code>double</code> value.</p>
<p>The compiler makes sure to generate each template instance only once. If a subsequent function call requires the same instance, then it calls the instance that exists.</p>
<section id="template-type-parameters." class="level3">
<h3 class="anchored" data-anchor-id="template-type-parameters.">Template type parameters.</h3>
<p>The name of the template type parameter can be used anywhere in the template’s function signature, return type and body. It is a placeholder for a type and can thus be put in any context you would normally put a concrete type.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">class</span> T<span class="op">&gt;</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> T<span class="op">&amp;</span> larger<span class="op">(</span><span class="at">const</span> T<span class="op">&amp;</span> a<span class="op">,</span><span class="at">const</span> T<span class="op">&amp;</span> b<span class="op">)</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> a <span class="op">&gt;</span> b <span class="op">?</span> a <span class="op">:</span> b<span class="op">;</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="function-template-overloading." class="level3">
<h3 class="anchored" data-anchor-id="function-template-overloading.">Function Template overloading.</h3>
<p>Templated functions can be overloaded.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> T<span class="op">&amp;</span> largest<span class="op">(</span><span class="at">const</span> T<span class="op">&amp;</span> a<span class="op">,</span><span class="at">const</span> T<span class="op">&amp;</span> b<span class="op">)</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> a <span class="op">&gt;</span> b <span class="op">?</span> a <span class="op">:</span> b<span class="op">;</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> T largest<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span>T<span class="op">&gt;&amp;</span> data<span class="op">)</span></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>    T max <span class="op">{};</span></span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="kw">auto</span> v<span class="op">:</span>data<span class="op">)</span></span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>v <span class="op">&gt;=</span> max<span class="op">)</span></span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a>            max <span class="op">=</span> v<span class="op">;</span></span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> max<span class="op">;</span></span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb17-21"><a href="#cb17-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-22"><a href="#cb17-22" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb17-23"><a href="#cb17-23" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb17-24"><a href="#cb17-24" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">Larger of 1.50 and 2.50 is : "</span>  <span class="op">&lt;&lt;</span> largest<span class="op">(</span><span class="fl">1.5</span><span class="op">,</span><span class="fl">2.5</span><span class="op">);</span></span>
<span id="cb17-25"><a href="#cb17-25" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> data <span class="op">{</span></span>
<span id="cb17-26"><a href="#cb17-26" aria-hidden="true" tabindex="-1"></a>        <span class="dv">2</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">8</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">7</span><span class="op">,</span> <span class="dv">3</span></span>
<span id="cb17-27"><a href="#cb17-27" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb17-28"><a href="#cb17-28" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">Largest of [2,5,8,4,7,3] is : "</span> <span class="op">&lt;&lt;</span> largest<span class="op">(</span>data<span class="op">);</span></span>
<span id="cb17-29"><a href="#cb17-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb17-30"><a href="#cb17-30" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>Larger of 1.50 and 2.50 is : 2.5
Largest of [2,5,8,4,7,3] is : 8</code></pre>
</section>
</section>
<section id="classes-and-object-oriented-programming." class="level2">
<h2 class="anchored" data-anchor-id="classes-and-object-oriented-programming.">Classes and Object Oriented Programming.</h2>
<p>An interesting exercise to write a <code>Matrix&lt;T&gt;</code> class.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Matrix.h</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;initializer_list&gt;</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdexcept&gt;</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T <span class="op">=</span> <span class="dt">double</span><span class="op">&gt;</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Matrix <span class="op">{</span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">//Default constructor</span></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>    Matrix<span class="op">()</span> <span class="op">:</span> Matrix<span class="op">(</span><span class="dv">3</span><span class="op">,</span> <span class="dv">3</span><span class="op">)</span> <span class="op">{}</span></span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">//Parameterized constructor with number of rows, cols as </span></span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// as arguments.</span></span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a>    Matrix<span class="op">(</span><span class="bu">std::</span>size_t m<span class="op">,</span> <span class="bu">std::</span>size_t n<span class="op">)</span> <span class="op">:</span> <span class="va">m_rows</span><span class="op">(</span>m<span class="op">),</span> <span class="va">m_cols</span><span class="op">(</span>n<span class="op">)</span></span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a>        <span class="va">m_data</span><span class="op">.</span>resize<span class="op">(</span><span class="va">m_rows</span> <span class="op">*</span> <span class="va">m_cols</span><span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb19-19"><a href="#cb19-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-20"><a href="#cb19-20" aria-hidden="true" tabindex="-1"></a>    <span class="co">//Parameterized constructor with matrix elements provided </span></span>
<span id="cb19-21"><a href="#cb19-21" aria-hidden="true" tabindex="-1"></a>    <span class="co">// in brace initializer lists.</span></span>
<span id="cb19-22"><a href="#cb19-22" aria-hidden="true" tabindex="-1"></a>    Matrix<span class="op">(</span><span class="bu">std::</span>initializer_list<span class="op">&lt;</span><span class="bu">std::</span>initializer_list<span class="op">&lt;</span>T<span class="op">&gt;&gt;</span> m<span class="op">)</span> <span class="op">{</span></span>
<span id="cb19-23"><a href="#cb19-23" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> i<span class="op">{},</span> j<span class="op">{};</span></span>
<span id="cb19-24"><a href="#cb19-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> row <span class="op">:</span> m<span class="op">)</span></span>
<span id="cb19-25"><a href="#cb19-25" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb19-26"><a href="#cb19-26" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> el <span class="op">:</span> row<span class="op">)</span></span>
<span id="cb19-27"><a href="#cb19-27" aria-hidden="true" tabindex="-1"></a>            <span class="op">{</span></span>
<span id="cb19-28"><a href="#cb19-28" aria-hidden="true" tabindex="-1"></a>                <span class="va">m_data</span><span class="op">.</span>push_back<span class="op">(</span>el<span class="op">);</span></span>
<span id="cb19-29"><a href="#cb19-29" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>i <span class="op">==</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb19-30"><a href="#cb19-30" aria-hidden="true" tabindex="-1"></a>                    <span class="op">++</span>j<span class="op">;</span></span>
<span id="cb19-31"><a href="#cb19-31" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb19-32"><a href="#cb19-32" aria-hidden="true" tabindex="-1"></a>            <span class="op">++</span>i<span class="op">;</span></span>
<span id="cb19-33"><a href="#cb19-33" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb19-34"><a href="#cb19-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-35"><a href="#cb19-35" aria-hidden="true" tabindex="-1"></a>        <span class="va">m_rows</span> <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb19-36"><a href="#cb19-36" aria-hidden="true" tabindex="-1"></a>        <span class="va">m_cols</span> <span class="op">=</span> j<span class="op">;</span></span>
<span id="cb19-37"><a href="#cb19-37" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb19-38"><a href="#cb19-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-39"><a href="#cb19-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-40"><a href="#cb19-40" aria-hidden="true" tabindex="-1"></a>    <span class="co">//Copy constructor</span></span>
<span id="cb19-41"><a href="#cb19-41" aria-hidden="true" tabindex="-1"></a>    Matrix<span class="op">(</span><span class="at">const</span> Matrix<span class="op">&amp;</span> A<span class="op">)</span> <span class="op">:</span> <span class="va">m_rows</span><span class="op">{</span> A<span class="op">.</span><span class="va">m_rows</span> <span class="op">},</span> <span class="va">m_cols</span><span class="op">{</span> A<span class="op">.</span><span class="va">m_cols</span> <span class="op">},</span> <span class="va">m_data</span><span class="op">{</span> A<span class="op">.</span><span class="va">m_data</span> <span class="op">}</span> <span class="op">{}</span></span>
<span id="cb19-42"><a href="#cb19-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-43"><a href="#cb19-43" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>size_t rows<span class="op">()</span> <span class="at">const</span></span>
<span id="cb19-44"><a href="#cb19-44" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb19-45"><a href="#cb19-45" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">m_rows</span><span class="op">;</span></span>
<span id="cb19-46"><a href="#cb19-46" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb19-47"><a href="#cb19-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-48"><a href="#cb19-48" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>size_t cols<span class="op">()</span> <span class="at">const</span></span>
<span id="cb19-49"><a href="#cb19-49" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb19-50"><a href="#cb19-50" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">m_cols</span><span class="op">;</span></span>
<span id="cb19-51"><a href="#cb19-51" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb19-52"><a href="#cb19-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-53"><a href="#cb19-53" aria-hidden="true" tabindex="-1"></a>    T<span class="op">&amp;</span> at<span class="op">(</span><span class="dt">int</span> i<span class="op">,</span> <span class="dt">int</span> j<span class="op">)</span></span>
<span id="cb19-54"><a href="#cb19-54" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb19-55"><a href="#cb19-55" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">m_data</span><span class="op">[</span>i <span class="op">*</span> <span class="va">m_cols</span> <span class="op">+</span> j<span class="op">];</span></span>
<span id="cb19-56"><a href="#cb19-56" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb19-57"><a href="#cb19-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-58"><a href="#cb19-58" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> T<span class="op">&amp;</span> at<span class="op">(</span><span class="dt">int</span> i<span class="op">,</span> <span class="dt">int</span> j<span class="op">)</span> <span class="at">const</span></span>
<span id="cb19-59"><a href="#cb19-59" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb19-60"><a href="#cb19-60" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">m_data</span><span class="op">[</span>i <span class="op">*</span> <span class="va">m_cols</span> <span class="op">+</span> j<span class="op">];</span></span>
<span id="cb19-61"><a href="#cb19-61" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb19-62"><a href="#cb19-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-63"><a href="#cb19-63" aria-hidden="true" tabindex="-1"></a>    T<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">()(</span><span class="dt">int</span> i<span class="op">,</span> <span class="dt">int</span> j<span class="op">)</span></span>
<span id="cb19-64"><a href="#cb19-64" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb19-65"><a href="#cb19-65" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>i <span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb19-66"><a href="#cb19-66" aria-hidden="true" tabindex="-1"></a>            <span class="cf">throw</span> <span class="bu">std::</span>invalid_argument<span class="op">(</span><span class="st">"The row index must be non-negative!"</span><span class="op">);</span></span>
<span id="cb19-67"><a href="#cb19-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-68"><a href="#cb19-68" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>j <span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb19-69"><a href="#cb19-69" aria-hidden="true" tabindex="-1"></a>            <span class="cf">throw</span> <span class="bu">std::</span>invalid_argument<span class="op">(</span><span class="st">"The column index must be non-negative!"</span><span class="op">);</span></span>
<span id="cb19-70"><a href="#cb19-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-71"><a href="#cb19-71" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>i <span class="op">&gt;=</span> <span class="va">m_rows</span><span class="op">)</span></span>
<span id="cb19-72"><a href="#cb19-72" aria-hidden="true" tabindex="-1"></a>            <span class="cf">throw</span> <span class="bu">std::</span>invalid_argument<span class="op">(</span><span class="st">"The row index must be less than "</span> <span class="op">+</span> <span class="va">m_rows</span><span class="op">);</span></span>
<span id="cb19-73"><a href="#cb19-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-74"><a href="#cb19-74" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>j <span class="op">&gt;=</span> <span class="va">m_cols</span><span class="op">)</span></span>
<span id="cb19-75"><a href="#cb19-75" aria-hidden="true" tabindex="-1"></a>            <span class="cf">throw</span> <span class="bu">std::</span>invalid_argument<span class="op">(</span><span class="st">"The col index must be less than "</span> <span class="op">+</span> <span class="va">m_cols</span><span class="op">);</span></span>
<span id="cb19-76"><a href="#cb19-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-77"><a href="#cb19-77" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> at<span class="op">(</span>i<span class="op">,</span> j<span class="op">);</span></span>
<span id="cb19-78"><a href="#cb19-78" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb19-79"><a href="#cb19-79" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-80"><a href="#cb19-80" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> T <span class="kw">operator</span><span class="op">()(</span><span class="dt">int</span> i<span class="op">,</span> <span class="dt">int</span> j<span class="op">)</span> <span class="at">const</span></span>
<span id="cb19-81"><a href="#cb19-81" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb19-82"><a href="#cb19-82" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>i <span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb19-83"><a href="#cb19-83" aria-hidden="true" tabindex="-1"></a>            <span class="cf">throw</span> <span class="bu">std::</span>invalid_argument<span class="op">(</span><span class="st">"The row index must be non-negative!"</span><span class="op">);</span></span>
<span id="cb19-84"><a href="#cb19-84" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-85"><a href="#cb19-85" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>j <span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb19-86"><a href="#cb19-86" aria-hidden="true" tabindex="-1"></a>            <span class="cf">throw</span> <span class="bu">std::</span>invalid_argument<span class="op">(</span><span class="st">"The column index must be non-negative!"</span><span class="op">);</span></span>
<span id="cb19-87"><a href="#cb19-87" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-88"><a href="#cb19-88" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>i <span class="op">&gt;=</span> <span class="va">m_rows</span><span class="op">)</span></span>
<span id="cb19-89"><a href="#cb19-89" aria-hidden="true" tabindex="-1"></a>            <span class="cf">throw</span> <span class="bu">std::</span>invalid_argument<span class="op">(</span><span class="st">"The row index must be less than "</span> <span class="op">+</span> <span class="va">m_rows</span><span class="op">);</span></span>
<span id="cb19-90"><a href="#cb19-90" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-91"><a href="#cb19-91" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>j <span class="op">&gt;=</span> <span class="va">m_cols</span><span class="op">)</span></span>
<span id="cb19-92"><a href="#cb19-92" aria-hidden="true" tabindex="-1"></a>            <span class="cf">throw</span> <span class="bu">std::</span>invalid_argument<span class="op">(</span><span class="st">"The col index must be less than "</span> <span class="op">+</span> <span class="va">m_cols</span><span class="op">);</span></span>
<span id="cb19-93"><a href="#cb19-93" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-94"><a href="#cb19-94" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> at<span class="op">(</span>i<span class="op">,</span> j<span class="op">);</span></span>
<span id="cb19-95"><a href="#cb19-95" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb19-96"><a href="#cb19-96" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-97"><a href="#cb19-97" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> Matrix <span class="kw">operator</span><span class="op">+(</span><span class="at">const</span> Matrix<span class="op">&amp;</span> mat<span class="op">)</span></span>
<span id="cb19-98"><a href="#cb19-98" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb19-99"><a href="#cb19-99" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>mat<span class="op">.</span>rows<span class="op">()</span> <span class="op">!=</span> rows<span class="op">())</span></span>
<span id="cb19-100"><a href="#cb19-100" aria-hidden="true" tabindex="-1"></a>            <span class="cf">throw</span> <span class="bu">std::</span>runtime_error<span class="op">(</span><span class="st">"In A + B, matrices A, B should have the same number of rows!"</span><span class="op">);</span></span>
<span id="cb19-101"><a href="#cb19-101" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-102"><a href="#cb19-102" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>mat<span class="op">.</span>cols<span class="op">()</span> <span class="op">!=</span> cols<span class="op">())</span></span>
<span id="cb19-103"><a href="#cb19-103" aria-hidden="true" tabindex="-1"></a>            <span class="cf">throw</span> <span class="bu">std::</span>runtime_error<span class="op">(</span><span class="st">"In A + B, matrices A, B should have the same number of cols!"</span><span class="op">);</span></span>
<span id="cb19-104"><a href="#cb19-104" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-105"><a href="#cb19-105" aria-hidden="true" tabindex="-1"></a>        Matrix result<span class="op">(</span>rows<span class="op">(),</span> cols<span class="op">());</span></span>
<span id="cb19-106"><a href="#cb19-106" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-107"><a href="#cb19-107" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i<span class="op">{};</span> i <span class="op">&lt;</span> rows<span class="op">();</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb19-108"><a href="#cb19-108" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb19-109"><a href="#cb19-109" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j<span class="op">{};</span> j <span class="op">&lt;</span> cols<span class="op">();</span> <span class="op">++</span>j<span class="op">)</span></span>
<span id="cb19-110"><a href="#cb19-110" aria-hidden="true" tabindex="-1"></a>            <span class="op">{</span></span>
<span id="cb19-111"><a href="#cb19-111" aria-hidden="true" tabindex="-1"></a>                result<span class="op">(</span>i<span class="op">,</span> j<span class="op">)</span> <span class="op">=</span> at<span class="op">(</span>i<span class="op">,</span> j<span class="op">)</span> <span class="op">+</span> mat<span class="op">(</span>i<span class="op">,</span> j<span class="op">);</span></span>
<span id="cb19-112"><a href="#cb19-112" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb19-113"><a href="#cb19-113" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb19-114"><a href="#cb19-114" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> result<span class="op">;</span></span>
<span id="cb19-115"><a href="#cb19-115" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb19-116"><a href="#cb19-116" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-117"><a href="#cb19-117" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> Matrix <span class="kw">operator</span><span class="op">-(</span><span class="at">const</span> Matrix<span class="op">&amp;</span> mat<span class="op">)</span></span>
<span id="cb19-118"><a href="#cb19-118" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb19-119"><a href="#cb19-119" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>mat<span class="op">.</span>rows<span class="op">()</span> <span class="op">!=</span> rows<span class="op">())</span></span>
<span id="cb19-120"><a href="#cb19-120" aria-hidden="true" tabindex="-1"></a>            <span class="cf">throw</span> <span class="bu">std::</span>runtime_error<span class="op">(</span><span class="st">"In A - B, matrices A, B should have the same number of rows!"</span><span class="op">);</span></span>
<span id="cb19-121"><a href="#cb19-121" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-122"><a href="#cb19-122" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>mat<span class="op">.</span>cols<span class="op">()</span> <span class="op">!=</span> cols<span class="op">())</span></span>
<span id="cb19-123"><a href="#cb19-123" aria-hidden="true" tabindex="-1"></a>            <span class="cf">throw</span> <span class="bu">std::</span>runtime_error<span class="op">(</span><span class="st">"In A - B, matrices A, B should have the same number of cols!"</span><span class="op">);</span></span>
<span id="cb19-124"><a href="#cb19-124" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-125"><a href="#cb19-125" aria-hidden="true" tabindex="-1"></a>        Matrix result<span class="op">(</span>rows<span class="op">(),</span> cols<span class="op">());</span></span>
<span id="cb19-126"><a href="#cb19-126" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-127"><a href="#cb19-127" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i<span class="op">{};</span> i <span class="op">&lt;</span> rows<span class="op">();</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb19-128"><a href="#cb19-128" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb19-129"><a href="#cb19-129" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j<span class="op">{};</span> j <span class="op">&lt;</span> cols<span class="op">();</span> <span class="op">++</span>j<span class="op">)</span></span>
<span id="cb19-130"><a href="#cb19-130" aria-hidden="true" tabindex="-1"></a>            <span class="op">{</span></span>
<span id="cb19-131"><a href="#cb19-131" aria-hidden="true" tabindex="-1"></a>                result<span class="op">(</span>i<span class="op">,</span> j<span class="op">)</span> <span class="op">=</span> at<span class="op">(</span>i<span class="op">,</span> j<span class="op">)</span> <span class="op">-</span> mat<span class="op">(</span>i<span class="op">,</span> j<span class="op">);</span></span>
<span id="cb19-132"><a href="#cb19-132" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb19-133"><a href="#cb19-133" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb19-134"><a href="#cb19-134" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> result<span class="op">;</span></span>
<span id="cb19-135"><a href="#cb19-135" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb19-136"><a href="#cb19-136" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-137"><a href="#cb19-137" aria-hidden="true" tabindex="-1"></a>    Matrix<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">=(</span><span class="at">const</span> Matrix<span class="op">&amp;</span> mat<span class="op">)</span></span>
<span id="cb19-138"><a href="#cb19-138" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb19-139"><a href="#cb19-139" aria-hidden="true" tabindex="-1"></a>        <span class="va">m_data</span> <span class="op">=</span> mat<span class="op">.</span><span class="va">m_data</span><span class="op">;</span></span>
<span id="cb19-140"><a href="#cb19-140" aria-hidden="true" tabindex="-1"></a>        <span class="va">m_rows</span> <span class="op">=</span> mat<span class="op">.</span>rows<span class="op">();</span></span>
<span id="cb19-141"><a href="#cb19-141" aria-hidden="true" tabindex="-1"></a>        <span class="va">m_cols</span> <span class="op">=</span> mat<span class="op">.</span>cols<span class="op">();</span></span>
<span id="cb19-142"><a href="#cb19-142" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-143"><a href="#cb19-143" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">*</span><span class="kw">this</span><span class="op">;</span></span>
<span id="cb19-144"><a href="#cb19-144" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb19-145"><a href="#cb19-145" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-146"><a href="#cb19-146" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> Matrix <span class="kw">operator</span><span class="op">*(</span><span class="at">const</span> Matrix<span class="op">&amp;</span> mat<span class="op">)</span></span>
<span id="cb19-147"><a href="#cb19-147" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb19-148"><a href="#cb19-148" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>cols<span class="op">()</span> <span class="op">!=</span> mat<span class="op">.</span>rows<span class="op">())</span></span>
<span id="cb19-149"><a href="#cb19-149" aria-hidden="true" tabindex="-1"></a>            <span class="cf">throw</span> <span class="bu">std::</span>runtime_error<span class="op">(</span><span class="st">"In A * B, cols of A must equal rows of B!"</span><span class="op">);</span></span>
<span id="cb19-150"><a href="#cb19-150" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-151"><a href="#cb19-151" aria-hidden="true" tabindex="-1"></a>        Matrix result<span class="op">{</span> rows<span class="op">(),</span> mat<span class="op">.</span>cols<span class="op">()</span> <span class="op">};</span></span>
<span id="cb19-152"><a href="#cb19-152" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-153"><a href="#cb19-153" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i<span class="op">{};</span> i <span class="op">&lt;</span> rows<span class="op">();</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb19-154"><a href="#cb19-154" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb19-155"><a href="#cb19-155" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> k<span class="op">{};</span> k <span class="op">&lt;</span> cols<span class="op">();</span> <span class="op">++</span>k<span class="op">)</span></span>
<span id="cb19-156"><a href="#cb19-156" aria-hidden="true" tabindex="-1"></a>            <span class="op">{</span></span>
<span id="cb19-157"><a href="#cb19-157" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j<span class="op">{};</span> j <span class="op">&lt;</span> mat<span class="op">.</span>cols<span class="op">();</span> <span class="op">++</span>j<span class="op">)</span></span>
<span id="cb19-158"><a href="#cb19-158" aria-hidden="true" tabindex="-1"></a>                <span class="op">{</span></span>
<span id="cb19-159"><a href="#cb19-159" aria-hidden="true" tabindex="-1"></a>                    result<span class="op">(</span>i<span class="op">,</span> j<span class="op">)</span> <span class="op">+=</span> at<span class="op">(</span>i<span class="op">,</span> k<span class="op">)</span> <span class="op">*</span> mat<span class="op">(</span>k<span class="op">,</span> j<span class="op">);</span></span>
<span id="cb19-160"><a href="#cb19-160" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb19-161"><a href="#cb19-161" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb19-162"><a href="#cb19-162" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb19-163"><a href="#cb19-163" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-164"><a href="#cb19-164" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> result<span class="op">;</span></span>
<span id="cb19-165"><a href="#cb19-165" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb19-166"><a href="#cb19-166" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-167"><a href="#cb19-167" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-168"><a href="#cb19-168" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="cb19-169"><a href="#cb19-169" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="va">m_data</span><span class="op">{};</span></span>
<span id="cb19-170"><a href="#cb19-170" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="va">m_rows</span><span class="op">;</span></span>
<span id="cb19-171"><a href="#cb19-171" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="va">m_cols</span><span class="op">;</span></span>
<span id="cb19-172"><a href="#cb19-172" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb20"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="co">//Matrix.cpp</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">"Matrix.h"</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>    Matrix<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> A<span class="op">{</span></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">},</span></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span><span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">}</span></span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a>    Matrix<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> B<span class="op">{</span></span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">},</span></span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span><span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">}</span></span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true" tabindex="-1"></a>    Matrix<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> result <span class="op">=</span> A <span class="op">+</span> B<span class="op">;</span></span>
<span id="cb20-19"><a href="#cb20-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-20"><a href="#cb20-20" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> result<span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">)</span> <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\t</span><span class="st">"</span> <span class="op">&lt;&lt;</span> result<span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">)</span> <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span></span>
<span id="cb20-21"><a href="#cb20-21" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> result<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">)</span> <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\t</span><span class="st">"</span> <span class="op">&lt;&lt;</span> result<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb20-22"><a href="#cb20-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-23"><a href="#cb20-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb20-24"><a href="#cb20-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<section id="access-specifiers-and-class-hierarchies." class="level3">
<h3 class="anchored" data-anchor-id="access-specifiers-and-class-hierarchies.">Access specifiers and class hierarchies.</h3>
<ul>
<li><p>The private members of the base class are inaccessible to the derived class.</p></li>
<li><p>When the base class specifier is <code>public</code>, the access status of the inherited members remains unchanged. Thus, inherited <code>public</code> members are <code>public</code>, and inherited <code>protected</code> members are <code>protected</code> in a derived class.</p></li>
<li><p>When the base class specifier is <code>protected</code>, both public and protected members of the base class are inherited as <code>protected</code> members in the child class.</p></li>
<li><p>When the base class specifier is <code>private</code>, inherited <code>public</code> and <code>protected</code> members become <code>private</code> to the derived class, so that they’re accessible by member functions of the the derived class, but they cannot be accessed if they’re inherited in another derived class.</p></li>
</ul>
</section>
<section id="constructors-and-destructors-in-derived-classes." class="level3">
<h3 class="anchored" data-anchor-id="constructors-and-destructors-in-derived-classes.">Constructors and Destructors in derived classes.</h3>
<p>Every constructor of the derived class always starts by invoking a constructor of the base class. And that base class constructor then invokes the constructor of its base class, and so on.</p>
<p><em>Remark.</em> You cannot initialize the member variables of a base class in the initialization list for the derived class constructor. Not even if those members are public or protected.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A<span class="op">{</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>    A<span class="op">(){</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">Inside A's constructor"</span><span class="op">;</span></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">~</span>A<span class="op">()</span></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">Inside A's destructor"</span><span class="op">;</span></span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> B <span class="op">:</span> <span class="kw">public</span> A</span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true" tabindex="-1"></a>    B<span class="op">()</span></span>
<span id="cb21-20"><a href="#cb21-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb21-21"><a href="#cb21-21" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">Inside B's constructor"</span><span class="op">;</span></span>
<span id="cb21-22"><a href="#cb21-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb21-23"><a href="#cb21-23" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb21-24"><a href="#cb21-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">~</span>B<span class="op">()</span></span>
<span id="cb21-25"><a href="#cb21-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb21-26"><a href="#cb21-26" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">Inside B's destructor"</span><span class="op">;</span></span>
<span id="cb21-27"><a href="#cb21-27" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb21-28"><a href="#cb21-28" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb21-29"><a href="#cb21-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-30"><a href="#cb21-30" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb21-31"><a href="#cb21-31" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb21-32"><a href="#cb21-32" aria-hidden="true" tabindex="-1"></a>    B b<span class="op">;</span></span>
<span id="cb21-33"><a href="#cb21-33" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb21-34"><a href="#cb21-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb21-35"><a href="#cb21-35" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>Inside A's constructor
Inside B's constructor
Inside B's destructor
Inside A's destructor</code></pre>
<p>Suppose you have a base class <code>Parent</code>, two child classes <code>Child_1</code> and <code>Child_2</code> that inherit from <code>Parent</code> and a <code>Grandchild</code> class that inherits from <code>Child_1</code> and <code>Child_2</code>. This is the diamond problem, named after the shape of such inheritance diagrams. The <code>Grandchild</code> inherits two copies of <code>Parent</code> : one through <code>Child_1</code> and another through <code>Child_2</code>.</p>
<p>To prevent the duplication of the base class, we identify to the compiler that the base class should appear only once within the derived class. We do this by specifying the class as a <em>virtual base class</em> using the <code>virtual</code> keword. The <code>Child_1</code> and <code>Child_2</code> classes would be defined like this:</p>
<pre><code>class Child_1 : public virtual Parent
{
    //...
};

class Child_2 : public virtual Parent
{
    //...
};</code></pre>
</section>
<section id="polymorphism." class="level3">
<h3 class="anchored" data-anchor-id="polymorphism.">Polymorphism.</h3>
<p>Every derived class object is a base class object. So, you can use a base class pointer/reference to store the address of a derived class object. It is easy to implement dynamic dispatch through virtual methods.</p>
<p>The below code snippet is instructive in understanding run-time polymorphism.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;memory&gt;</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A <span class="op">{</span></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> foo<span class="op">()</span> <span class="op">{</span></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">Greetings from a!"</span><span class="op">;</span></span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> B <span class="op">:</span><span class="kw">public</span> A <span class="op">{</span></span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb24-15"><a href="#cb24-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="dt">void</span> foo<span class="op">()</span></span>
<span id="cb24-16"><a href="#cb24-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb24-17"><a href="#cb24-17" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">Greetings from b!"</span><span class="op">;</span></span>
<span id="cb24-18"><a href="#cb24-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb24-19"><a href="#cb24-19" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb24-20"><a href="#cb24-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-21"><a href="#cb24-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-22"><a href="#cb24-22" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> C <span class="op">:</span> <span class="kw">public</span> B <span class="op">{</span></span>
<span id="cb24-23"><a href="#cb24-23" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="cb24-24"><a href="#cb24-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="dt">void</span> foo<span class="op">()</span></span>
<span id="cb24-25"><a href="#cb24-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb24-26"><a href="#cb24-26" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">Greetings from c!"</span><span class="op">;</span></span>
<span id="cb24-27"><a href="#cb24-27" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb24-28"><a href="#cb24-28" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb24-29"><a href="#cb24-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-30"><a href="#cb24-30" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> D <span class="op">:</span> <span class="kw">public</span> C <span class="op">{</span></span>
<span id="cb24-31"><a href="#cb24-31" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb24-32"><a href="#cb24-32" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> foo<span class="op">()</span></span>
<span id="cb24-33"><a href="#cb24-33" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb24-34"><a href="#cb24-34" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">Greetings from d!"</span><span class="op">;</span></span>
<span id="cb24-35"><a href="#cb24-35" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb24-36"><a href="#cb24-36" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb24-37"><a href="#cb24-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-38"><a href="#cb24-38" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb24-39"><a href="#cb24-39" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb24-40"><a href="#cb24-40" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>shared_ptr<span class="op">&lt;</span>A<span class="op">&gt;</span> a_ptr <span class="op">=</span> <span class="bu">std::</span>make_shared<span class="op">&lt;</span>D<span class="op">&gt;();</span></span>
<span id="cb24-41"><a href="#cb24-41" aria-hidden="true" tabindex="-1"></a>    a_ptr <span class="op">-&gt;</span>foo<span class="op">();</span></span>
<span id="cb24-42"><a href="#cb24-42" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb24-43"><a href="#cb24-43" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>shared_ptr<span class="op">&lt;</span>B<span class="op">&gt;</span> b_ptr <span class="op">=</span> <span class="bu">std::</span>make_shared<span class="op">&lt;</span>D<span class="op">&gt;();</span></span>
<span id="cb24-44"><a href="#cb24-44" aria-hidden="true" tabindex="-1"></a>    b_ptr <span class="op">-&gt;</span>foo<span class="op">();</span></span>
<span id="cb24-45"><a href="#cb24-45" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb24-46"><a href="#cb24-46" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>shared_ptr<span class="op">&lt;</span>C<span class="op">&gt;</span> c_ptr <span class="op">=</span> <span class="bu">std::</span>make_shared<span class="op">&lt;</span>D<span class="op">&gt;();</span></span>
<span id="cb24-47"><a href="#cb24-47" aria-hidden="true" tabindex="-1"></a>    <span class="co">//c_ptr -&gt;foo();  //will not compile, foo() is a private member is not inherited by D</span></span>
<span id="cb24-48"><a href="#cb24-48" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb24-49"><a href="#cb24-49" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>shared_ptr<span class="op">&lt;</span>D<span class="op">&gt;</span> d_ptr <span class="op">=</span> <span class="bu">std::</span>make_shared<span class="op">&lt;</span>D<span class="op">&gt;();</span></span>
<span id="cb24-50"><a href="#cb24-50" aria-hidden="true" tabindex="-1"></a>    d_ptr <span class="op">-&gt;</span>foo<span class="op">();</span></span>
<span id="cb24-51"><a href="#cb24-51" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>Greetings from a!
Greetings from d!
Greetings from d!</code></pre>
<p>When you specify a function as <code>virtual</code> in a base class, you indicate to the compiler that you want dynamic binding for function calls in any class that’s derived from this base class. A function that you specify as <code>virtual</code> in the base class will be <code>virtual</code> in all classes that directly or indirectly derive from the base class. This is the case, whether or not you specify the function as <code>virtual</code> in the derived class.</p>
<p>The call to a virtual function using an <strong>object</strong> is always resolved statically. You only get dybamic resolution of calls to virtual functions through a pointer or a reference. Consider the below code snippet:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>    D d<span class="op">{};</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>    A<span class="op">&amp;</span> aRef <span class="op">=</span> d<span class="op">;</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>    B<span class="op">&amp;</span> bRef <span class="op">=</span> d<span class="op">;</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>    A a<span class="op">;</span> B b<span class="op">;</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>    aRef<span class="op">.</span>foo<span class="op">();</span></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a>    bRef<span class="op">.</span>foo<span class="op">();</span></span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a>    a<span class="op">.</span>foo<span class="op">();</span></span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a>    b<span class="op">.</span>foo<span class="op">();</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>Greetings from a!
Greetings from d!
Greetings from a!
Greetings from b!</code></pre>
<section id="requirements-for-a-virtual-function." class="level4">
<h4 class="anchored" data-anchor-id="requirements-for-a-virtual-function.">Requirements for a virtual function.</h4>
<p>For a function to be <code>virtual</code>, its definition in a derived class must have the same signature as it has in the base class. If the base class function is <code>const</code>, for instance, then the derive class function must also be <code>const</code>. Generally, the return type of a virtual function in a derived class must be the same as in the base class as well, but there’s an exception when the return type in the base class is a pointer or a reference to a class type. In this case, the derived class version of a virtual function may return a pointer or a reference to a more specialized type than that of the base. This is called <em>covariance</em>.</p>
<p>Another restriction is that a virtual function can’t be a template function.</p>
<p>In standard object-oriented programming terms, a function in a derived class that redefines a function of the base class is said to <em>override</em> this function. A function with the same name as a virtual function in a base class only <strong>overrides</strong> that function if the remainder of their signatures match exactly as well; if they do not, the function in the derived class is a new function that <em>hides</em> the one in the base class. This means that if you try to use different parameters for a virtual function in a derived class or use different <code>const</code> specifiers, then the virtual function mechanism won’t work. The function in the derived class then defines, a new different function - and this new function will therefore operate with static binding that is established and fixed at compile time.</p>
</section>
<section id="override-specifier." class="level4">
<h4 class="anchored" data-anchor-id="override-specifier."><code>override</code> specifier.</h4>
<p>The <code>override</code> specification guarantees that you don’t make mistakes in function overrides and these exactly match the virtual function signatures in base class.</p>
</section>
<section id="final-qualifier." class="level4">
<h4 class="anchored" data-anchor-id="final-qualifier."><code>final</code> qualifier.</h4>
<p>Sometimes, we may want to prevent a member function from being overriden in a derived class. We can do this by specifying that a function is <code>final</code>.</p>
</section>
</section>
<section id="virtual-destructors." class="level3">
<h3 class="anchored" data-anchor-id="virtual-destructors.">Virtual destructors.</h3>
<p>Along with the other function, the destructor methods of classes should also be resolved dynamically. That is, if a <code>Base*</code> pointer points to <code>Derived</code> object, the <code>Derived</code> class destructor method should be called first. (Object creation is top-down, destruction is bottom-up in an inheritance hierarchy). So, it’s always prudent to declare destructor methods as <code>virtual</code>.</p>
</section>
<section id="calling-the-base-class-version-of-a-virtual-function." class="level3">
<h3 class="anchored" data-anchor-id="calling-the-base-class-version-of-a-virtual-function.">Calling the base class version of a virtual function.</h3>
<p>It’s easy to call the derived class version of a virtual function through a pointer or reference to a derived class object - the call is made dynamically. However, what do you do when you actually want to call the base class function for a derived class object?</p>
<p>Consider the <code>Box</code> and <code>ToughPack</code> classes.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;memory&gt;</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Box<span class="op">{</span></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a>    Box<span class="op">()</span> <span class="op">:</span> Box<span class="op">(</span><span class="fl">1.0</span><span class="op">)</span> <span class="op">{}</span></span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a>    Box<span class="op">(</span><span class="dt">double</span> side<span class="op">)</span> <span class="op">:</span> Box<span class="op">(</span>side<span class="op">,</span> side<span class="op">,</span> side<span class="op">)</span> <span class="op">{}</span></span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a>    Box<span class="op">(</span><span class="dt">double</span> length<span class="op">,</span> <span class="dt">double</span> width<span class="op">,</span> <span class="dt">double</span> height<span class="op">)</span> <span class="op">:</span> <span class="va">m_length</span><span class="op">(</span>length<span class="op">),</span> <span class="va">m_width</span><span class="op">(</span>width<span class="op">),</span> <span class="va">m_height</span><span class="op">(</span>height<span class="op">)</span> <span class="op">{}</span></span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> <span class="kw">virtual</span> volume<span class="op">()</span></span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb28-14"><a href="#cb28-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">m_length</span> <span class="op">*</span> <span class="va">m_width</span> <span class="op">*</span> <span class="va">m_height</span><span class="op">;</span></span>
<span id="cb28-15"><a href="#cb28-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb28-16"><a href="#cb28-16" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-17"><a href="#cb28-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">~</span>Box<span class="op">()</span></span>
<span id="cb28-18"><a href="#cb28-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb28-19"><a href="#cb28-19" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">Box dtor"</span><span class="op">;</span></span>
<span id="cb28-20"><a href="#cb28-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb28-21"><a href="#cb28-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">protected</span><span class="op">:</span></span>
<span id="cb28-22"><a href="#cb28-22" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> <span class="va">m_length</span><span class="op">;</span></span>
<span id="cb28-23"><a href="#cb28-23" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> <span class="va">m_width</span><span class="op">;</span></span>
<span id="cb28-24"><a href="#cb28-24" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> <span class="va">m_height</span><span class="op">;</span></span>
<span id="cb28-25"><a href="#cb28-25" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb28-26"><a href="#cb28-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-27"><a href="#cb28-27" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> ToughPack <span class="op">:</span> <span class="kw">public</span> Box</span>
<span id="cb28-28"><a href="#cb28-28" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb28-29"><a href="#cb28-29" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb28-30"><a href="#cb28-30" aria-hidden="true" tabindex="-1"></a>    ToughPack<span class="op">()</span> <span class="op">:</span> Box<span class="op">()</span> <span class="op">{}</span></span>
<span id="cb28-31"><a href="#cb28-31" aria-hidden="true" tabindex="-1"></a>    ToughPack<span class="op">(</span><span class="dt">double</span> side<span class="op">)</span> <span class="op">:</span> Box<span class="op">(</span>side<span class="op">)</span> <span class="op">{}</span></span>
<span id="cb28-32"><a href="#cb28-32" aria-hidden="true" tabindex="-1"></a>    ToughPack<span class="op">(</span><span class="dt">double</span> x<span class="op">,</span> <span class="dt">double</span> y<span class="op">,</span> <span class="dt">double</span> z<span class="op">)</span> <span class="op">:</span> Box<span class="op">(</span>x<span class="op">,</span>y<span class="op">,</span>z<span class="op">)</span> <span class="op">{}</span></span>
<span id="cb28-33"><a href="#cb28-33" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-34"><a href="#cb28-34" aria-hidden="true" tabindex="-1"></a>    <span class="co">//Function to calculate volume allowing for 15% of packing</span></span>
<span id="cb28-35"><a href="#cb28-35" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> volume<span class="op">()</span> <span class="kw">override</span></span>
<span id="cb28-36"><a href="#cb28-36" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb28-37"><a href="#cb28-37" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="fl">0.85</span> <span class="op">*</span> <span class="va">m_length</span> <span class="op">*</span> <span class="va">m_width</span> <span class="op">*</span> <span class="va">m_height</span> <span class="op">;</span></span>
<span id="cb28-38"><a href="#cb28-38" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb28-39"><a href="#cb28-39" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-40"><a href="#cb28-40" aria-hidden="true" tabindex="-1"></a>    <span class="op">~</span>ToughPack<span class="op">()</span></span>
<span id="cb28-41"><a href="#cb28-41" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb28-42"><a href="#cb28-42" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">ToughPack dtor"</span><span class="op">;</span></span>
<span id="cb28-43"><a href="#cb28-43" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb28-44"><a href="#cb28-44" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>In <code>ToughPack</code>’s <code>volume()</code> method, the <code>m_length*m_width*m_height</code> part of the <code>return</code> statement is exactly the formula used to compute the <code>volume()</code> inside the base class <code>Box</code>. In this case, the amount of code we had to retype was limited, but this won’t always be the case. It would therefore be much better if you could simply call the base class version of this function isntead.</p>
<p>A plausible first attempt to do so would be:</p>
<pre><code>double volume() const override
{
    return 0.85 * volume(); // Infinite recursion!
}</code></pre>
<p>However, this would call <code>volume()</code> override itself, which would then be calling itself again, which would then be calling itself again! This leads to infinite recursion and a crash.</p>
<p>Calling the base class version from within a function override like this is common. The solution is to explicitly ask the compiler to call the base class version of the function.</p>
<pre><code>double volume() const override
{
    return 0.85 * Box::volume(); 
}</code></pre>
</section>
<section id="when-my-base-classs-constructor-calls-a-virtual-function-on-its-this-object-why-doesnt-my-derived-classs-override-of-that-virtual-function-get-invoked" class="level3">
<h3 class="anchored" data-anchor-id="when-my-base-classs-constructor-calls-a-virtual-function-on-its-this-object-why-doesnt-my-derived-classs-override-of-that-virtual-function-get-invoked">When my base class’s constructor calls a virtual function on its this object, why doesn’t my derived class’s override of that virtual function get invoked?</h3>
<p>What happens when we call virtual functions from inside constructors and destructors? Calling a polymorphic function from inside a constructor/desctructor is a recipe for disaster in most cases. It should be avoided whenver possible.</p>
<p>In a constructor, the virtual call mechanism is disabled, because overriding from derived classes hasn’t happened yet. Objects are constructed from <code>Base</code> up, “Base before derived”.</p>
<p>Since <code>Base</code> object must be constructed before <code>Derived</code>, the call to <code>f()</code> always resolves statically to <code>Base::f()</code> from inside the constructor.</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include</span><span class="im">&lt;string&gt;</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include</span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> B <span class="op">{</span></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>    B<span class="op">(</span><span class="at">const</span> string<span class="op">&amp;</span> ss<span class="op">)</span> <span class="op">{</span> cout <span class="op">&lt;&lt;</span> <span class="st">"B constructor</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span> f<span class="op">(</span>ss<span class="op">);</span> <span class="op">}</span></span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="dt">void</span> f<span class="op">(</span><span class="at">const</span> string<span class="op">&amp;)</span> <span class="op">{</span> cout <span class="op">&lt;&lt;</span> <span class="st">"B::f</span><span class="sc">\n</span><span class="st">"</span><span class="op">;}</span></span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> D <span class="op">:</span> <span class="kw">public</span> B <span class="op">{</span></span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a>    D<span class="op">(</span><span class="at">const</span> string <span class="op">&amp;</span> ss<span class="op">)</span> <span class="op">:</span>B<span class="op">(</span>ss<span class="op">)</span> <span class="op">{</span> cout <span class="op">&lt;&lt;</span> <span class="st">"D constructor</span><span class="sc">\n</span><span class="st">"</span><span class="op">;}</span></span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> f<span class="op">(</span><span class="at">const</span> string<span class="op">&amp;</span> ss<span class="op">)</span> <span class="op">{</span> cout <span class="op">&lt;&lt;</span> <span class="st">"D::f</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span> s <span class="op">=</span> ss<span class="op">;</span> <span class="op">}</span></span>
<span id="cb31-13"><a href="#cb31-13" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="cb31-14"><a href="#cb31-14" aria-hidden="true" tabindex="-1"></a>    string s<span class="op">;</span></span>
<span id="cb31-15"><a href="#cb31-15" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb31-16"><a href="#cb31-16" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb31-17"><a href="#cb31-17" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb31-18"><a href="#cb31-18" aria-hidden="true" tabindex="-1"></a>    D d<span class="op">(</span><span class="st">"Hello"</span><span class="op">);</span></span>
<span id="cb31-19"><a href="#cb31-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>B constructor
B::f
D constructor</code></pre>
</section>
<section id="how-can-i-set-up-my-class-so-it-wont-be-inherited-from" class="level3">
<h3 class="anchored" data-anchor-id="how-can-i-set-up-my-class-so-it-wont-be-inherited-from">How can I set up my class so it won’t be inherited from?</h3>
<p>Just declare the class as <code>final</code>.</p>
</section>
</section>
<section id="pure-virtual-functions." class="level2">
<h2 class="anchored" data-anchor-id="pure-virtual-functions.">Pure virtual functions.</h2>
<p>There are situations where we require a base class with a virtual function that’s redefined in each of the derived classes, but hwere there’s no meaningful definition for the function in the base class. For example, you might define a base class <code>Shape</code>, from which you derive classes definining specific shapes, such as <code>Circle</code>, <code>Ellipse</code>, <code>Rectangle</code>, <code>Hexagon</code> and so on. The <code>Shape</code> class could include a virtual function <code>area()</code>, that you’d call for the derived class object to compute the area of a particular shape. The <code>Shape</code> class itself, though, cannot possibly provide a meaningful implementation of the <code>area()</code> function, one that caters, for instance, to both <code>Circle</code>s and <code>Rectangle</code>s. This is a job for a <em>pure virtual function</em>.</p>
<p>The purpose of a pure virtual function is to enable the derived class versions of the function to be called polymorphically. To declare a pure virtual function rather than an ordinary virtual function that has a definition, you use the same syntax but add <code>=0</code> to it’s declaration within the class.</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;memory&gt;</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Shape <span class="op">{</span></span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a>    Shape<span class="op">()</span> <span class="op">=</span> <span class="cf">default</span><span class="op">;</span></span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="dt">double</span> area<span class="op">()</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> <span class="co">//pure virtual function</span></span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb33-11"><a href="#cb33-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-12"><a href="#cb33-12" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Rectangle <span class="op">:</span> <span class="kw">public</span> Shape <span class="op">{</span></span>
<span id="cb33-13"><a href="#cb33-13" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb33-14"><a href="#cb33-14" aria-hidden="true" tabindex="-1"></a>    Rectangle<span class="op">(</span><span class="dt">double</span> l<span class="op">,</span> <span class="dt">double</span> w<span class="op">)</span> <span class="op">:</span> <span class="va">m_length</span><span class="op">(</span>l<span class="op">),</span> <span class="va">m_width</span><span class="op">(</span>w<span class="op">)</span> <span class="op">{}</span></span>
<span id="cb33-15"><a href="#cb33-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-16"><a href="#cb33-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> area<span class="op">()</span> <span class="kw">override</span> <span class="op">{</span></span>
<span id="cb33-17"><a href="#cb33-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">m_length</span> <span class="op">*</span> <span class="va">m_width</span><span class="op">;</span></span>
<span id="cb33-18"><a href="#cb33-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb33-19"><a href="#cb33-19" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="cb33-20"><a href="#cb33-20" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> <span class="va">m_length</span><span class="op">;</span></span>
<span id="cb33-21"><a href="#cb33-21" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> <span class="va">m_width</span><span class="op">;</span></span>
<span id="cb33-22"><a href="#cb33-22" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb33-23"><a href="#cb33-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-24"><a href="#cb33-24" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Circle <span class="op">:</span> <span class="kw">public</span> Shape <span class="op">{</span></span>
<span id="cb33-25"><a href="#cb33-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-26"><a href="#cb33-26" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb33-27"><a href="#cb33-27" aria-hidden="true" tabindex="-1"></a>    Circle<span class="op">(</span><span class="dt">double</span> r<span class="op">)</span> <span class="op">:</span> <span class="va">m_radius</span><span class="op">(</span>r<span class="op">)</span> <span class="op">{}</span></span>
<span id="cb33-28"><a href="#cb33-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-29"><a href="#cb33-29" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> area<span class="op">()</span> <span class="kw">override</span> <span class="op">{</span></span>
<span id="cb33-30"><a href="#cb33-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="fl">3.14159</span> <span class="op">*</span> <span class="va">m_radius</span> <span class="op">*</span> <span class="va">m_radius</span><span class="op">;</span></span>
<span id="cb33-31"><a href="#cb33-31" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb33-32"><a href="#cb33-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-33"><a href="#cb33-33" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="cb33-34"><a href="#cb33-34" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> <span class="va">m_radius</span><span class="op">;</span></span>
<span id="cb33-35"><a href="#cb33-35" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb33-36"><a href="#cb33-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-37"><a href="#cb33-37" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb33-38"><a href="#cb33-38" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb33-39"><a href="#cb33-39" aria-hidden="true" tabindex="-1"></a>    <span class="co">//Let's create a container to hold different kinds of shapes</span></span>
<span id="cb33-40"><a href="#cb33-40" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>unique_ptr<span class="op">&lt;</span>Shape<span class="op">&gt;&gt;</span> shapes<span class="op">{};</span></span>
<span id="cb33-41"><a href="#cb33-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-42"><a href="#cb33-42" aria-hidden="true" tabindex="-1"></a>    shapes<span class="op">.</span>push_back<span class="op">(</span><span class="bu">std::</span>make_unique<span class="op">&lt;</span>Rectangle<span class="op">&gt;(</span><span class="fl">5.0</span><span class="op">,</span> <span class="fl">5.0</span><span class="op">));</span></span>
<span id="cb33-43"><a href="#cb33-43" aria-hidden="true" tabindex="-1"></a>    shapes<span class="op">.</span>push_back<span class="op">(</span><span class="bu">std::</span>make_unique<span class="op">&lt;</span>Circle<span class="op">&gt;(</span><span class="fl">3.0</span><span class="op">));</span></span>
<span id="cb33-44"><a href="#cb33-44" aria-hidden="true" tabindex="-1"></a>    shapes<span class="op">.</span>push_back<span class="op">(</span><span class="bu">std::</span>make_unique<span class="op">&lt;</span>Rectangle<span class="op">&gt;(</span><span class="fl">10.0</span><span class="op">,</span> <span class="fl">12.0</span><span class="op">));</span></span>
<span id="cb33-45"><a href="#cb33-45" aria-hidden="true" tabindex="-1"></a>    shapes<span class="op">.</span>push_back<span class="op">(</span><span class="bu">std::</span>make_unique<span class="op">&lt;</span>Circle<span class="op">&gt;(</span><span class="fl">5.0</span><span class="op">));</span></span>
<span id="cb33-46"><a href="#cb33-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-47"><a href="#cb33-47" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i<span class="op">{};</span> i <span class="op">&lt;</span> shapes<span class="op">.</span>size<span class="op">();</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb33-48"><a href="#cb33-48" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb33-49"><a href="#cb33-49" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">Area = "</span> <span class="op">&lt;&lt;</span> shapes<span class="op">[</span>i<span class="op">]-&gt;</span>area<span class="op">();</span></span>
<span id="cb33-50"><a href="#cb33-50" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb33-51"><a href="#cb33-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-52"><a href="#cb33-52" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb33-53"><a href="#cb33-53" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>Area = 25
Area = 28.2743
Area = 120
Area = 78.5397</code></pre>
</section>
<section id="abstract-classes." class="level2">
<h2 class="anchored" data-anchor-id="abstract-classes.">Abstract Classes.</h2>
<p>An abstract class purely exists for the purpose of deriving classes from it and cannot be instantiated.</p>
<p>Any class that contains atleast one pure virtual function is an abstract class. Because an abstract class cannot be instantiated, you cannot pass it by value to a function, a parameter of type <code>Shape</code> will not compile. Similarly, you cannot return a <code>Shape</code> object from a functiojn. However, pointers or references to an abstract class can be used as parameter or return types, so types such as <code>Shape*</code> <code>std::shared_ptr&lt;Shape&gt;</code> and <code>Shape&amp;</code> are fine in these settings.</p>
<p>Any class that inherits from <code>Shape</code> is obligated to provide an implementation of the <code>area()</code> method. If it doesn’t, it too is an abstract class. More specifically, if any pure virtual function of an abstract base class isn’t in a derived class, then the pure virtual function will be inherited as such, and the derived class becomes an abstract class.</p>
<p>Thus, abstract base classes (ABCs) are often used as interfaces.</p>


<!-- -->

</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/quantdev\.blog");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb35" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a><span class="an">title:</span><span class="co"> "C++ Refresher - Part I"</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a><span class="an">author:</span><span class="co"> "Quasar"</span></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a><span class="an">date:</span><span class="co"> "2023-12-18"</span></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a><span class="an">categories:</span><span class="co"> [C++]      </span></span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a><span class="an">toc:</span><span class="co"> true</span></span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a><span class="an">image:</span><span class="co"> "cpp.jpg"</span></span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a><span class="an">toc-depth:</span><span class="co"> 2</span></span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb35-10"><a href="#cb35-10" aria-hidden="true" tabindex="-1"></a><span class="fu">## Hazards of dynamic memory allocation.</span></span>
<span id="cb35-11"><a href="#cb35-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-12"><a href="#cb35-12" aria-hidden="true" tabindex="-1"></a><span class="fu">#### Dangling pointers and multiple deallocations.</span></span>
<span id="cb35-13"><a href="#cb35-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-14"><a href="#cb35-14" aria-hidden="true" tabindex="-1"></a>A *dangling pointer* is a pointer variable that still contains the address to the free store memory that has already been deallocated using <span class="in">`delete`</span> or <span class="in">`delete[]`</span>. Dereferencing a dangling pointer makes you read from, or even worse write to memory that might already be allocated to and used by other parts of the program, resulting in all kinds of unpredictable results. </span>
<span id="cb35-15"><a href="#cb35-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-16"><a href="#cb35-16" aria-hidden="true" tabindex="-1"></a>Multiple deallocations which occur when you deallocate an already deallocated memory (and hence dangling) pointer for a second time is a recipe for disaster.</span>
<span id="cb35-17"><a href="#cb35-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-18"><a href="#cb35-18" aria-hidden="true" tabindex="-1"></a>One basic strategy to guard yourself against dangling pointers is to always reset a pointer to <span class="in">`nullptr`</span>, after the memory it points to is released. However, in more complex programs, different parts of the code often collaborate by accessing the same memory - an object or an array of objects - all through distinct copies of the same pointer. In such cases, our simple strategy falls short. Which part of the code is going to call <span class="in">`delete`</span>/<span class="in">`delete[]`</span>? And when? How do you ensure that no other part of the code is still using the same dynamically allocated memory.</span>
<span id="cb35-19"><a href="#cb35-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-20"><a href="#cb35-20" aria-hidden="true" tabindex="-1"></a><span class="fu">#### Allocation/Deallocation mismatch.</span></span>
<span id="cb35-21"><a href="#cb35-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-22"><a href="#cb35-22" aria-hidden="true" tabindex="-1"></a>A dynamically allocated array, allocated using <span class="in">`new[]`</span>, is captured in a regular pointer cariable. But, so is a single allocated value that is allocated using <span class="in">`new`</span>.</span>
<span id="cb35-23"><a href="#cb35-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-24"><a href="#cb35-24" aria-hidden="true" tabindex="-1"></a><span class="in">```cpp</span></span>
<span id="cb35-25"><a href="#cb35-25" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span><span class="op">*</span> single_df <span class="op">{</span><span class="kw">new</span> <span class="dt">double</span> <span class="op">{</span><span class="fl">0.95</span><span class="op">}};</span></span>
<span id="cb35-26"><a href="#cb35-26" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span><span class="op">*</span> array_of_dfs <span class="op">{</span><span class="kw">new</span> <span class="dt">double</span><span class="op">[</span><span class="dv">3</span><span class="op">]</span> <span class="op">{</span><span class="fl">1.00</span><span class="op">,</span> <span class="fl">0.95</span><span class="op">,</span> <span class="fl">0.90</span><span class="op">}};</span></span>
<span id="cb35-27"><a href="#cb35-27" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb35-28"><a href="#cb35-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-29"><a href="#cb35-29" aria-hidden="true" tabindex="-1"></a>After this the compiler has no way to distinguish between the two, especially once such a pointer gets passed around different parts of the program. This means that the following two statements will compile without error.</span>
<span id="cb35-30"><a href="#cb35-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-31"><a href="#cb35-31" aria-hidden="true" tabindex="-1"></a><span class="in">```cpp</span></span>
<span id="cb35-32"><a href="#cb35-32" aria-hidden="true" tabindex="-1"></a><span class="kw">delete</span><span class="op">[]</span> single_df<span class="op">;</span></span>
<span id="cb35-33"><a href="#cb35-33" aria-hidden="true" tabindex="-1"></a><span class="kw">delete</span> array_of_dfs<span class="op">;</span></span>
<span id="cb35-34"><a href="#cb35-34" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb35-35"><a href="#cb35-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-36"><a href="#cb35-36" aria-hidden="true" tabindex="-1"></a>Every <span class="in">`new`</span> must be paired with a single <span class="in">`delete`</span>; every <span class="in">`new[]`</span> must be paired with a single <span class="in">`delete[]`</span>.</span>
<span id="cb35-37"><a href="#cb35-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-38"><a href="#cb35-38" aria-hidden="true" tabindex="-1"></a><span class="fu">#### Memory Leaks.</span></span>
<span id="cb35-39"><a href="#cb35-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-40"><a href="#cb35-40" aria-hidden="true" tabindex="-1"></a>A memory leak occurs when you allocate memory using <span class="in">`new`</span> or <span class="in">`new[]`</span> and fail to release it. If you lose the address of free store memory you have allocated by overwriting the address in the pointer you were using to access it, for instance, you have a memory leak. </span>
<span id="cb35-41"><a href="#cb35-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-42"><a href="#cb35-42" aria-hidden="true" tabindex="-1"></a>When it comes to scope, pointers are just like any other variable. The lifetime of a pointer extends from the point at which you define it in a block to the closing brace of the block. After that it no longer exists, the free store goes out of scope and it's no longer possible to delete the memory. </span>
<span id="cb35-43"><a href="#cb35-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-44"><a href="#cb35-44" aria-hidden="true" tabindex="-1"></a>It's still relatively easy to see, where you've simply forgotten to use <span class="in">`delete`</span> to free memory when use of the memory ceases at a point close to where you allocated it, but you'd be surprised how often programmers make mistakes like this, especially if, for instance, <span class="in">`return`</span> statements creep in between allocation and deallocation of your variable. And naturally, memory leaks are even more difficult to spot in complex programs, where memory may be allocated in part of the the program and should be released in a completely separate part.</span>
<span id="cb35-45"><a href="#cb35-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-46"><a href="#cb35-46" aria-hidden="true" tabindex="-1"></a>One basic strategy for avoiding memory leaks is to immediately add <span class="in">`delete`</span> operation at an appropriate place each time you use the <span class="in">`new`</span> operator. But this strategy by no means is fail-safe. Even C++ programmers are fallible creatures.</span>
<span id="cb35-47"><a href="#cb35-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-48"><a href="#cb35-48" aria-hidden="true" tabindex="-1"></a><span class="fu">#### Fragmentation of the Free-Store.</span></span>
<span id="cb35-49"><a href="#cb35-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-50"><a href="#cb35-50" aria-hidden="true" tabindex="-1"></a>Memory fragmentation can arise in programs that frequently dynamically allocate and release memory blocks. Each time, the <span class="in">`new`</span> operator is used, it allocates a contiguous block of bytes. If you create and destroy many memory blocks of different sizes, it's possible to arrive at a situation in which the allocated memory is interspersed with small blocks of free memory, none of which is large enough to accomodate a new memory allocation request by your program. The aggregate of the free memory can be quite large, but if all the individual blocks are small (smaller than a current allocation request), the allocation request will fail.</span>
<span id="cb35-51"><a href="#cb35-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-52"><a href="#cb35-52" aria-hidden="true" tabindex="-1"></a><span class="fu">### Golden rule of dynamic memory allocation.</span></span>
<span id="cb35-53"><a href="#cb35-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-54"><a href="#cb35-54" aria-hidden="true" tabindex="-1"></a>Never use the operators <span class="in">`new`</span>, <span class="in">`new[]`</span>, <span class="in">`delete`</span> and <span class="in">`delete[]`</span> directly in day-to-day coding. These operators have no place in modern C++ code. Always use either the <span class="in">`std::vector&lt;T&gt;`</span> container to replace dynamic arrays or a smart pointer to dynamically allocate individual objects and manage their lifetimes. </span>
<span id="cb35-55"><a href="#cb35-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-56"><a href="#cb35-56" aria-hidden="true" tabindex="-1"></a><span class="fu">## Raw pointers and Smart Pointers.</span></span>
<span id="cb35-57"><a href="#cb35-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-58"><a href="#cb35-58" aria-hidden="true" tabindex="-1"></a>Pointer types <span class="in">`int*`</span>, <span class="in">`double*`</span> are referred to as *raw pointers* because variables of these types contain nothing more than an address. A raw pointer can store the address of an automatic variable or a memory-block allocated in the free-store. </span>
<span id="cb35-59"><a href="#cb35-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-60"><a href="#cb35-60" aria-hidden="true" tabindex="-1"></a>A *smart pointer* is an object that mimics a raw pointer in that, it contains an address, and you can use it in the same way in many respects. Smart pointers are normally used only to store the address of memory allocated in the free store. A smart pointer does much more than a raw pointer, though. The most notable feature of a smart pointer, is that we don't have to worry about using the <span class="in">`delete`</span> or <span class="in">`delete[]`</span> operator to free memory. It will be released automatically, when it is no longer needed. This means that dangling pointers and multiple deallocations, allocation/deallocation mismatches and memory leaks will no longer be possible. </span>
<span id="cb35-61"><a href="#cb35-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-62"><a href="#cb35-62" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>A <span class="in">`std::unique_ptr&lt;T&gt;`</span> object behaves as a pointer to type <span class="in">`T`</span> and is unique in the sense that there can be only one single <span class="in">`unique_ptr&lt;&gt;`</span> object containing the same address. In other words, there can never be two or more <span class="in">`unique_ptr&lt;T&gt;`</span> objects pointing to the same memory address at the same time. A <span class="in">`unique_ptr&lt;&gt;`</span> object is said to own the object it points to exclusively. The uniqueness is enforced by the fact, that a compiler will never allow you to copy a <span class="in">`unique_ptr&lt;&gt;`</span>.</span>
<span id="cb35-63"><a href="#cb35-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-64"><a href="#cb35-64" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>A <span class="in">`std::shared_ptr&lt;T&gt;`</span> object also behaves as a pointer to type <span class="in">`T`</span>, but in contrast with <span class="in">`unique_ptr&lt;T&gt;`</span> there can be any number of <span class="in">`shared_ptr&lt;&gt;`</span> objects that allow *shared ownership* of an object in the free-store. At any given moment, the number of `shared_ptr&lt;&gt;` objects that contain a given address in time is known by the runtime. This is called *reference counting*. The reference count for a <span class="in">`shared_ptr&lt;&gt;`</span> containing a given free store address is incremented each time a new <span class="in">`shared_ptr`</span> object is creating containing that address, and its decremented when a <span class="in">`shared_ptr`</span> containing the address is destroyed or assigned to point to a different address. When there are no <span class="in">`shared_ptr`</span> objects containing a given address, the reference count will have dropped to zero, and the memory for the object at that address is released automatically. All <span class="in">`shared_ptr&lt;&gt;`</span> objects that point to the same address have access to the the count of how many there are.</span>
<span id="cb35-65"><a href="#cb35-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-66"><a href="#cb35-66" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>A <span class="in">`weak_ptr&lt;T&gt;`</span> is linked to a <span class="in">`shared_ptr&lt;T&gt;`</span> and contains the same address. Creating a <span class="in">`weak_ptr&lt;&gt;`</span> does not increment the reference count associated with the linked <span class="in">`shared_ptr&lt;&gt;`</span> object, though, so a <span class="in">`weak_ptr&lt;&gt;`</span> does not prevent the object pointed to from being destroyed. Its memory will still be released when the last <span class="in">`shared_ptr&lt;&gt;`</span> referencing it is destroyed or reassigned to point to a different address, even when associated <span class="in">`weak_ptr&lt;&gt;`</span> objects still exist. If this happens, the <span class="in">`weak_ptr&lt;&gt;`</span> will nevertheless not contain a dangling pointer, atleast not one that you could inadvertently access. The reason is that you cannot access the address encapsulated by a <span class="in">`weak_ptr&lt;T&gt;`</span> directly. The compiler forces you to first create a <span class="in">`shared_ptr&lt;T&gt;`</span> object out of it that refers to the same address. If the memory address for the <span class="in">`weak_ptr&lt;&gt;`</span> is still valid, forcing you to create a <span class="in">`shared_ptr&lt;&gt;`</span> first ensures that the reference count is again incremented and that the pointer can be used safely again. If the memory is released already, however, this operation will result in a <span class="in">`shared_ptr&lt;T&gt;`</span> containing a <span class="in">`nullptr`</span>.</span>
<span id="cb35-67"><a href="#cb35-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-68"><a href="#cb35-68" aria-hidden="true" tabindex="-1"></a>One use for having <span class="in">`weak_ptr&lt;&gt;`</span> objects is to avoid so called reference cycles with <span class="in">`shared_ptr&lt;&gt;`</span> objects. Conceptually, a reference cycle is where a <span class="in">`shared_ptr&lt;Y&gt;`</span> inside the object <span class="in">`x`</span> points to some other object <span class="in">`y`</span> that contains a <span class="in">`shared_ptr&lt;X&gt;`</span>, which points back to <span class="in">`x`</span>. With this situation, neither <span class="in">`x`</span> nor <span class="in">`y`</span> can be destroyed. In practice, this may occur in many ways. <span class="in">`weak_ptr`</span> allows you to break such cycles. Another use of weak pointers is in the implementation of object caches. </span>
<span id="cb35-69"><a href="#cb35-69" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-70"><a href="#cb35-70" aria-hidden="true" tabindex="-1"></a>In the below code snippet, the destructors <span class="in">`~A()`</span> and <span class="in">`~B()`</span> are not invoked even when the objects <span class="in">`shrd_a`</span> and <span class="in">`shrd_b`</span> go out of scope.</span>
<span id="cb35-71"><a href="#cb35-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-72"><a href="#cb35-72" aria-hidden="true" tabindex="-1"></a><span class="in">```cpp</span></span>
<span id="cb35-73"><a href="#cb35-73" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb35-74"><a href="#cb35-74" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;memory&gt;</span></span>
<span id="cb35-75"><a href="#cb35-75" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-76"><a href="#cb35-76" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb35-77"><a href="#cb35-77" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-78"><a href="#cb35-78" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A<span class="op">;</span></span>
<span id="cb35-79"><a href="#cb35-79" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> B<span class="op">;</span></span>
<span id="cb35-80"><a href="#cb35-80" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-81"><a href="#cb35-81" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A<span class="op">{</span></span>
<span id="cb35-82"><a href="#cb35-82" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb35-83"><a href="#cb35-83" aria-hidden="true" tabindex="-1"></a>    shared_ptr<span class="op">&lt;</span>B<span class="op">&gt;</span> <span class="va">m_b</span><span class="op">;</span></span>
<span id="cb35-84"><a href="#cb35-84" aria-hidden="true" tabindex="-1"></a>    A<span class="op">()</span> <span class="op">{</span>cout <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">A()"</span><span class="op">;}</span></span>
<span id="cb35-85"><a href="#cb35-85" aria-hidden="true" tabindex="-1"></a>    <span class="op">~</span>A<span class="op">()</span> <span class="op">{</span>cout <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">~A()"</span><span class="op">;}</span></span>
<span id="cb35-86"><a href="#cb35-86" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb35-87"><a href="#cb35-87" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-88"><a href="#cb35-88" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> B<span class="op">{</span></span>
<span id="cb35-89"><a href="#cb35-89" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb35-90"><a href="#cb35-90" aria-hidden="true" tabindex="-1"></a>    shared_ptr<span class="op">&lt;</span>A<span class="op">&gt;</span> <span class="va">m_a</span><span class="op">;</span></span>
<span id="cb35-91"><a href="#cb35-91" aria-hidden="true" tabindex="-1"></a>    B <span class="op">()</span> <span class="op">{</span>cout <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">B()"</span><span class="op">;}</span></span>
<span id="cb35-92"><a href="#cb35-92" aria-hidden="true" tabindex="-1"></a>    <span class="op">~</span>B<span class="op">()</span> <span class="op">{</span>cout <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">~B()"</span><span class="op">;}</span></span>
<span id="cb35-93"><a href="#cb35-93" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb35-94"><a href="#cb35-94" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-95"><a href="#cb35-95" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb35-96"><a href="#cb35-96" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb35-97"><a href="#cb35-97" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb35-98"><a href="#cb35-98" aria-hidden="true" tabindex="-1"></a>        shared_ptr<span class="op">&lt;</span>A<span class="op">&gt;</span> shrd_a <span class="op">{</span>make_shared<span class="op">&lt;</span>A<span class="op">&gt;()};</span> <span class="co">//A's ref count = 1</span></span>
<span id="cb35-99"><a href="#cb35-99" aria-hidden="true" tabindex="-1"></a>        shared_ptr<span class="op">&lt;</span>B<span class="op">&gt;</span> shrd_b <span class="op">{</span>make_shared<span class="op">&lt;</span>B<span class="op">&gt;()};</span> <span class="co">//B's ref count = 1</span></span>
<span id="cb35-100"><a href="#cb35-100" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb35-101"><a href="#cb35-101" aria-hidden="true" tabindex="-1"></a>        shrd_a<span class="op">-&gt;</span><span class="va">m_b</span> <span class="op">=</span> shrd_b<span class="op">;</span> <span class="co">//B's ref count = 2</span></span>
<span id="cb35-102"><a href="#cb35-102" aria-hidden="true" tabindex="-1"></a>        shrd_b<span class="op">-&gt;</span><span class="va">m_a</span> <span class="op">=</span> shrd_a<span class="op">;</span> <span class="co">//A's ref count = 2</span></span>
<span id="cb35-103"><a href="#cb35-103" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb35-104"><a href="#cb35-104" aria-hidden="true" tabindex="-1"></a>    <span class="co">//shrd_a and shrd_b go out of scope and are destroyed</span></span>
<span id="cb35-105"><a href="#cb35-105" aria-hidden="true" tabindex="-1"></a>    <span class="co">// A's ref count = 1</span></span>
<span id="cb35-106"><a href="#cb35-106" aria-hidden="true" tabindex="-1"></a>    <span class="co">// B's ref count = 1</span></span>
<span id="cb35-107"><a href="#cb35-107" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ((Memory of A, B is deallocated only when ref count drops to 0))</span></span>
<span id="cb35-108"><a href="#cb35-108" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb35-109"><a href="#cb35-109" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb35-110"><a href="#cb35-110" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb35-111"><a href="#cb35-111" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-112"><a href="#cb35-112" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb35-113"><a href="#cb35-113" aria-hidden="true" tabindex="-1"></a><span class="in">A()</span></span>
<span id="cb35-114"><a href="#cb35-114" aria-hidden="true" tabindex="-1"></a><span class="in">B()</span></span>
<span id="cb35-115"><a href="#cb35-115" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb35-116"><a href="#cb35-116" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-117"><a href="#cb35-117" aria-hidden="true" tabindex="-1"></a>To solve it, the programmer needs to be aware of the ownership relationship among the objects, or needs to invent an ownership relationship, if no such ownership exists. The above C++ code can be changed so that A owns B:</span>
<span id="cb35-118"><a href="#cb35-118" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-119"><a href="#cb35-119" aria-hidden="true" tabindex="-1"></a><span class="in">```cpp</span></span>
<span id="cb35-120"><a href="#cb35-120" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb35-121"><a href="#cb35-121" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;memory&gt;</span></span>
<span id="cb35-122"><a href="#cb35-122" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-123"><a href="#cb35-123" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb35-124"><a href="#cb35-124" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-125"><a href="#cb35-125" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A<span class="op">;</span></span>
<span id="cb35-126"><a href="#cb35-126" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> B<span class="op">;</span></span>
<span id="cb35-127"><a href="#cb35-127" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-128"><a href="#cb35-128" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A<span class="op">{</span></span>
<span id="cb35-129"><a href="#cb35-129" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb35-130"><a href="#cb35-130" aria-hidden="true" tabindex="-1"></a>    shared_ptr<span class="op">&lt;</span>B<span class="op">&gt;</span> <span class="va">m_b</span><span class="op">;</span></span>
<span id="cb35-131"><a href="#cb35-131" aria-hidden="true" tabindex="-1"></a>    A<span class="op">()</span> <span class="op">{</span>cout <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">A()"</span><span class="op">;}</span></span>
<span id="cb35-132"><a href="#cb35-132" aria-hidden="true" tabindex="-1"></a>    <span class="op">~</span>A<span class="op">()</span> <span class="op">{</span>cout <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">~A()"</span><span class="op">;}</span></span>
<span id="cb35-133"><a href="#cb35-133" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb35-134"><a href="#cb35-134" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-135"><a href="#cb35-135" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> B<span class="op">{</span></span>
<span id="cb35-136"><a href="#cb35-136" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb35-137"><a href="#cb35-137" aria-hidden="true" tabindex="-1"></a>    weak_ptr<span class="op">&lt;</span>A<span class="op">&gt;</span> <span class="va">m_a</span><span class="op">;</span></span>
<span id="cb35-138"><a href="#cb35-138" aria-hidden="true" tabindex="-1"></a>    B <span class="op">()</span> <span class="op">{</span>cout <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">B()"</span><span class="op">;}</span></span>
<span id="cb35-139"><a href="#cb35-139" aria-hidden="true" tabindex="-1"></a>    <span class="op">~</span>B<span class="op">()</span> <span class="op">{</span>cout <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">~B()"</span><span class="op">;}</span></span>
<span id="cb35-140"><a href="#cb35-140" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb35-141"><a href="#cb35-141" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-142"><a href="#cb35-142" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb35-143"><a href="#cb35-143" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb35-144"><a href="#cb35-144" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb35-145"><a href="#cb35-145" aria-hidden="true" tabindex="-1"></a>        shared_ptr<span class="op">&lt;</span>A<span class="op">&gt;</span> shrd_a <span class="op">{</span>make_shared<span class="op">&lt;</span>A<span class="op">&gt;()};</span> <span class="co">//A's ref count = 1</span></span>
<span id="cb35-146"><a href="#cb35-146" aria-hidden="true" tabindex="-1"></a>        shared_ptr<span class="op">&lt;</span>B<span class="op">&gt;</span> shrd_b <span class="op">{</span>make_shared<span class="op">&lt;</span>B<span class="op">&gt;()};</span> <span class="co">//B's ref count = 1</span></span>
<span id="cb35-147"><a href="#cb35-147" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb35-148"><a href="#cb35-148" aria-hidden="true" tabindex="-1"></a>        shrd_a<span class="op">-&gt;</span><span class="va">m_b</span> <span class="op">=</span> shrd_b<span class="op">;</span> <span class="co">//B's ref count = 2</span></span>
<span id="cb35-149"><a href="#cb35-149" aria-hidden="true" tabindex="-1"></a>        shrd_b<span class="op">-&gt;</span><span class="va">m_a</span> <span class="op">=</span> shrd_a<span class="op">;</span> <span class="co">//A's ref count = 1</span></span>
<span id="cb35-150"><a href="#cb35-150" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb35-151"><a href="#cb35-151" aria-hidden="true" tabindex="-1"></a>    <span class="co">//shrd_a and shrd_b go out of scope and are destroyed</span></span>
<span id="cb35-152"><a href="#cb35-152" aria-hidden="true" tabindex="-1"></a>    <span class="co">// A's ref count = 0</span></span>
<span id="cb35-153"><a href="#cb35-153" aria-hidden="true" tabindex="-1"></a>    <span class="co">// B's ref count = 1</span></span>
<span id="cb35-154"><a href="#cb35-154" aria-hidden="true" tabindex="-1"></a>    <span class="co">// A is destroyed</span></span>
<span id="cb35-155"><a href="#cb35-155" aria-hidden="true" tabindex="-1"></a>    <span class="co">// B's ref count = 0</span></span>
<span id="cb35-156"><a href="#cb35-156" aria-hidden="true" tabindex="-1"></a>    <span class="co">// B is destroyed</span></span>
<span id="cb35-157"><a href="#cb35-157" aria-hidden="true" tabindex="-1"></a>    <span class="co">//</span></span>
<span id="cb35-158"><a href="#cb35-158" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb35-159"><a href="#cb35-159" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb35-160"><a href="#cb35-160" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb35-161"><a href="#cb35-161" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-162"><a href="#cb35-162" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb35-163"><a href="#cb35-163" aria-hidden="true" tabindex="-1"></a><span class="in">A()</span></span>
<span id="cb35-164"><a href="#cb35-164" aria-hidden="true" tabindex="-1"></a><span class="in">B()</span></span>
<span id="cb35-165"><a href="#cb35-165" aria-hidden="true" tabindex="-1"></a><span class="in">~A()</span></span>
<span id="cb35-166"><a href="#cb35-166" aria-hidden="true" tabindex="-1"></a><span class="in">~B()</span></span>
<span id="cb35-167"><a href="#cb35-167" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb35-168"><a href="#cb35-168" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-169"><a href="#cb35-169" aria-hidden="true" tabindex="-1"></a><span class="fu">### Using `unique_ptr&lt;T&gt;` and `shared_ptr&lt;T&gt;` pointers.</span></span>
<span id="cb35-170"><a href="#cb35-170" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-171"><a href="#cb35-171" aria-hidden="true" tabindex="-1"></a>A <span class="in">`unique_ptr&lt;T&gt;`</span> object stores an address uniquely, so the value to which it points is owned exlusively by the <span class="in">`unique_ptr&lt;T&gt;`</span> smart pointer. When the <span class="in">`unique_ptr&lt;T&gt;`</span> is destroyed, so is the value to which it points. Like all smart pointers, a <span class="in">`unique_ptr&lt;&gt;`</span> is most useful when working with dynamically allocated objects. Objects then should not be shared by multiple parts of the program, or where the lifetime of the dynamic pobject is naturally tied to a single other object in your program. </span>
<span id="cb35-172"><a href="#cb35-172" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-173"><a href="#cb35-173" aria-hidden="true" tabindex="-1"></a>One common use for a <span class="in">`unique_ptr&lt;&gt;`</span> is to hold something called a *polymorphic pointer*, which in essence is a pointer to a dynamically allocated object that can be of any number of related class types.</span>
<span id="cb35-174"><a href="#cb35-174" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-175"><a href="#cb35-175" aria-hidden="true" tabindex="-1"></a>To create and initialize a double variable on the free-store, we write:</span>
<span id="cb35-176"><a href="#cb35-176" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-177"><a href="#cb35-177" aria-hidden="true" tabindex="-1"></a><span class="in">```cpp</span></span>
<span id="cb35-178"><a href="#cb35-178" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb35-179"><a href="#cb35-179" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;memory&gt;</span></span>
<span id="cb35-180"><a href="#cb35-180" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-181"><a href="#cb35-181" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb35-182"><a href="#cb35-182" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb35-183"><a href="#cb35-183" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>unique_ptr<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> pDiscountFactor <span class="op">{</span><span class="bu">std::</span>make_unique<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;(</span><span class="fl">0.95</span><span class="op">)};</span></span>
<span id="cb35-184"><a href="#cb35-184" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb35-185"><a href="#cb35-185" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"Discount Factor = "</span> <span class="op">&lt;&lt;</span> <span class="op">*</span>pDiscountFactor<span class="op">;</span></span>
<span id="cb35-186"><a href="#cb35-186" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb35-187"><a href="#cb35-187" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb35-188"><a href="#cb35-188" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb35-189"><a href="#cb35-189" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb35-190"><a href="#cb35-190" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-191"><a href="#cb35-191" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb35-192"><a href="#cb35-192" aria-hidden="true" tabindex="-1"></a><span class="in">Discount Factor = 0.95</span></span>
<span id="cb35-193"><a href="#cb35-193" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb35-194"><a href="#cb35-194" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-195"><a href="#cb35-195" aria-hidden="true" tabindex="-1"></a>The memory allocated on the free store holding <span class="in">`0.95`</span> is released once <span class="in">`pDiscountFactor`</span> goes out of scope and is destroyed after the <span class="in">`return`</span> statement.</span>
<span id="cb35-196"><a href="#cb35-196" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-197"><a href="#cb35-197" aria-hidden="true" tabindex="-1"></a>The below code snippet shows how smart pointers work.</span>
<span id="cb35-198"><a href="#cb35-198" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-199"><a href="#cb35-199" aria-hidden="true" tabindex="-1"></a><span class="in">```cpp</span></span>
<span id="cb35-200"><a href="#cb35-200" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb35-201"><a href="#cb35-201" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;memory&gt;</span></span>
<span id="cb35-202"><a href="#cb35-202" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-203"><a href="#cb35-203" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> X<span class="op">{</span></span>
<span id="cb35-204"><a href="#cb35-204" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb35-205"><a href="#cb35-205" aria-hidden="true" tabindex="-1"></a>        X<span class="op">()</span></span>
<span id="cb35-206"><a href="#cb35-206" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb35-207"><a href="#cb35-207" aria-hidden="true" tabindex="-1"></a>          <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">X created"</span><span class="op">;</span></span>
<span id="cb35-208"><a href="#cb35-208" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb35-209"><a href="#cb35-209" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb35-210"><a href="#cb35-210" aria-hidden="true" tabindex="-1"></a>        <span class="op">~</span>X<span class="op">()</span></span>
<span id="cb35-211"><a href="#cb35-211" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb35-212"><a href="#cb35-212" aria-hidden="true" tabindex="-1"></a>          <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">X destroyed"</span><span class="op">;</span></span>
<span id="cb35-213"><a href="#cb35-213" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb35-214"><a href="#cb35-214" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb35-215"><a href="#cb35-215" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-216"><a href="#cb35-216" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Y<span class="op">{</span></span>
<span id="cb35-217"><a href="#cb35-217" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb35-218"><a href="#cb35-218" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb35-219"><a href="#cb35-219" aria-hidden="true" tabindex="-1"></a>        Y<span class="op">()</span></span>
<span id="cb35-220"><a href="#cb35-220" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb35-221"><a href="#cb35-221" aria-hidden="true" tabindex="-1"></a>          <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">Y created"</span><span class="op">;</span></span>
<span id="cb35-222"><a href="#cb35-222" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb35-223"><a href="#cb35-223" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb35-224"><a href="#cb35-224" aria-hidden="true" tabindex="-1"></a>        <span class="op">~</span>Y<span class="op">()</span></span>
<span id="cb35-225"><a href="#cb35-225" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb35-226"><a href="#cb35-226" aria-hidden="true" tabindex="-1"></a>          <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">Y destroyed"</span><span class="op">;</span></span>
<span id="cb35-227"><a href="#cb35-227" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> </span>
<span id="cb35-228"><a href="#cb35-228" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb35-229"><a href="#cb35-229" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-230"><a href="#cb35-230" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb35-231"><a href="#cb35-231" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb35-232"><a href="#cb35-232" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">Inside main"</span><span class="op">;</span></span>
<span id="cb35-233"><a href="#cb35-233" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>shared_ptr<span class="op">&lt;</span>Y<span class="op">&gt;</span> sPtrY1 <span class="op">{</span><span class="bu">std::</span>make_shared<span class="op">&lt;</span>Y<span class="op">&gt;()};</span></span>
<span id="cb35-234"><a href="#cb35-234" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb35-235"><a href="#cb35-235" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb35-236"><a href="#cb35-236" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb35-237"><a href="#cb35-237" aria-hidden="true" tabindex="-1"></a>        <span class="co">//inner scope</span></span>
<span id="cb35-238"><a href="#cb35-238" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">Inside inner"</span><span class="op">;</span></span>
<span id="cb35-239"><a href="#cb35-239" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb35-240"><a href="#cb35-240" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>unique_ptr<span class="op">&lt;</span>X<span class="op">&gt;</span> uPtrX1 <span class="op">{</span><span class="bu">std::</span>make_unique<span class="op">&lt;</span>X<span class="op">&gt;()};</span></span>
<span id="cb35-241"><a href="#cb35-241" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>shared_ptr<span class="op">&lt;</span>Y<span class="op">&gt;</span> sPtrY2 <span class="op">{</span>sPtrY1<span class="op">};</span></span>
<span id="cb35-242"><a href="#cb35-242" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb35-243"><a href="#cb35-243" aria-hidden="true" tabindex="-1"></a>        <span class="co">// copy assignment and copy construction is not allowed on unique_ptr objects</span></span>
<span id="cb35-244"><a href="#cb35-244" aria-hidden="true" tabindex="-1"></a>        <span class="co">//std::unique_ptr&lt;X&gt; uPtrX2 = uPtrX1;</span></span>
<span id="cb35-245"><a href="#cb35-245" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb35-246"><a href="#cb35-246" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">Exiting inner"</span><span class="op">;</span></span>
<span id="cb35-247"><a href="#cb35-247" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb35-248"><a href="#cb35-248" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb35-249"><a href="#cb35-249" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">Exiting main"</span><span class="op">;</span></span>
<span id="cb35-250"><a href="#cb35-250" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb35-251"><a href="#cb35-251" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb35-252"><a href="#cb35-252" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb35-253"><a href="#cb35-253" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-254"><a href="#cb35-254" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb35-255"><a href="#cb35-255" aria-hidden="true" tabindex="-1"></a><span class="in">Inside main</span></span>
<span id="cb35-256"><a href="#cb35-256" aria-hidden="true" tabindex="-1"></a><span class="in">Y created</span></span>
<span id="cb35-257"><a href="#cb35-257" aria-hidden="true" tabindex="-1"></a><span class="in">Inside inner</span></span>
<span id="cb35-258"><a href="#cb35-258" aria-hidden="true" tabindex="-1"></a><span class="in">X created</span></span>
<span id="cb35-259"><a href="#cb35-259" aria-hidden="true" tabindex="-1"></a><span class="in">Exiting inner</span></span>
<span id="cb35-260"><a href="#cb35-260" aria-hidden="true" tabindex="-1"></a><span class="in">X destroyed</span></span>
<span id="cb35-261"><a href="#cb35-261" aria-hidden="true" tabindex="-1"></a><span class="in">Exiting main</span></span>
<span id="cb35-262"><a href="#cb35-262" aria-hidden="true" tabindex="-1"></a><span class="in">Y destroyed</span></span>
<span id="cb35-263"><a href="#cb35-263" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb35-264"><a href="#cb35-264" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-265"><a href="#cb35-265" aria-hidden="true" tabindex="-1"></a><span class="fu">## References.</span></span>
<span id="cb35-266"><a href="#cb35-266" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-267"><a href="#cb35-267" aria-hidden="true" tabindex="-1"></a>A reference is a name that you can use as an alias for another variable. Unlike a pointer, you cannot declare a reference and not initialize it. Because a reference is an alias, the variable which it is an alias must be provided when the reference is initialized. Also, a reference cannot be modified to be an alias for something else.</span>
<span id="cb35-268"><a href="#cb35-268" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-269"><a href="#cb35-269" aria-hidden="true" tabindex="-1"></a><span class="in">```cpp</span></span>
<span id="cb35-270"><a href="#cb35-270" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb35-271"><a href="#cb35-271" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;memory&gt;</span></span>
<span id="cb35-272"><a href="#cb35-272" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-273"><a href="#cb35-273" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-274"><a href="#cb35-274" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> swap<span class="op">(</span><span class="dt">int</span><span class="op">&amp;</span> a<span class="op">,</span> <span class="dt">int</span><span class="op">&amp;</span> b<span class="op">)</span></span>
<span id="cb35-275"><a href="#cb35-275" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb35-276"><a href="#cb35-276" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> temp <span class="op">{</span>a<span class="op">};</span></span>
<span id="cb35-277"><a href="#cb35-277" aria-hidden="true" tabindex="-1"></a>    a <span class="op">=</span> b<span class="op">;</span></span>
<span id="cb35-278"><a href="#cb35-278" aria-hidden="true" tabindex="-1"></a>    b <span class="op">=</span> temp<span class="op">;</span></span>
<span id="cb35-279"><a href="#cb35-279" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb35-280"><a href="#cb35-280" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-281"><a href="#cb35-281" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb35-282"><a href="#cb35-282" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb35-283"><a href="#cb35-283" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> x <span class="op">{</span><span class="dv">10</span><span class="op">};</span> </span>
<span id="cb35-284"><a href="#cb35-284" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> y <span class="op">{</span><span class="dv">15</span><span class="op">};</span></span>
<span id="cb35-285"><a href="#cb35-285" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb35-286"><a href="#cb35-286" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st"> Before swap:"</span><span class="op">;</span></span>
<span id="cb35-287"><a href="#cb35-287" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st"> x = "</span> <span class="op">&lt;&lt;</span> x <span class="op">;</span></span>
<span id="cb35-288"><a href="#cb35-288" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st"> y = "</span> <span class="op">&lt;&lt;</span> y<span class="op">;</span></span>
<span id="cb35-289"><a href="#cb35-289" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb35-290"><a href="#cb35-290" aria-hidden="true" tabindex="-1"></a>    swap<span class="op">(</span>x<span class="op">,</span>y<span class="op">);</span></span>
<span id="cb35-291"><a href="#cb35-291" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb35-292"><a href="#cb35-292" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st"> After swap:"</span><span class="op">;</span></span>
<span id="cb35-293"><a href="#cb35-293" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st"> x = "</span> <span class="op">&lt;&lt;</span> x <span class="op">;</span></span>
<span id="cb35-294"><a href="#cb35-294" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st"> y = "</span> <span class="op">&lt;&lt;</span> y<span class="op">;</span></span>
<span id="cb35-295"><a href="#cb35-295" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb35-296"><a href="#cb35-296" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb35-297"><a href="#cb35-297" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb35-298"><a href="#cb35-298" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-299"><a href="#cb35-299" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb35-300"><a href="#cb35-300" aria-hidden="true" tabindex="-1"></a><span class="in"> Before swap:</span></span>
<span id="cb35-301"><a href="#cb35-301" aria-hidden="true" tabindex="-1"></a><span class="in"> x = 10</span></span>
<span id="cb35-302"><a href="#cb35-302" aria-hidden="true" tabindex="-1"></a><span class="in"> y = 15</span></span>
<span id="cb35-303"><a href="#cb35-303" aria-hidden="true" tabindex="-1"></a><span class="in"> After swap:</span></span>
<span id="cb35-304"><a href="#cb35-304" aria-hidden="true" tabindex="-1"></a><span class="in"> x = 15</span></span>
<span id="cb35-305"><a href="#cb35-305" aria-hidden="true" tabindex="-1"></a><span class="in"> y = 10</span></span>
<span id="cb35-306"><a href="#cb35-306" aria-hidden="true" tabindex="-1"></a><span class="in"> ```</span></span>
<span id="cb35-307"><a href="#cb35-307" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb35-308"><a href="#cb35-308" aria-hidden="true" tabindex="-1"></a>Never return a pointer or reference to an automatic stack-allocated local variable from within a function. Automatic variables are destroyed and the stack is popped, once the control goes outside the scope in which they are declared.</span>
<span id="cb35-309"><a href="#cb35-309" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-310"><a href="#cb35-310" aria-hidden="true" tabindex="-1"></a><span class="fu">## Function Templates.</span></span>
<span id="cb35-311"><a href="#cb35-311" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-312"><a href="#cb35-312" aria-hidden="true" tabindex="-1"></a>A function template itself is not a definition of a function; it is a blueprint or a recipe for definining an entire family of functions. A function template is a parametric function definition, where a particular function instance is created by one or more parameter values. The compiler uses a function template to generate a function definition when necessary. If it is never necessary, no code results from the template. A function definition that is generated from a template is an *instance* or *instantiation* of the template. </span>
<span id="cb35-313"><a href="#cb35-313" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-314"><a href="#cb35-314" aria-hidden="true" tabindex="-1"></a>The parameters of a function template are usually data-types, where an instance can be generated for a parameter value of type <span class="in">`int`</span>, for example, and another with parameter valuer of type <span class="in">`string`</span>. But parameters are not necessarily types. They can be other things such as a dimension, for example. </span>
<span id="cb35-315"><a href="#cb35-315" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-316"><a href="#cb35-316" aria-hidden="true" tabindex="-1"></a><span class="in">```cpp</span></span>
<span id="cb35-317"><a href="#cb35-317" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">class</span> T<span class="op">&gt;</span></span>
<span id="cb35-318"><a href="#cb35-318" aria-hidden="true" tabindex="-1"></a>T larger<span class="op">(</span>T a<span class="op">,</span> T b<span class="op">)</span></span>
<span id="cb35-319"><a href="#cb35-319" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb35-320"><a href="#cb35-320" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> a <span class="op">&gt;</span> b <span class="op">?</span> a <span class="op">:</span> b<span class="op">;</span></span>
<span id="cb35-321"><a href="#cb35-321" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb35-322"><a href="#cb35-322" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb35-323"><a href="#cb35-323" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-324"><a href="#cb35-324" aria-hidden="true" tabindex="-1"></a>The compiler creates instances of the template from any statement that uses the <span class="in">`larger()`</span> function. Here's an example:</span>
<span id="cb35-325"><a href="#cb35-325" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-326"><a href="#cb35-326" aria-hidden="true" tabindex="-1"></a><span class="in">```cpp</span></span>
<span id="cb35-327"><a href="#cb35-327" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb35-328"><a href="#cb35-328" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb35-329"><a href="#cb35-329" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">Larger of 1.50 and 2.50 is : "</span>  <span class="op">&lt;&lt;</span> larger<span class="op">(</span><span class="fl">1.5</span><span class="op">,</span><span class="fl">2.5</span><span class="op">);</span></span>
<span id="cb35-330"><a href="#cb35-330" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb35-331"><a href="#cb35-331" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb35-332"><a href="#cb35-332" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb35-333"><a href="#cb35-333" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-334"><a href="#cb35-334" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb35-335"><a href="#cb35-335" aria-hidden="true" tabindex="-1"></a><span class="in">Larger of 1.50 and 2.50 is : 2.5</span></span>
<span id="cb35-336"><a href="#cb35-336" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb35-337"><a href="#cb35-337" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-338"><a href="#cb35-338" aria-hidden="true" tabindex="-1"></a>You just use the function in the normal way. You don't need to specify a value for the template parameter <span class="in">`T`</span>. The compiler deduces the type that is to replace <span class="in">`T`</span> from the arguments in the <span class="in">`larger`</span> function call. This mechanism is referred to as *template argument deduction*. The arguments to <span class="in">`larger()`</span> are literals of type <span class="in">`double`</span>, so this call causes the compiler to search for an existing definition of <span class="in">`larger()`</span> with <span class="in">`double`</span> parameters. If it doesn't find one, the compiler creates this version of <span class="in">`larger()`</span> from the template by susbstituting <span class="in">`double`</span> for <span class="in">`T`</span> in the template definition. </span>
<span id="cb35-339"><a href="#cb35-339" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-340"><a href="#cb35-340" aria-hidden="true" tabindex="-1"></a>The resulting function accepts arguments of type <span class="in">`double`</span> and returs a <span class="in">`double`</span> value.</span>
<span id="cb35-341"><a href="#cb35-341" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-342"><a href="#cb35-342" aria-hidden="true" tabindex="-1"></a>The compiler makes sure to generate each template instance only once. If a subsequent function call requires the same instance, then it calls the instance that exists.</span>
<span id="cb35-343"><a href="#cb35-343" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-344"><a href="#cb35-344" aria-hidden="true" tabindex="-1"></a><span class="fu">### Template type parameters.</span></span>
<span id="cb35-345"><a href="#cb35-345" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-346"><a href="#cb35-346" aria-hidden="true" tabindex="-1"></a>The name of the template type parameter can be used anywhere in the template's function signature, return type and body. It is a placeholder for a type and can thus be put in any context you would normally put a concrete type.</span>
<span id="cb35-347"><a href="#cb35-347" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-348"><a href="#cb35-348" aria-hidden="true" tabindex="-1"></a><span class="in">```cpp</span></span>
<span id="cb35-349"><a href="#cb35-349" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">class</span> T<span class="op">&gt;</span></span>
<span id="cb35-350"><a href="#cb35-350" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> T<span class="op">&amp;</span> larger<span class="op">(</span><span class="at">const</span> T<span class="op">&amp;</span> a<span class="op">,</span><span class="at">const</span> T<span class="op">&amp;</span> b<span class="op">)</span></span>
<span id="cb35-351"><a href="#cb35-351" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb35-352"><a href="#cb35-352" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> a <span class="op">&gt;</span> b <span class="op">?</span> a <span class="op">:</span> b<span class="op">;</span></span>
<span id="cb35-353"><a href="#cb35-353" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb35-354"><a href="#cb35-354" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb35-355"><a href="#cb35-355" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-356"><a href="#cb35-356" aria-hidden="true" tabindex="-1"></a><span class="fu">### Function Template overloading.</span></span>
<span id="cb35-357"><a href="#cb35-357" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-358"><a href="#cb35-358" aria-hidden="true" tabindex="-1"></a>Templated functions can be overloaded.</span>
<span id="cb35-359"><a href="#cb35-359" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-360"><a href="#cb35-360" aria-hidden="true" tabindex="-1"></a><span class="in">```cpp</span></span>
<span id="cb35-361"><a href="#cb35-361" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb35-362"><a href="#cb35-362" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb35-363"><a href="#cb35-363" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-364"><a href="#cb35-364" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb35-365"><a href="#cb35-365" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> T<span class="op">&amp;</span> largest<span class="op">(</span><span class="at">const</span> T<span class="op">&amp;</span> a<span class="op">,</span><span class="at">const</span> T<span class="op">&amp;</span> b<span class="op">)</span></span>
<span id="cb35-366"><a href="#cb35-366" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb35-367"><a href="#cb35-367" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> a <span class="op">&gt;</span> b <span class="op">?</span> a <span class="op">:</span> b<span class="op">;</span></span>
<span id="cb35-368"><a href="#cb35-368" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb35-369"><a href="#cb35-369" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-370"><a href="#cb35-370" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb35-371"><a href="#cb35-371" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> T largest<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span>T<span class="op">&gt;&amp;</span> data<span class="op">)</span></span>
<span id="cb35-372"><a href="#cb35-372" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb35-373"><a href="#cb35-373" aria-hidden="true" tabindex="-1"></a>    T max <span class="op">{};</span></span>
<span id="cb35-374"><a href="#cb35-374" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="kw">auto</span> v<span class="op">:</span>data<span class="op">)</span></span>
<span id="cb35-375"><a href="#cb35-375" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb35-376"><a href="#cb35-376" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>v <span class="op">&gt;=</span> max<span class="op">)</span></span>
<span id="cb35-377"><a href="#cb35-377" aria-hidden="true" tabindex="-1"></a>            max <span class="op">=</span> v<span class="op">;</span></span>
<span id="cb35-378"><a href="#cb35-378" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb35-379"><a href="#cb35-379" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> max<span class="op">;</span></span>
<span id="cb35-380"><a href="#cb35-380" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb35-381"><a href="#cb35-381" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-382"><a href="#cb35-382" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb35-383"><a href="#cb35-383" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb35-384"><a href="#cb35-384" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">Larger of 1.50 and 2.50 is : "</span>  <span class="op">&lt;&lt;</span> largest<span class="op">(</span><span class="fl">1.5</span><span class="op">,</span><span class="fl">2.5</span><span class="op">);</span></span>
<span id="cb35-385"><a href="#cb35-385" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> data <span class="op">{</span></span>
<span id="cb35-386"><a href="#cb35-386" aria-hidden="true" tabindex="-1"></a>        <span class="dv">2</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">8</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">7</span><span class="op">,</span> <span class="dv">3</span></span>
<span id="cb35-387"><a href="#cb35-387" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb35-388"><a href="#cb35-388" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">Largest of [2,5,8,4,7,3] is : "</span> <span class="op">&lt;&lt;</span> largest<span class="op">(</span>data<span class="op">);</span></span>
<span id="cb35-389"><a href="#cb35-389" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb35-390"><a href="#cb35-390" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb35-391"><a href="#cb35-391" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb35-392"><a href="#cb35-392" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-393"><a href="#cb35-393" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb35-394"><a href="#cb35-394" aria-hidden="true" tabindex="-1"></a><span class="in">Larger of 1.50 and 2.50 is : 2.5</span></span>
<span id="cb35-395"><a href="#cb35-395" aria-hidden="true" tabindex="-1"></a><span class="in">Largest of [2,5,8,4,7,3] is : 8</span></span>
<span id="cb35-396"><a href="#cb35-396" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb35-397"><a href="#cb35-397" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-398"><a href="#cb35-398" aria-hidden="true" tabindex="-1"></a><span class="fu">## Classes and Object Oriented Programming.</span></span>
<span id="cb35-399"><a href="#cb35-399" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-400"><a href="#cb35-400" aria-hidden="true" tabindex="-1"></a>An interesting exercise to write a <span class="in">`Matrix&lt;T&gt;`</span> class.</span>
<span id="cb35-401"><a href="#cb35-401" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-402"><a href="#cb35-402" aria-hidden="true" tabindex="-1"></a><span class="in">```cpp</span></span>
<span id="cb35-403"><a href="#cb35-403" aria-hidden="true" tabindex="-1"></a><span class="co">// Matrix.h</span></span>
<span id="cb35-404"><a href="#cb35-404" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb35-405"><a href="#cb35-405" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb35-406"><a href="#cb35-406" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;initializer_list&gt;</span></span>
<span id="cb35-407"><a href="#cb35-407" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdexcept&gt;</span></span>
<span id="cb35-408"><a href="#cb35-408" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-409"><a href="#cb35-409" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T <span class="op">=</span> <span class="dt">double</span><span class="op">&gt;</span></span>
<span id="cb35-410"><a href="#cb35-410" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Matrix <span class="op">{</span></span>
<span id="cb35-411"><a href="#cb35-411" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb35-412"><a href="#cb35-412" aria-hidden="true" tabindex="-1"></a>    <span class="co">//Default constructor</span></span>
<span id="cb35-413"><a href="#cb35-413" aria-hidden="true" tabindex="-1"></a>    Matrix<span class="op">()</span> <span class="op">:</span> Matrix<span class="op">(</span><span class="dv">3</span><span class="op">,</span> <span class="dv">3</span><span class="op">)</span> <span class="op">{}</span></span>
<span id="cb35-414"><a href="#cb35-414" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-415"><a href="#cb35-415" aria-hidden="true" tabindex="-1"></a>    <span class="co">//Parameterized constructor with number of rows, cols as </span></span>
<span id="cb35-416"><a href="#cb35-416" aria-hidden="true" tabindex="-1"></a>    <span class="co">// as arguments.</span></span>
<span id="cb35-417"><a href="#cb35-417" aria-hidden="true" tabindex="-1"></a>    Matrix<span class="op">(</span><span class="bu">std::</span>size_t m<span class="op">,</span> <span class="bu">std::</span>size_t n<span class="op">)</span> <span class="op">:</span> <span class="va">m_rows</span><span class="op">(</span>m<span class="op">),</span> <span class="va">m_cols</span><span class="op">(</span>n<span class="op">)</span></span>
<span id="cb35-418"><a href="#cb35-418" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb35-419"><a href="#cb35-419" aria-hidden="true" tabindex="-1"></a>        <span class="va">m_data</span><span class="op">.</span>resize<span class="op">(</span><span class="va">m_rows</span> <span class="op">*</span> <span class="va">m_cols</span><span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb35-420"><a href="#cb35-420" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb35-421"><a href="#cb35-421" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-422"><a href="#cb35-422" aria-hidden="true" tabindex="-1"></a>    <span class="co">//Parameterized constructor with matrix elements provided </span></span>
<span id="cb35-423"><a href="#cb35-423" aria-hidden="true" tabindex="-1"></a>    <span class="co">// in brace initializer lists.</span></span>
<span id="cb35-424"><a href="#cb35-424" aria-hidden="true" tabindex="-1"></a>    Matrix<span class="op">(</span><span class="bu">std::</span>initializer_list<span class="op">&lt;</span><span class="bu">std::</span>initializer_list<span class="op">&lt;</span>T<span class="op">&gt;&gt;</span> m<span class="op">)</span> <span class="op">{</span></span>
<span id="cb35-425"><a href="#cb35-425" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> i<span class="op">{},</span> j<span class="op">{};</span></span>
<span id="cb35-426"><a href="#cb35-426" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> row <span class="op">:</span> m<span class="op">)</span></span>
<span id="cb35-427"><a href="#cb35-427" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb35-428"><a href="#cb35-428" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> el <span class="op">:</span> row<span class="op">)</span></span>
<span id="cb35-429"><a href="#cb35-429" aria-hidden="true" tabindex="-1"></a>            <span class="op">{</span></span>
<span id="cb35-430"><a href="#cb35-430" aria-hidden="true" tabindex="-1"></a>                <span class="va">m_data</span><span class="op">.</span>push_back<span class="op">(</span>el<span class="op">);</span></span>
<span id="cb35-431"><a href="#cb35-431" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>i <span class="op">==</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb35-432"><a href="#cb35-432" aria-hidden="true" tabindex="-1"></a>                    <span class="op">++</span>j<span class="op">;</span></span>
<span id="cb35-433"><a href="#cb35-433" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb35-434"><a href="#cb35-434" aria-hidden="true" tabindex="-1"></a>            <span class="op">++</span>i<span class="op">;</span></span>
<span id="cb35-435"><a href="#cb35-435" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb35-436"><a href="#cb35-436" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-437"><a href="#cb35-437" aria-hidden="true" tabindex="-1"></a>        <span class="va">m_rows</span> <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb35-438"><a href="#cb35-438" aria-hidden="true" tabindex="-1"></a>        <span class="va">m_cols</span> <span class="op">=</span> j<span class="op">;</span></span>
<span id="cb35-439"><a href="#cb35-439" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb35-440"><a href="#cb35-440" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-441"><a href="#cb35-441" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-442"><a href="#cb35-442" aria-hidden="true" tabindex="-1"></a>    <span class="co">//Copy constructor</span></span>
<span id="cb35-443"><a href="#cb35-443" aria-hidden="true" tabindex="-1"></a>    Matrix<span class="op">(</span><span class="at">const</span> Matrix<span class="op">&amp;</span> A<span class="op">)</span> <span class="op">:</span> <span class="va">m_rows</span><span class="op">{</span> A<span class="op">.</span><span class="va">m_rows</span> <span class="op">},</span> <span class="va">m_cols</span><span class="op">{</span> A<span class="op">.</span><span class="va">m_cols</span> <span class="op">},</span> <span class="va">m_data</span><span class="op">{</span> A<span class="op">.</span><span class="va">m_data</span> <span class="op">}</span> <span class="op">{}</span></span>
<span id="cb35-444"><a href="#cb35-444" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-445"><a href="#cb35-445" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>size_t rows<span class="op">()</span> <span class="at">const</span></span>
<span id="cb35-446"><a href="#cb35-446" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb35-447"><a href="#cb35-447" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">m_rows</span><span class="op">;</span></span>
<span id="cb35-448"><a href="#cb35-448" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb35-449"><a href="#cb35-449" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-450"><a href="#cb35-450" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>size_t cols<span class="op">()</span> <span class="at">const</span></span>
<span id="cb35-451"><a href="#cb35-451" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb35-452"><a href="#cb35-452" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">m_cols</span><span class="op">;</span></span>
<span id="cb35-453"><a href="#cb35-453" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb35-454"><a href="#cb35-454" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-455"><a href="#cb35-455" aria-hidden="true" tabindex="-1"></a>    T<span class="op">&amp;</span> at<span class="op">(</span><span class="dt">int</span> i<span class="op">,</span> <span class="dt">int</span> j<span class="op">)</span></span>
<span id="cb35-456"><a href="#cb35-456" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb35-457"><a href="#cb35-457" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">m_data</span><span class="op">[</span>i <span class="op">*</span> <span class="va">m_cols</span> <span class="op">+</span> j<span class="op">];</span></span>
<span id="cb35-458"><a href="#cb35-458" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb35-459"><a href="#cb35-459" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-460"><a href="#cb35-460" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> T<span class="op">&amp;</span> at<span class="op">(</span><span class="dt">int</span> i<span class="op">,</span> <span class="dt">int</span> j<span class="op">)</span> <span class="at">const</span></span>
<span id="cb35-461"><a href="#cb35-461" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb35-462"><a href="#cb35-462" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">m_data</span><span class="op">[</span>i <span class="op">*</span> <span class="va">m_cols</span> <span class="op">+</span> j<span class="op">];</span></span>
<span id="cb35-463"><a href="#cb35-463" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb35-464"><a href="#cb35-464" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-465"><a href="#cb35-465" aria-hidden="true" tabindex="-1"></a>    T<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">()(</span><span class="dt">int</span> i<span class="op">,</span> <span class="dt">int</span> j<span class="op">)</span></span>
<span id="cb35-466"><a href="#cb35-466" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb35-467"><a href="#cb35-467" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>i <span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb35-468"><a href="#cb35-468" aria-hidden="true" tabindex="-1"></a>            <span class="cf">throw</span> <span class="bu">std::</span>invalid_argument<span class="op">(</span><span class="st">"The row index must be non-negative!"</span><span class="op">);</span></span>
<span id="cb35-469"><a href="#cb35-469" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-470"><a href="#cb35-470" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>j <span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb35-471"><a href="#cb35-471" aria-hidden="true" tabindex="-1"></a>            <span class="cf">throw</span> <span class="bu">std::</span>invalid_argument<span class="op">(</span><span class="st">"The column index must be non-negative!"</span><span class="op">);</span></span>
<span id="cb35-472"><a href="#cb35-472" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-473"><a href="#cb35-473" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>i <span class="op">&gt;=</span> <span class="va">m_rows</span><span class="op">)</span></span>
<span id="cb35-474"><a href="#cb35-474" aria-hidden="true" tabindex="-1"></a>            <span class="cf">throw</span> <span class="bu">std::</span>invalid_argument<span class="op">(</span><span class="st">"The row index must be less than "</span> <span class="op">+</span> <span class="va">m_rows</span><span class="op">);</span></span>
<span id="cb35-475"><a href="#cb35-475" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-476"><a href="#cb35-476" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>j <span class="op">&gt;=</span> <span class="va">m_cols</span><span class="op">)</span></span>
<span id="cb35-477"><a href="#cb35-477" aria-hidden="true" tabindex="-1"></a>            <span class="cf">throw</span> <span class="bu">std::</span>invalid_argument<span class="op">(</span><span class="st">"The col index must be less than "</span> <span class="op">+</span> <span class="va">m_cols</span><span class="op">);</span></span>
<span id="cb35-478"><a href="#cb35-478" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-479"><a href="#cb35-479" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> at<span class="op">(</span>i<span class="op">,</span> j<span class="op">);</span></span>
<span id="cb35-480"><a href="#cb35-480" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb35-481"><a href="#cb35-481" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-482"><a href="#cb35-482" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> T <span class="kw">operator</span><span class="op">()(</span><span class="dt">int</span> i<span class="op">,</span> <span class="dt">int</span> j<span class="op">)</span> <span class="at">const</span></span>
<span id="cb35-483"><a href="#cb35-483" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb35-484"><a href="#cb35-484" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>i <span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb35-485"><a href="#cb35-485" aria-hidden="true" tabindex="-1"></a>            <span class="cf">throw</span> <span class="bu">std::</span>invalid_argument<span class="op">(</span><span class="st">"The row index must be non-negative!"</span><span class="op">);</span></span>
<span id="cb35-486"><a href="#cb35-486" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-487"><a href="#cb35-487" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>j <span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb35-488"><a href="#cb35-488" aria-hidden="true" tabindex="-1"></a>            <span class="cf">throw</span> <span class="bu">std::</span>invalid_argument<span class="op">(</span><span class="st">"The column index must be non-negative!"</span><span class="op">);</span></span>
<span id="cb35-489"><a href="#cb35-489" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-490"><a href="#cb35-490" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>i <span class="op">&gt;=</span> <span class="va">m_rows</span><span class="op">)</span></span>
<span id="cb35-491"><a href="#cb35-491" aria-hidden="true" tabindex="-1"></a>            <span class="cf">throw</span> <span class="bu">std::</span>invalid_argument<span class="op">(</span><span class="st">"The row index must be less than "</span> <span class="op">+</span> <span class="va">m_rows</span><span class="op">);</span></span>
<span id="cb35-492"><a href="#cb35-492" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-493"><a href="#cb35-493" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>j <span class="op">&gt;=</span> <span class="va">m_cols</span><span class="op">)</span></span>
<span id="cb35-494"><a href="#cb35-494" aria-hidden="true" tabindex="-1"></a>            <span class="cf">throw</span> <span class="bu">std::</span>invalid_argument<span class="op">(</span><span class="st">"The col index must be less than "</span> <span class="op">+</span> <span class="va">m_cols</span><span class="op">);</span></span>
<span id="cb35-495"><a href="#cb35-495" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-496"><a href="#cb35-496" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> at<span class="op">(</span>i<span class="op">,</span> j<span class="op">);</span></span>
<span id="cb35-497"><a href="#cb35-497" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb35-498"><a href="#cb35-498" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-499"><a href="#cb35-499" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> Matrix <span class="kw">operator</span><span class="op">+(</span><span class="at">const</span> Matrix<span class="op">&amp;</span> mat<span class="op">)</span></span>
<span id="cb35-500"><a href="#cb35-500" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb35-501"><a href="#cb35-501" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>mat<span class="op">.</span>rows<span class="op">()</span> <span class="op">!=</span> rows<span class="op">())</span></span>
<span id="cb35-502"><a href="#cb35-502" aria-hidden="true" tabindex="-1"></a>            <span class="cf">throw</span> <span class="bu">std::</span>runtime_error<span class="op">(</span><span class="st">"In A + B, matrices A, B should have the same number of rows!"</span><span class="op">);</span></span>
<span id="cb35-503"><a href="#cb35-503" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-504"><a href="#cb35-504" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>mat<span class="op">.</span>cols<span class="op">()</span> <span class="op">!=</span> cols<span class="op">())</span></span>
<span id="cb35-505"><a href="#cb35-505" aria-hidden="true" tabindex="-1"></a>            <span class="cf">throw</span> <span class="bu">std::</span>runtime_error<span class="op">(</span><span class="st">"In A + B, matrices A, B should have the same number of cols!"</span><span class="op">);</span></span>
<span id="cb35-506"><a href="#cb35-506" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-507"><a href="#cb35-507" aria-hidden="true" tabindex="-1"></a>        Matrix result<span class="op">(</span>rows<span class="op">(),</span> cols<span class="op">());</span></span>
<span id="cb35-508"><a href="#cb35-508" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-509"><a href="#cb35-509" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i<span class="op">{};</span> i <span class="op">&lt;</span> rows<span class="op">();</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb35-510"><a href="#cb35-510" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb35-511"><a href="#cb35-511" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j<span class="op">{};</span> j <span class="op">&lt;</span> cols<span class="op">();</span> <span class="op">++</span>j<span class="op">)</span></span>
<span id="cb35-512"><a href="#cb35-512" aria-hidden="true" tabindex="-1"></a>            <span class="op">{</span></span>
<span id="cb35-513"><a href="#cb35-513" aria-hidden="true" tabindex="-1"></a>                result<span class="op">(</span>i<span class="op">,</span> j<span class="op">)</span> <span class="op">=</span> at<span class="op">(</span>i<span class="op">,</span> j<span class="op">)</span> <span class="op">+</span> mat<span class="op">(</span>i<span class="op">,</span> j<span class="op">);</span></span>
<span id="cb35-514"><a href="#cb35-514" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb35-515"><a href="#cb35-515" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb35-516"><a href="#cb35-516" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> result<span class="op">;</span></span>
<span id="cb35-517"><a href="#cb35-517" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb35-518"><a href="#cb35-518" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-519"><a href="#cb35-519" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> Matrix <span class="kw">operator</span><span class="op">-(</span><span class="at">const</span> Matrix<span class="op">&amp;</span> mat<span class="op">)</span></span>
<span id="cb35-520"><a href="#cb35-520" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb35-521"><a href="#cb35-521" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>mat<span class="op">.</span>rows<span class="op">()</span> <span class="op">!=</span> rows<span class="op">())</span></span>
<span id="cb35-522"><a href="#cb35-522" aria-hidden="true" tabindex="-1"></a>            <span class="cf">throw</span> <span class="bu">std::</span>runtime_error<span class="op">(</span><span class="st">"In A - B, matrices A, B should have the same number of rows!"</span><span class="op">);</span></span>
<span id="cb35-523"><a href="#cb35-523" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-524"><a href="#cb35-524" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>mat<span class="op">.</span>cols<span class="op">()</span> <span class="op">!=</span> cols<span class="op">())</span></span>
<span id="cb35-525"><a href="#cb35-525" aria-hidden="true" tabindex="-1"></a>            <span class="cf">throw</span> <span class="bu">std::</span>runtime_error<span class="op">(</span><span class="st">"In A - B, matrices A, B should have the same number of cols!"</span><span class="op">);</span></span>
<span id="cb35-526"><a href="#cb35-526" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-527"><a href="#cb35-527" aria-hidden="true" tabindex="-1"></a>        Matrix result<span class="op">(</span>rows<span class="op">(),</span> cols<span class="op">());</span></span>
<span id="cb35-528"><a href="#cb35-528" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-529"><a href="#cb35-529" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i<span class="op">{};</span> i <span class="op">&lt;</span> rows<span class="op">();</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb35-530"><a href="#cb35-530" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb35-531"><a href="#cb35-531" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j<span class="op">{};</span> j <span class="op">&lt;</span> cols<span class="op">();</span> <span class="op">++</span>j<span class="op">)</span></span>
<span id="cb35-532"><a href="#cb35-532" aria-hidden="true" tabindex="-1"></a>            <span class="op">{</span></span>
<span id="cb35-533"><a href="#cb35-533" aria-hidden="true" tabindex="-1"></a>                result<span class="op">(</span>i<span class="op">,</span> j<span class="op">)</span> <span class="op">=</span> at<span class="op">(</span>i<span class="op">,</span> j<span class="op">)</span> <span class="op">-</span> mat<span class="op">(</span>i<span class="op">,</span> j<span class="op">);</span></span>
<span id="cb35-534"><a href="#cb35-534" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb35-535"><a href="#cb35-535" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb35-536"><a href="#cb35-536" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> result<span class="op">;</span></span>
<span id="cb35-537"><a href="#cb35-537" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb35-538"><a href="#cb35-538" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-539"><a href="#cb35-539" aria-hidden="true" tabindex="-1"></a>    Matrix<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">=(</span><span class="at">const</span> Matrix<span class="op">&amp;</span> mat<span class="op">)</span></span>
<span id="cb35-540"><a href="#cb35-540" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb35-541"><a href="#cb35-541" aria-hidden="true" tabindex="-1"></a>        <span class="va">m_data</span> <span class="op">=</span> mat<span class="op">.</span><span class="va">m_data</span><span class="op">;</span></span>
<span id="cb35-542"><a href="#cb35-542" aria-hidden="true" tabindex="-1"></a>        <span class="va">m_rows</span> <span class="op">=</span> mat<span class="op">.</span>rows<span class="op">();</span></span>
<span id="cb35-543"><a href="#cb35-543" aria-hidden="true" tabindex="-1"></a>        <span class="va">m_cols</span> <span class="op">=</span> mat<span class="op">.</span>cols<span class="op">();</span></span>
<span id="cb35-544"><a href="#cb35-544" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-545"><a href="#cb35-545" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">*</span><span class="kw">this</span><span class="op">;</span></span>
<span id="cb35-546"><a href="#cb35-546" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb35-547"><a href="#cb35-547" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-548"><a href="#cb35-548" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> Matrix <span class="kw">operator</span><span class="op">*(</span><span class="at">const</span> Matrix<span class="op">&amp;</span> mat<span class="op">)</span></span>
<span id="cb35-549"><a href="#cb35-549" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb35-550"><a href="#cb35-550" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>cols<span class="op">()</span> <span class="op">!=</span> mat<span class="op">.</span>rows<span class="op">())</span></span>
<span id="cb35-551"><a href="#cb35-551" aria-hidden="true" tabindex="-1"></a>            <span class="cf">throw</span> <span class="bu">std::</span>runtime_error<span class="op">(</span><span class="st">"In A * B, cols of A must equal rows of B!"</span><span class="op">);</span></span>
<span id="cb35-552"><a href="#cb35-552" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-553"><a href="#cb35-553" aria-hidden="true" tabindex="-1"></a>        Matrix result<span class="op">{</span> rows<span class="op">(),</span> mat<span class="op">.</span>cols<span class="op">()</span> <span class="op">};</span></span>
<span id="cb35-554"><a href="#cb35-554" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-555"><a href="#cb35-555" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i<span class="op">{};</span> i <span class="op">&lt;</span> rows<span class="op">();</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb35-556"><a href="#cb35-556" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb35-557"><a href="#cb35-557" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> k<span class="op">{};</span> k <span class="op">&lt;</span> cols<span class="op">();</span> <span class="op">++</span>k<span class="op">)</span></span>
<span id="cb35-558"><a href="#cb35-558" aria-hidden="true" tabindex="-1"></a>            <span class="op">{</span></span>
<span id="cb35-559"><a href="#cb35-559" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j<span class="op">{};</span> j <span class="op">&lt;</span> mat<span class="op">.</span>cols<span class="op">();</span> <span class="op">++</span>j<span class="op">)</span></span>
<span id="cb35-560"><a href="#cb35-560" aria-hidden="true" tabindex="-1"></a>                <span class="op">{</span></span>
<span id="cb35-561"><a href="#cb35-561" aria-hidden="true" tabindex="-1"></a>                    result<span class="op">(</span>i<span class="op">,</span> j<span class="op">)</span> <span class="op">+=</span> at<span class="op">(</span>i<span class="op">,</span> k<span class="op">)</span> <span class="op">*</span> mat<span class="op">(</span>k<span class="op">,</span> j<span class="op">);</span></span>
<span id="cb35-562"><a href="#cb35-562" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb35-563"><a href="#cb35-563" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb35-564"><a href="#cb35-564" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb35-565"><a href="#cb35-565" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-566"><a href="#cb35-566" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> result<span class="op">;</span></span>
<span id="cb35-567"><a href="#cb35-567" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb35-568"><a href="#cb35-568" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-569"><a href="#cb35-569" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-570"><a href="#cb35-570" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="cb35-571"><a href="#cb35-571" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="va">m_data</span><span class="op">{};</span></span>
<span id="cb35-572"><a href="#cb35-572" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="va">m_rows</span><span class="op">;</span></span>
<span id="cb35-573"><a href="#cb35-573" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="va">m_cols</span><span class="op">;</span></span>
<span id="cb35-574"><a href="#cb35-574" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb35-575"><a href="#cb35-575" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb35-576"><a href="#cb35-576" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-577"><a href="#cb35-577" aria-hidden="true" tabindex="-1"></a><span class="in">```cpp</span></span>
<span id="cb35-578"><a href="#cb35-578" aria-hidden="true" tabindex="-1"></a><span class="co">//Matrix.cpp</span></span>
<span id="cb35-579"><a href="#cb35-579" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-580"><a href="#cb35-580" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb35-581"><a href="#cb35-581" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">"Matrix.h"</span></span>
<span id="cb35-582"><a href="#cb35-582" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-583"><a href="#cb35-583" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb35-584"><a href="#cb35-584" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb35-585"><a href="#cb35-585" aria-hidden="true" tabindex="-1"></a>    Matrix<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> A<span class="op">{</span></span>
<span id="cb35-586"><a href="#cb35-586" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">},</span></span>
<span id="cb35-587"><a href="#cb35-587" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span><span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">}</span></span>
<span id="cb35-588"><a href="#cb35-588" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb35-589"><a href="#cb35-589" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-590"><a href="#cb35-590" aria-hidden="true" tabindex="-1"></a>    Matrix<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> B<span class="op">{</span></span>
<span id="cb35-591"><a href="#cb35-591" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">},</span></span>
<span id="cb35-592"><a href="#cb35-592" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span><span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">}</span></span>
<span id="cb35-593"><a href="#cb35-593" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb35-594"><a href="#cb35-594" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-595"><a href="#cb35-595" aria-hidden="true" tabindex="-1"></a>    Matrix<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> result <span class="op">=</span> A <span class="op">+</span> B<span class="op">;</span></span>
<span id="cb35-596"><a href="#cb35-596" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-597"><a href="#cb35-597" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> result<span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">)</span> <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\t</span><span class="st">"</span> <span class="op">&lt;&lt;</span> result<span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">)</span> <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span></span>
<span id="cb35-598"><a href="#cb35-598" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> result<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">)</span> <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\t</span><span class="st">"</span> <span class="op">&lt;&lt;</span> result<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb35-599"><a href="#cb35-599" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-600"><a href="#cb35-600" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb35-601"><a href="#cb35-601" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb35-602"><a href="#cb35-602" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb35-603"><a href="#cb35-603" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-604"><a href="#cb35-604" aria-hidden="true" tabindex="-1"></a><span class="fu">### Access specifiers and class hierarchies.</span></span>
<span id="cb35-605"><a href="#cb35-605" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-606"><a href="#cb35-606" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>The private members of the base class are inaccessible to the derived class.</span>
<span id="cb35-607"><a href="#cb35-607" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-608"><a href="#cb35-608" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>When the base class specifier is <span class="in">`public`</span>, the access status of the inherited members remains unchanged. Thus, inherited <span class="in">`public`</span> members are <span class="in">`public`</span>, and inherited <span class="in">`protected`</span> members are <span class="in">`protected`</span> in a derived class.</span>
<span id="cb35-609"><a href="#cb35-609" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-610"><a href="#cb35-610" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>When the base class specifier is <span class="in">`protected`</span>, both public and protected members of the base class are inherited as <span class="in">`protected`</span> members in the child class.</span>
<span id="cb35-611"><a href="#cb35-611" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-612"><a href="#cb35-612" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>When the base class specifier is <span class="in">`private`</span>, inherited <span class="in">`public`</span> and <span class="in">`protected`</span> members become <span class="in">`private`</span> to the derived class, so that they're accessible by member functions of the the derived class, but they cannot be accessed if they're inherited in another derived class.</span>
<span id="cb35-613"><a href="#cb35-613" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-614"><a href="#cb35-614" aria-hidden="true" tabindex="-1"></a><span class="fu">### Constructors and Destructors in derived classes.</span></span>
<span id="cb35-615"><a href="#cb35-615" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-616"><a href="#cb35-616" aria-hidden="true" tabindex="-1"></a>Every constructor of the derived class always starts by invoking a constructor of the base class. And that base class constructor then invokes the constructor of its base class, and so on.</span>
<span id="cb35-617"><a href="#cb35-617" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-618"><a href="#cb35-618" aria-hidden="true" tabindex="-1"></a>*Remark.* You cannot initialize the member variables of a base class in the initialization list for the derived class constructor. Not even if those members are public or protected. </span>
<span id="cb35-619"><a href="#cb35-619" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-620"><a href="#cb35-620" aria-hidden="true" tabindex="-1"></a><span class="in">```cpp</span></span>
<span id="cb35-621"><a href="#cb35-621" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb35-622"><a href="#cb35-622" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb35-623"><a href="#cb35-623" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb35-624"><a href="#cb35-624" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-625"><a href="#cb35-625" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A<span class="op">{</span></span>
<span id="cb35-626"><a href="#cb35-626" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb35-627"><a href="#cb35-627" aria-hidden="true" tabindex="-1"></a>    A<span class="op">(){</span></span>
<span id="cb35-628"><a href="#cb35-628" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">Inside A's constructor"</span><span class="op">;</span></span>
<span id="cb35-629"><a href="#cb35-629" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb35-630"><a href="#cb35-630" aria-hidden="true" tabindex="-1"></a>    <span class="op">~</span>A<span class="op">()</span></span>
<span id="cb35-631"><a href="#cb35-631" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb35-632"><a href="#cb35-632" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">Inside A's destructor"</span><span class="op">;</span></span>
<span id="cb35-633"><a href="#cb35-633" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb35-634"><a href="#cb35-634" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb35-635"><a href="#cb35-635" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-636"><a href="#cb35-636" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> B <span class="op">:</span> <span class="kw">public</span> A</span>
<span id="cb35-637"><a href="#cb35-637" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb35-638"><a href="#cb35-638" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb35-639"><a href="#cb35-639" aria-hidden="true" tabindex="-1"></a>    B<span class="op">()</span></span>
<span id="cb35-640"><a href="#cb35-640" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb35-641"><a href="#cb35-641" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">Inside B's constructor"</span><span class="op">;</span></span>
<span id="cb35-642"><a href="#cb35-642" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb35-643"><a href="#cb35-643" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb35-644"><a href="#cb35-644" aria-hidden="true" tabindex="-1"></a>    <span class="op">~</span>B<span class="op">()</span></span>
<span id="cb35-645"><a href="#cb35-645" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb35-646"><a href="#cb35-646" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">Inside B's destructor"</span><span class="op">;</span></span>
<span id="cb35-647"><a href="#cb35-647" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb35-648"><a href="#cb35-648" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb35-649"><a href="#cb35-649" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-650"><a href="#cb35-650" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb35-651"><a href="#cb35-651" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb35-652"><a href="#cb35-652" aria-hidden="true" tabindex="-1"></a>    B b<span class="op">;</span></span>
<span id="cb35-653"><a href="#cb35-653" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb35-654"><a href="#cb35-654" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb35-655"><a href="#cb35-655" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb35-656"><a href="#cb35-656" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb35-657"><a href="#cb35-657" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-658"><a href="#cb35-658" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb35-659"><a href="#cb35-659" aria-hidden="true" tabindex="-1"></a><span class="in">Inside A's constructor</span></span>
<span id="cb35-660"><a href="#cb35-660" aria-hidden="true" tabindex="-1"></a><span class="in">Inside B's constructor</span></span>
<span id="cb35-661"><a href="#cb35-661" aria-hidden="true" tabindex="-1"></a><span class="in">Inside B's destructor</span></span>
<span id="cb35-662"><a href="#cb35-662" aria-hidden="true" tabindex="-1"></a><span class="in">Inside A's destructor</span></span>
<span id="cb35-663"><a href="#cb35-663" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb35-664"><a href="#cb35-664" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-665"><a href="#cb35-665" aria-hidden="true" tabindex="-1"></a>Suppose you have a base class <span class="in">`Parent`</span>, two child classes <span class="in">`Child_1`</span> and <span class="in">`Child_2`</span> that inherit from <span class="in">`Parent`</span> and a <span class="in">`Grandchild`</span> class that inherits from <span class="in">`Child_1`</span> and <span class="in">`Child_2`</span>. This is the diamond problem, named after the shape of such inheritance diagrams. The <span class="in">`Grandchild`</span> inherits two copies of <span class="in">`Parent`</span> : one through <span class="in">`Child_1`</span> and another through <span class="in">`Child_2`</span>. </span>
<span id="cb35-666"><a href="#cb35-666" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-667"><a href="#cb35-667" aria-hidden="true" tabindex="-1"></a>To prevent the duplication of the base class, we identify to the compiler that the base class should appear only once within the derived class. We do this by specifying the class as a *virtual base class* using the <span class="in">`virtual`</span> keword. The <span class="in">`Child_1`</span> and <span class="in">`Child_2`</span> classes would be defined like this:</span>
<span id="cb35-668"><a href="#cb35-668" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-669"><a href="#cb35-669" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb35-670"><a href="#cb35-670" aria-hidden="true" tabindex="-1"></a><span class="in">class Child_1 : public virtual Parent</span></span>
<span id="cb35-671"><a href="#cb35-671" aria-hidden="true" tabindex="-1"></a><span class="in">{</span></span>
<span id="cb35-672"><a href="#cb35-672" aria-hidden="true" tabindex="-1"></a><span class="in">    //...</span></span>
<span id="cb35-673"><a href="#cb35-673" aria-hidden="true" tabindex="-1"></a><span class="in">};</span></span>
<span id="cb35-674"><a href="#cb35-674" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-675"><a href="#cb35-675" aria-hidden="true" tabindex="-1"></a><span class="in">class Child_2 : public virtual Parent</span></span>
<span id="cb35-676"><a href="#cb35-676" aria-hidden="true" tabindex="-1"></a><span class="in">{</span></span>
<span id="cb35-677"><a href="#cb35-677" aria-hidden="true" tabindex="-1"></a><span class="in">    //...</span></span>
<span id="cb35-678"><a href="#cb35-678" aria-hidden="true" tabindex="-1"></a><span class="in">};</span></span>
<span id="cb35-679"><a href="#cb35-679" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb35-680"><a href="#cb35-680" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-681"><a href="#cb35-681" aria-hidden="true" tabindex="-1"></a><span class="fu">### Polymorphism.</span></span>
<span id="cb35-682"><a href="#cb35-682" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-683"><a href="#cb35-683" aria-hidden="true" tabindex="-1"></a>Every derived class object is a base class object. So, you can use a base class pointer/reference to store the address of a derived class object. It is easy to implement dynamic dispatch through virtual methods.</span>
<span id="cb35-684"><a href="#cb35-684" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-685"><a href="#cb35-685" aria-hidden="true" tabindex="-1"></a>The below code snippet is instructive in understanding run-time polymorphism.</span>
<span id="cb35-686"><a href="#cb35-686" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-687"><a href="#cb35-687" aria-hidden="true" tabindex="-1"></a><span class="in">```cpp</span></span>
<span id="cb35-688"><a href="#cb35-688" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;memory&gt;</span></span>
<span id="cb35-689"><a href="#cb35-689" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb35-690"><a href="#cb35-690" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-691"><a href="#cb35-691" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb35-692"><a href="#cb35-692" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-693"><a href="#cb35-693" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A <span class="op">{</span></span>
<span id="cb35-694"><a href="#cb35-694" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb35-695"><a href="#cb35-695" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> foo<span class="op">()</span> <span class="op">{</span></span>
<span id="cb35-696"><a href="#cb35-696" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">Greetings from a!"</span><span class="op">;</span></span>
<span id="cb35-697"><a href="#cb35-697" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb35-698"><a href="#cb35-698" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb35-699"><a href="#cb35-699" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-700"><a href="#cb35-700" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> B <span class="op">:</span><span class="kw">public</span> A <span class="op">{</span></span>
<span id="cb35-701"><a href="#cb35-701" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb35-702"><a href="#cb35-702" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="dt">void</span> foo<span class="op">()</span></span>
<span id="cb35-703"><a href="#cb35-703" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb35-704"><a href="#cb35-704" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">Greetings from b!"</span><span class="op">;</span></span>
<span id="cb35-705"><a href="#cb35-705" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb35-706"><a href="#cb35-706" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb35-707"><a href="#cb35-707" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-708"><a href="#cb35-708" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-709"><a href="#cb35-709" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> C <span class="op">:</span> <span class="kw">public</span> B <span class="op">{</span></span>
<span id="cb35-710"><a href="#cb35-710" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="cb35-711"><a href="#cb35-711" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="dt">void</span> foo<span class="op">()</span></span>
<span id="cb35-712"><a href="#cb35-712" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb35-713"><a href="#cb35-713" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">Greetings from c!"</span><span class="op">;</span></span>
<span id="cb35-714"><a href="#cb35-714" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb35-715"><a href="#cb35-715" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb35-716"><a href="#cb35-716" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-717"><a href="#cb35-717" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> D <span class="op">:</span> <span class="kw">public</span> C <span class="op">{</span></span>
<span id="cb35-718"><a href="#cb35-718" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb35-719"><a href="#cb35-719" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> foo<span class="op">()</span></span>
<span id="cb35-720"><a href="#cb35-720" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb35-721"><a href="#cb35-721" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">Greetings from d!"</span><span class="op">;</span></span>
<span id="cb35-722"><a href="#cb35-722" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb35-723"><a href="#cb35-723" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb35-724"><a href="#cb35-724" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-725"><a href="#cb35-725" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb35-726"><a href="#cb35-726" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb35-727"><a href="#cb35-727" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>shared_ptr<span class="op">&lt;</span>A<span class="op">&gt;</span> a_ptr <span class="op">=</span> <span class="bu">std::</span>make_shared<span class="op">&lt;</span>D<span class="op">&gt;();</span></span>
<span id="cb35-728"><a href="#cb35-728" aria-hidden="true" tabindex="-1"></a>    a_ptr <span class="op">-&gt;</span>foo<span class="op">();</span></span>
<span id="cb35-729"><a href="#cb35-729" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb35-730"><a href="#cb35-730" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>shared_ptr<span class="op">&lt;</span>B<span class="op">&gt;</span> b_ptr <span class="op">=</span> <span class="bu">std::</span>make_shared<span class="op">&lt;</span>D<span class="op">&gt;();</span></span>
<span id="cb35-731"><a href="#cb35-731" aria-hidden="true" tabindex="-1"></a>    b_ptr <span class="op">-&gt;</span>foo<span class="op">();</span></span>
<span id="cb35-732"><a href="#cb35-732" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb35-733"><a href="#cb35-733" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>shared_ptr<span class="op">&lt;</span>C<span class="op">&gt;</span> c_ptr <span class="op">=</span> <span class="bu">std::</span>make_shared<span class="op">&lt;</span>D<span class="op">&gt;();</span></span>
<span id="cb35-734"><a href="#cb35-734" aria-hidden="true" tabindex="-1"></a>    <span class="co">//c_ptr -&gt;foo();  //will not compile, foo() is a private member is not inherited by D</span></span>
<span id="cb35-735"><a href="#cb35-735" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb35-736"><a href="#cb35-736" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>shared_ptr<span class="op">&lt;</span>D<span class="op">&gt;</span> d_ptr <span class="op">=</span> <span class="bu">std::</span>make_shared<span class="op">&lt;</span>D<span class="op">&gt;();</span></span>
<span id="cb35-737"><a href="#cb35-737" aria-hidden="true" tabindex="-1"></a>    d_ptr <span class="op">-&gt;</span>foo<span class="op">();</span></span>
<span id="cb35-738"><a href="#cb35-738" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb35-739"><a href="#cb35-739" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb35-740"><a href="#cb35-740" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-741"><a href="#cb35-741" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb35-742"><a href="#cb35-742" aria-hidden="true" tabindex="-1"></a><span class="in">Greetings from a!</span></span>
<span id="cb35-743"><a href="#cb35-743" aria-hidden="true" tabindex="-1"></a><span class="in">Greetings from d!</span></span>
<span id="cb35-744"><a href="#cb35-744" aria-hidden="true" tabindex="-1"></a><span class="in">Greetings from d!</span></span>
<span id="cb35-745"><a href="#cb35-745" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb35-746"><a href="#cb35-746" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-747"><a href="#cb35-747" aria-hidden="true" tabindex="-1"></a>When you specify a function as <span class="in">`virtual`</span> in a base class, you indicate to the compiler that you want dynamic binding for function calls in any class that's derived from this base class. A function that you specify as <span class="in">`virtual`</span> in the base class will be <span class="in">`virtual`</span> in all classes that directly or indirectly derive from the base class. This is the case, whether or not you specify the function as <span class="in">`virtual`</span> in the derived class. </span>
<span id="cb35-748"><a href="#cb35-748" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-749"><a href="#cb35-749" aria-hidden="true" tabindex="-1"></a>The call to a virtual function using an **object** is always resolved statically. You only get dybamic resolution of calls to virtual functions through a pointer or a reference. Consider the below code snippet:</span>
<span id="cb35-750"><a href="#cb35-750" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-751"><a href="#cb35-751" aria-hidden="true" tabindex="-1"></a><span class="in">```cpp</span></span>
<span id="cb35-752"><a href="#cb35-752" aria-hidden="true" tabindex="-1"></a>    D d<span class="op">{};</span></span>
<span id="cb35-753"><a href="#cb35-753" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb35-754"><a href="#cb35-754" aria-hidden="true" tabindex="-1"></a>    A<span class="op">&amp;</span> aRef <span class="op">=</span> d<span class="op">;</span></span>
<span id="cb35-755"><a href="#cb35-755" aria-hidden="true" tabindex="-1"></a>    B<span class="op">&amp;</span> bRef <span class="op">=</span> d<span class="op">;</span></span>
<span id="cb35-756"><a href="#cb35-756" aria-hidden="true" tabindex="-1"></a>    A a<span class="op">;</span> B b<span class="op">;</span></span>
<span id="cb35-757"><a href="#cb35-757" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb35-758"><a href="#cb35-758" aria-hidden="true" tabindex="-1"></a>    aRef<span class="op">.</span>foo<span class="op">();</span></span>
<span id="cb35-759"><a href="#cb35-759" aria-hidden="true" tabindex="-1"></a>    bRef<span class="op">.</span>foo<span class="op">();</span></span>
<span id="cb35-760"><a href="#cb35-760" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb35-761"><a href="#cb35-761" aria-hidden="true" tabindex="-1"></a>    a<span class="op">.</span>foo<span class="op">();</span></span>
<span id="cb35-762"><a href="#cb35-762" aria-hidden="true" tabindex="-1"></a>    b<span class="op">.</span>foo<span class="op">();</span></span>
<span id="cb35-763"><a href="#cb35-763" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb35-764"><a href="#cb35-764" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-765"><a href="#cb35-765" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb35-766"><a href="#cb35-766" aria-hidden="true" tabindex="-1"></a><span class="in">Greetings from a!</span></span>
<span id="cb35-767"><a href="#cb35-767" aria-hidden="true" tabindex="-1"></a><span class="in">Greetings from d!</span></span>
<span id="cb35-768"><a href="#cb35-768" aria-hidden="true" tabindex="-1"></a><span class="in">Greetings from a!</span></span>
<span id="cb35-769"><a href="#cb35-769" aria-hidden="true" tabindex="-1"></a><span class="in">Greetings from b!</span></span>
<span id="cb35-770"><a href="#cb35-770" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb35-771"><a href="#cb35-771" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-772"><a href="#cb35-772" aria-hidden="true" tabindex="-1"></a><span class="fu">#### Requirements for a virtual function.</span></span>
<span id="cb35-773"><a href="#cb35-773" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-774"><a href="#cb35-774" aria-hidden="true" tabindex="-1"></a>For a function to be <span class="in">`virtual`</span>, its definition in a derived class must have the same signature as it has in the base class. If the base class function is <span class="in">`const`</span>, for instance, then the derive class function must also be <span class="in">`const`</span>. Generally, the return type of a virtual function in a derived class must be the same as in the base class as well, but there's an exception when the return type in the base class is a pointer or a reference to a class type. In this case, the derived class version of a virtual function may return a pointer or a reference to a more specialized type than that of the base. This is called *covariance*.</span>
<span id="cb35-775"><a href="#cb35-775" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-776"><a href="#cb35-776" aria-hidden="true" tabindex="-1"></a>Another restriction is that a virtual function can't be a template function. </span>
<span id="cb35-777"><a href="#cb35-777" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-778"><a href="#cb35-778" aria-hidden="true" tabindex="-1"></a>In standard object-oriented programming terms, a function in a derived class that redefines a function of the base class is said to *override* this function. A function with the same name as a virtual function in a base class only **overrides** that function if the remainder of their signatures match exactly as well; if they do not, the function in the derived class is a new function that *hides* the one in the base class. </span>
<span id="cb35-779"><a href="#cb35-779" aria-hidden="true" tabindex="-1"></a>This means that if you try to use different parameters for a virtual function in a derived class or use different <span class="in">`const`</span> specifiers, then the virtual function mechanism won't work. The function in the derived class then defines, a new different function - and this new function will therefore operate with static binding that is established and fixed at compile time. </span>
<span id="cb35-780"><a href="#cb35-780" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-781"><a href="#cb35-781" aria-hidden="true" tabindex="-1"></a><span class="fu">#### `override` specifier.</span></span>
<span id="cb35-782"><a href="#cb35-782" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-783"><a href="#cb35-783" aria-hidden="true" tabindex="-1"></a>The <span class="in">`override`</span> specification guarantees that you don't make mistakes in function overrides and these exactly match the virtual function signatures in base class. </span>
<span id="cb35-784"><a href="#cb35-784" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-785"><a href="#cb35-785" aria-hidden="true" tabindex="-1"></a><span class="fu">#### `final` qualifier.</span></span>
<span id="cb35-786"><a href="#cb35-786" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-787"><a href="#cb35-787" aria-hidden="true" tabindex="-1"></a>Sometimes, we may want to prevent a member function from being overriden in a derived class. We can do this by specifying that a function is <span class="in">`final`</span>.</span>
<span id="cb35-788"><a href="#cb35-788" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-789"><a href="#cb35-789" aria-hidden="true" tabindex="-1"></a><span class="fu">### Virtual destructors.</span></span>
<span id="cb35-790"><a href="#cb35-790" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-791"><a href="#cb35-791" aria-hidden="true" tabindex="-1"></a>Along with the other function, the destructor methods of classes should also be resolved dynamically. That is, if a <span class="in">`Base*`</span> pointer points to <span class="in">`Derived`</span> object, the <span class="in">`Derived`</span> class destructor method should be called first. (Object creation is top-down, destruction is bottom-up in an inheritance hierarchy). So, it's always prudent to declare destructor methods as <span class="in">`virtual`</span>.</span>
<span id="cb35-792"><a href="#cb35-792" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-793"><a href="#cb35-793" aria-hidden="true" tabindex="-1"></a><span class="fu">### Calling the base class version of a virtual function.</span></span>
<span id="cb35-794"><a href="#cb35-794" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-795"><a href="#cb35-795" aria-hidden="true" tabindex="-1"></a>It's easy to call the derived class version of a virtual function through a pointer or reference to a derived class object - the call is made dynamically. However, what do you do when you actually want to call the base class function for a derived class object?</span>
<span id="cb35-796"><a href="#cb35-796" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-797"><a href="#cb35-797" aria-hidden="true" tabindex="-1"></a>Consider the <span class="in">`Box`</span> and <span class="in">`ToughPack`</span> classes.</span>
<span id="cb35-798"><a href="#cb35-798" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-799"><a href="#cb35-799" aria-hidden="true" tabindex="-1"></a><span class="in">```cpp</span></span>
<span id="cb35-800"><a href="#cb35-800" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb35-801"><a href="#cb35-801" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;memory&gt;</span></span>
<span id="cb35-802"><a href="#cb35-802" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb35-803"><a href="#cb35-803" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-804"><a href="#cb35-804" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Box<span class="op">{</span></span>
<span id="cb35-805"><a href="#cb35-805" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb35-806"><a href="#cb35-806" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb35-807"><a href="#cb35-807" aria-hidden="true" tabindex="-1"></a>    Box<span class="op">()</span> <span class="op">:</span> Box<span class="op">(</span><span class="fl">1.0</span><span class="op">)</span> <span class="op">{}</span></span>
<span id="cb35-808"><a href="#cb35-808" aria-hidden="true" tabindex="-1"></a>    Box<span class="op">(</span><span class="dt">double</span> side<span class="op">)</span> <span class="op">:</span> Box<span class="op">(</span>side<span class="op">,</span> side<span class="op">,</span> side<span class="op">)</span> <span class="op">{}</span></span>
<span id="cb35-809"><a href="#cb35-809" aria-hidden="true" tabindex="-1"></a>    Box<span class="op">(</span><span class="dt">double</span> length<span class="op">,</span> <span class="dt">double</span> width<span class="op">,</span> <span class="dt">double</span> height<span class="op">)</span> <span class="op">:</span> <span class="va">m_length</span><span class="op">(</span>length<span class="op">),</span> <span class="va">m_width</span><span class="op">(</span>width<span class="op">),</span> <span class="va">m_height</span><span class="op">(</span>height<span class="op">)</span> <span class="op">{}</span></span>
<span id="cb35-810"><a href="#cb35-810" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb35-811"><a href="#cb35-811" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> <span class="kw">virtual</span> volume<span class="op">()</span></span>
<span id="cb35-812"><a href="#cb35-812" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb35-813"><a href="#cb35-813" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">m_length</span> <span class="op">*</span> <span class="va">m_width</span> <span class="op">*</span> <span class="va">m_height</span><span class="op">;</span></span>
<span id="cb35-814"><a href="#cb35-814" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb35-815"><a href="#cb35-815" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb35-816"><a href="#cb35-816" aria-hidden="true" tabindex="-1"></a>    <span class="op">~</span>Box<span class="op">()</span></span>
<span id="cb35-817"><a href="#cb35-817" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb35-818"><a href="#cb35-818" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">Box dtor"</span><span class="op">;</span></span>
<span id="cb35-819"><a href="#cb35-819" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb35-820"><a href="#cb35-820" aria-hidden="true" tabindex="-1"></a>    <span class="kw">protected</span><span class="op">:</span></span>
<span id="cb35-821"><a href="#cb35-821" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> <span class="va">m_length</span><span class="op">;</span></span>
<span id="cb35-822"><a href="#cb35-822" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> <span class="va">m_width</span><span class="op">;</span></span>
<span id="cb35-823"><a href="#cb35-823" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> <span class="va">m_height</span><span class="op">;</span></span>
<span id="cb35-824"><a href="#cb35-824" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb35-825"><a href="#cb35-825" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-826"><a href="#cb35-826" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> ToughPack <span class="op">:</span> <span class="kw">public</span> Box</span>
<span id="cb35-827"><a href="#cb35-827" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb35-828"><a href="#cb35-828" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb35-829"><a href="#cb35-829" aria-hidden="true" tabindex="-1"></a>    ToughPack<span class="op">()</span> <span class="op">:</span> Box<span class="op">()</span> <span class="op">{}</span></span>
<span id="cb35-830"><a href="#cb35-830" aria-hidden="true" tabindex="-1"></a>    ToughPack<span class="op">(</span><span class="dt">double</span> side<span class="op">)</span> <span class="op">:</span> Box<span class="op">(</span>side<span class="op">)</span> <span class="op">{}</span></span>
<span id="cb35-831"><a href="#cb35-831" aria-hidden="true" tabindex="-1"></a>    ToughPack<span class="op">(</span><span class="dt">double</span> x<span class="op">,</span> <span class="dt">double</span> y<span class="op">,</span> <span class="dt">double</span> z<span class="op">)</span> <span class="op">:</span> Box<span class="op">(</span>x<span class="op">,</span>y<span class="op">,</span>z<span class="op">)</span> <span class="op">{}</span></span>
<span id="cb35-832"><a href="#cb35-832" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb35-833"><a href="#cb35-833" aria-hidden="true" tabindex="-1"></a>    <span class="co">//Function to calculate volume allowing for 15% of packing</span></span>
<span id="cb35-834"><a href="#cb35-834" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> volume<span class="op">()</span> <span class="kw">override</span></span>
<span id="cb35-835"><a href="#cb35-835" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb35-836"><a href="#cb35-836" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="fl">0.85</span> <span class="op">*</span> <span class="va">m_length</span> <span class="op">*</span> <span class="va">m_width</span> <span class="op">*</span> <span class="va">m_height</span> <span class="op">;</span></span>
<span id="cb35-837"><a href="#cb35-837" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb35-838"><a href="#cb35-838" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb35-839"><a href="#cb35-839" aria-hidden="true" tabindex="-1"></a>    <span class="op">~</span>ToughPack<span class="op">()</span></span>
<span id="cb35-840"><a href="#cb35-840" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb35-841"><a href="#cb35-841" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">ToughPack dtor"</span><span class="op">;</span></span>
<span id="cb35-842"><a href="#cb35-842" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb35-843"><a href="#cb35-843" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb35-844"><a href="#cb35-844" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb35-845"><a href="#cb35-845" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-846"><a href="#cb35-846" aria-hidden="true" tabindex="-1"></a>In <span class="in">`ToughPack`</span>'s <span class="in">`volume()`</span> method, the <span class="in">`m_length*m_width*m_height`</span> part of the <span class="in">`return`</span> statement is exactly the formula used to compute the <span class="in">`volume()`</span> inside the base class <span class="in">`Box`</span>. In this case, the amount of code we had to retype was limited, but this won't always be the case. It would therefore be much better if you could simply call the base class version of this function isntead.</span>
<span id="cb35-847"><a href="#cb35-847" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-848"><a href="#cb35-848" aria-hidden="true" tabindex="-1"></a>A plausible first attempt to do so would be:</span>
<span id="cb35-849"><a href="#cb35-849" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-850"><a href="#cb35-850" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb35-851"><a href="#cb35-851" aria-hidden="true" tabindex="-1"></a><span class="in">double volume() const override</span></span>
<span id="cb35-852"><a href="#cb35-852" aria-hidden="true" tabindex="-1"></a><span class="in">{</span></span>
<span id="cb35-853"><a href="#cb35-853" aria-hidden="true" tabindex="-1"></a><span class="in">    return 0.85 * volume(); // Infinite recursion!</span></span>
<span id="cb35-854"><a href="#cb35-854" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb35-855"><a href="#cb35-855" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb35-856"><a href="#cb35-856" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-857"><a href="#cb35-857" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-858"><a href="#cb35-858" aria-hidden="true" tabindex="-1"></a>However, this would call <span class="in">`volume()`</span> override itself, which would then be calling itself again, which would then be calling itself again! This leads to infinite recursion and a crash.</span>
<span id="cb35-859"><a href="#cb35-859" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-860"><a href="#cb35-860" aria-hidden="true" tabindex="-1"></a>Calling the base class version from within a function override like this is common. The solution is to explicitly ask the compiler to call the base class version of the function.</span>
<span id="cb35-861"><a href="#cb35-861" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-862"><a href="#cb35-862" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb35-863"><a href="#cb35-863" aria-hidden="true" tabindex="-1"></a><span class="in">double volume() const override</span></span>
<span id="cb35-864"><a href="#cb35-864" aria-hidden="true" tabindex="-1"></a><span class="in">{</span></span>
<span id="cb35-865"><a href="#cb35-865" aria-hidden="true" tabindex="-1"></a><span class="in">    return 0.85 * Box::volume(); </span></span>
<span id="cb35-866"><a href="#cb35-866" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb35-867"><a href="#cb35-867" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb35-868"><a href="#cb35-868" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-869"><a href="#cb35-869" aria-hidden="true" tabindex="-1"></a><span class="fu">### When my base class’s constructor calls a virtual function on its this object, why doesn’t my derived class’s override of that virtual function get invoked?</span></span>
<span id="cb35-870"><a href="#cb35-870" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-871"><a href="#cb35-871" aria-hidden="true" tabindex="-1"></a>What happens when we call virtual functions from inside constructors and destructors? Calling a polymorphic function from inside a constructor/desctructor is a recipe for disaster in most cases. It should be avoided whenver possible. </span>
<span id="cb35-872"><a href="#cb35-872" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-873"><a href="#cb35-873" aria-hidden="true" tabindex="-1"></a>In a constructor, the virtual call mechanism is disabled, because overriding from derived classes hasn't happened yet. Objects are constructed from <span class="in">`Base`</span> up, "Base before derived".</span>
<span id="cb35-874"><a href="#cb35-874" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-875"><a href="#cb35-875" aria-hidden="true" tabindex="-1"></a>Since <span class="in">`Base`</span> object must be constructed before <span class="in">`Derived`</span>, the call to <span class="in">`f()`</span> always resolves statically to <span class="in">`Base::f()`</span> from inside the constructor.  </span>
<span id="cb35-876"><a href="#cb35-876" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-877"><a href="#cb35-877" aria-hidden="true" tabindex="-1"></a><span class="in">```cpp</span></span>
<span id="cb35-878"><a href="#cb35-878" aria-hidden="true" tabindex="-1"></a><span class="pp">#include</span><span class="im">&lt;string&gt;</span></span>
<span id="cb35-879"><a href="#cb35-879" aria-hidden="true" tabindex="-1"></a><span class="pp">#include</span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb35-880"><a href="#cb35-880" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb35-881"><a href="#cb35-881" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> B <span class="op">{</span></span>
<span id="cb35-882"><a href="#cb35-882" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb35-883"><a href="#cb35-883" aria-hidden="true" tabindex="-1"></a>    B<span class="op">(</span><span class="at">const</span> string<span class="op">&amp;</span> ss<span class="op">)</span> <span class="op">{</span> cout <span class="op">&lt;&lt;</span> <span class="st">"B constructor</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span> f<span class="op">(</span>ss<span class="op">);</span> <span class="op">}</span></span>
<span id="cb35-884"><a href="#cb35-884" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="dt">void</span> f<span class="op">(</span><span class="at">const</span> string<span class="op">&amp;)</span> <span class="op">{</span> cout <span class="op">&lt;&lt;</span> <span class="st">"B::f</span><span class="sc">\n</span><span class="st">"</span><span class="op">;}</span></span>
<span id="cb35-885"><a href="#cb35-885" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb35-886"><a href="#cb35-886" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> D <span class="op">:</span> <span class="kw">public</span> B <span class="op">{</span></span>
<span id="cb35-887"><a href="#cb35-887" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb35-888"><a href="#cb35-888" aria-hidden="true" tabindex="-1"></a>    D<span class="op">(</span><span class="at">const</span> string <span class="op">&amp;</span> ss<span class="op">)</span> <span class="op">:</span>B<span class="op">(</span>ss<span class="op">)</span> <span class="op">{</span> cout <span class="op">&lt;&lt;</span> <span class="st">"D constructor</span><span class="sc">\n</span><span class="st">"</span><span class="op">;}</span></span>
<span id="cb35-889"><a href="#cb35-889" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> f<span class="op">(</span><span class="at">const</span> string<span class="op">&amp;</span> ss<span class="op">)</span> <span class="op">{</span> cout <span class="op">&lt;&lt;</span> <span class="st">"D::f</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span> s <span class="op">=</span> ss<span class="op">;</span> <span class="op">}</span></span>
<span id="cb35-890"><a href="#cb35-890" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="cb35-891"><a href="#cb35-891" aria-hidden="true" tabindex="-1"></a>    string s<span class="op">;</span></span>
<span id="cb35-892"><a href="#cb35-892" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb35-893"><a href="#cb35-893" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb35-894"><a href="#cb35-894" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb35-895"><a href="#cb35-895" aria-hidden="true" tabindex="-1"></a>    D d<span class="op">(</span><span class="st">"Hello"</span><span class="op">);</span></span>
<span id="cb35-896"><a href="#cb35-896" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb35-897"><a href="#cb35-897" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-898"><a href="#cb35-898" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb35-899"><a href="#cb35-899" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-900"><a href="#cb35-900" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb35-901"><a href="#cb35-901" aria-hidden="true" tabindex="-1"></a><span class="in">B constructor</span></span>
<span id="cb35-902"><a href="#cb35-902" aria-hidden="true" tabindex="-1"></a><span class="in">B::f</span></span>
<span id="cb35-903"><a href="#cb35-903" aria-hidden="true" tabindex="-1"></a><span class="in">D constructor</span></span>
<span id="cb35-904"><a href="#cb35-904" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb35-905"><a href="#cb35-905" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-906"><a href="#cb35-906" aria-hidden="true" tabindex="-1"></a><span class="fu">### How can I set up my class so it won't be inherited from?</span></span>
<span id="cb35-907"><a href="#cb35-907" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-908"><a href="#cb35-908" aria-hidden="true" tabindex="-1"></a>Just declare the class as <span class="in">`final`</span>. </span>
<span id="cb35-909"><a href="#cb35-909" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-910"><a href="#cb35-910" aria-hidden="true" tabindex="-1"></a><span class="fu">## Pure virtual functions.</span></span>
<span id="cb35-911"><a href="#cb35-911" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-912"><a href="#cb35-912" aria-hidden="true" tabindex="-1"></a>There are situations where we require a base class with a virtual function that's redefined in each of the derived classes, but hwere there's no meaningful definition for the function in the base class. For example, you might define a base class <span class="in">`Shape`</span>, from which you derive classes definining specific shapes, such as <span class="in">`Circle`</span>, <span class="in">`Ellipse`</span>, <span class="in">`Rectangle`</span>, <span class="in">`Hexagon`</span> and so on. The <span class="in">`Shape`</span> class could include a virtual function <span class="in">`area()`</span>, that you'd call for the derived class object to compute the area of a particular shape. The <span class="in">`Shape`</span> class itself, though, cannot possibly provide a meaningful implementation of the <span class="in">`area()`</span> function, one that caters, for instance, to both <span class="in">`Circle`</span>s and <span class="in">`Rectangle`</span>s. This is a job for a *pure virtual function*.</span>
<span id="cb35-913"><a href="#cb35-913" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-914"><a href="#cb35-914" aria-hidden="true" tabindex="-1"></a>The purpose of a pure virtual function is to enable the derived class versions of the function to be called polymorphically. To declare a pure virtual function rather than an ordinary virtual function that has a definition, you use the same syntax but add <span class="in">`=0`</span> to it's declaration within the class. </span>
<span id="cb35-915"><a href="#cb35-915" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-916"><a href="#cb35-916" aria-hidden="true" tabindex="-1"></a><span class="in">```cpp</span></span>
<span id="cb35-917"><a href="#cb35-917" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb35-918"><a href="#cb35-918" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;memory&gt;</span></span>
<span id="cb35-919"><a href="#cb35-919" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb35-920"><a href="#cb35-920" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-921"><a href="#cb35-921" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Shape <span class="op">{</span></span>
<span id="cb35-922"><a href="#cb35-922" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb35-923"><a href="#cb35-923" aria-hidden="true" tabindex="-1"></a>    Shape<span class="op">()</span> <span class="op">=</span> <span class="cf">default</span><span class="op">;</span></span>
<span id="cb35-924"><a href="#cb35-924" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="dt">double</span> area<span class="op">()</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> <span class="co">//pure virtual function</span></span>
<span id="cb35-925"><a href="#cb35-925" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-926"><a href="#cb35-926" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb35-927"><a href="#cb35-927" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-928"><a href="#cb35-928" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Rectangle <span class="op">:</span> <span class="kw">public</span> Shape <span class="op">{</span></span>
<span id="cb35-929"><a href="#cb35-929" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb35-930"><a href="#cb35-930" aria-hidden="true" tabindex="-1"></a>    Rectangle<span class="op">(</span><span class="dt">double</span> l<span class="op">,</span> <span class="dt">double</span> w<span class="op">)</span> <span class="op">:</span> <span class="va">m_length</span><span class="op">(</span>l<span class="op">),</span> <span class="va">m_width</span><span class="op">(</span>w<span class="op">)</span> <span class="op">{}</span></span>
<span id="cb35-931"><a href="#cb35-931" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-932"><a href="#cb35-932" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> area<span class="op">()</span> <span class="kw">override</span> <span class="op">{</span></span>
<span id="cb35-933"><a href="#cb35-933" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">m_length</span> <span class="op">*</span> <span class="va">m_width</span><span class="op">;</span></span>
<span id="cb35-934"><a href="#cb35-934" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb35-935"><a href="#cb35-935" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="cb35-936"><a href="#cb35-936" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> <span class="va">m_length</span><span class="op">;</span></span>
<span id="cb35-937"><a href="#cb35-937" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> <span class="va">m_width</span><span class="op">;</span></span>
<span id="cb35-938"><a href="#cb35-938" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb35-939"><a href="#cb35-939" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-940"><a href="#cb35-940" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Circle <span class="op">:</span> <span class="kw">public</span> Shape <span class="op">{</span></span>
<span id="cb35-941"><a href="#cb35-941" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-942"><a href="#cb35-942" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb35-943"><a href="#cb35-943" aria-hidden="true" tabindex="-1"></a>    Circle<span class="op">(</span><span class="dt">double</span> r<span class="op">)</span> <span class="op">:</span> <span class="va">m_radius</span><span class="op">(</span>r<span class="op">)</span> <span class="op">{}</span></span>
<span id="cb35-944"><a href="#cb35-944" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-945"><a href="#cb35-945" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> area<span class="op">()</span> <span class="kw">override</span> <span class="op">{</span></span>
<span id="cb35-946"><a href="#cb35-946" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="fl">3.14159</span> <span class="op">*</span> <span class="va">m_radius</span> <span class="op">*</span> <span class="va">m_radius</span><span class="op">;</span></span>
<span id="cb35-947"><a href="#cb35-947" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb35-948"><a href="#cb35-948" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-949"><a href="#cb35-949" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="cb35-950"><a href="#cb35-950" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> <span class="va">m_radius</span><span class="op">;</span></span>
<span id="cb35-951"><a href="#cb35-951" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb35-952"><a href="#cb35-952" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-953"><a href="#cb35-953" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb35-954"><a href="#cb35-954" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb35-955"><a href="#cb35-955" aria-hidden="true" tabindex="-1"></a>    <span class="co">//Let's create a container to hold different kinds of shapes</span></span>
<span id="cb35-956"><a href="#cb35-956" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>unique_ptr<span class="op">&lt;</span>Shape<span class="op">&gt;&gt;</span> shapes<span class="op">{};</span></span>
<span id="cb35-957"><a href="#cb35-957" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-958"><a href="#cb35-958" aria-hidden="true" tabindex="-1"></a>    shapes<span class="op">.</span>push_back<span class="op">(</span><span class="bu">std::</span>make_unique<span class="op">&lt;</span>Rectangle<span class="op">&gt;(</span><span class="fl">5.0</span><span class="op">,</span> <span class="fl">5.0</span><span class="op">));</span></span>
<span id="cb35-959"><a href="#cb35-959" aria-hidden="true" tabindex="-1"></a>    shapes<span class="op">.</span>push_back<span class="op">(</span><span class="bu">std::</span>make_unique<span class="op">&lt;</span>Circle<span class="op">&gt;(</span><span class="fl">3.0</span><span class="op">));</span></span>
<span id="cb35-960"><a href="#cb35-960" aria-hidden="true" tabindex="-1"></a>    shapes<span class="op">.</span>push_back<span class="op">(</span><span class="bu">std::</span>make_unique<span class="op">&lt;</span>Rectangle<span class="op">&gt;(</span><span class="fl">10.0</span><span class="op">,</span> <span class="fl">12.0</span><span class="op">));</span></span>
<span id="cb35-961"><a href="#cb35-961" aria-hidden="true" tabindex="-1"></a>    shapes<span class="op">.</span>push_back<span class="op">(</span><span class="bu">std::</span>make_unique<span class="op">&lt;</span>Circle<span class="op">&gt;(</span><span class="fl">5.0</span><span class="op">));</span></span>
<span id="cb35-962"><a href="#cb35-962" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-963"><a href="#cb35-963" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i<span class="op">{};</span> i <span class="op">&lt;</span> shapes<span class="op">.</span>size<span class="op">();</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb35-964"><a href="#cb35-964" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb35-965"><a href="#cb35-965" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">Area = "</span> <span class="op">&lt;&lt;</span> shapes<span class="op">[</span>i<span class="op">]-&gt;</span>area<span class="op">();</span></span>
<span id="cb35-966"><a href="#cb35-966" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb35-967"><a href="#cb35-967" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-968"><a href="#cb35-968" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb35-969"><a href="#cb35-969" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb35-970"><a href="#cb35-970" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb35-971"><a href="#cb35-971" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-972"><a href="#cb35-972" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb35-973"><a href="#cb35-973" aria-hidden="true" tabindex="-1"></a><span class="in">Area = 25</span></span>
<span id="cb35-974"><a href="#cb35-974" aria-hidden="true" tabindex="-1"></a><span class="in">Area = 28.2743</span></span>
<span id="cb35-975"><a href="#cb35-975" aria-hidden="true" tabindex="-1"></a><span class="in">Area = 120</span></span>
<span id="cb35-976"><a href="#cb35-976" aria-hidden="true" tabindex="-1"></a><span class="in">Area = 78.5397</span></span>
<span id="cb35-977"><a href="#cb35-977" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb35-978"><a href="#cb35-978" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-979"><a href="#cb35-979" aria-hidden="true" tabindex="-1"></a><span class="fu">## Abstract Classes.</span></span>
<span id="cb35-980"><a href="#cb35-980" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-981"><a href="#cb35-981" aria-hidden="true" tabindex="-1"></a>An abstract class purely exists for the purpose of deriving classes from it and cannot be instantiated.</span>
<span id="cb35-982"><a href="#cb35-982" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-983"><a href="#cb35-983" aria-hidden="true" tabindex="-1"></a>Any class that contains atleast one pure virtual function is an abstract class. Because an abstract class cannot be instantiated, you cannot pass it by value to a function, a parameter of type <span class="in">`Shape`</span> will not compile. Similarly, you cannot return a <span class="in">`Shape`</span> object from a functiojn. However, pointers or references to an abstract class can be used as parameter or return types, so types such as <span class="in">`Shape*`</span> <span class="in">`std::shared_ptr&lt;Shape&gt;`</span> and <span class="in">`Shape&amp;`</span> are fine in these settings. </span>
<span id="cb35-984"><a href="#cb35-984" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-985"><a href="#cb35-985" aria-hidden="true" tabindex="-1"></a>Any class that inherits from <span class="in">`Shape`</span> is obligated to provide an implementation of the <span class="in">`area()`</span> method. If it doesn't, it too is an abstract class. More specifically, if any pure virtual function of an abstract base class isn't in a derived class, then the pure virtual function will be inherited as such, and the derived class becomes an abstract class.</span>
<span id="cb35-986"><a href="#cb35-986" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-987"><a href="#cb35-987" aria-hidden="true" tabindex="-1"></a>Thus, abstract base classes (ABCs) are often used as interfaces.</span></code><button title="Copy to Clipboard" class="code-copy-button" data-in-quarto-modal=""><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->




</body></html>