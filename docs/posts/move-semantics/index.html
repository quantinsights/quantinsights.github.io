<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Quasar">
<meta name="dcterms.date" content="2024-10-26">

<title>A hitchhiker’s guide to move semantics and perfect forwarding – Quant Insights</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;800&display=swap');
  @import url('https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400..800;1,400..800&display=swap');
  @import url('https://fonts.googleapis.com/css2?family=Fira+Code:wght@300..700&display=swap');
  @import url('https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap');
  @import url('https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&family=Source+Code+Pro:ital,wght@0,200..900;1,200..900&display=swap');
  @import url('https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&display=swap');
</style>
<script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9993009899870547" crossorigin="anonymous"></script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Quant Insights</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com"> <i class="bi bi-twitter" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <div class="quarto-title-block"><div><h1 class="title">A hitchhiker’s guide to move semantics and perfect forwarding</h1><button type="button" class="btn code-tools-button" id="quarto-code-tools-source"><i class="bi"></i> Code</button></div></div>
                                <div class="quarto-categories">
                <div class="quarto-category">C++</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Quasar </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">October 26, 2024</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#motivation-for-move-semantics" id="toc-motivation-for-move-semantics" class="nav-link active" data-scroll-target="#motivation-for-move-semantics">Motivation for Move Semantics</a>
  <ul class="collapse">
  <li><a href="#value-semantics" id="toc-value-semantics" class="nav-link" data-scroll-target="#value-semantics">Value Semantics</a></li>
  </ul></li>
  <li><a href="#copy-elison" id="toc-copy-elison" class="nav-link" data-scroll-target="#copy-elison">Copy elison</a></li>
  <li><a href="#copy-and-swap-idiom" id="toc-copy-and-swap-idiom" class="nav-link" data-scroll-target="#copy-and-swap-idiom">Copy and swap idiom</a>
  <ul class="collapse">
  <li><a href="#why-does-it-work" id="toc-why-does-it-work" class="nav-link" data-scroll-target="#why-does-it-work">Why does it work?</a></li>
  </ul></li>
  <li><a href="#value-categories" id="toc-value-categories" class="nav-link" data-scroll-target="#value-categories">Value Categories</a></li>
  <li><a href="#moving-data" id="toc-moving-data" class="nav-link" data-scroll-target="#moving-data">Moving data</a>
  <ul class="collapse">
  <li><a href="#rvalue-references-in-detail" id="toc-rvalue-references-in-detail" class="nav-link" data-scroll-target="#rvalue-references-in-detail"><em>rvalue</em> references in detail</a></li>
  <li><a href="#rvalue-references-as-parameters" id="toc-rvalue-references-as-parameters" class="nav-link" data-scroll-target="#rvalue-references-as-parameters"><em>rvalue</em> references as parameters</a></li>
  </ul></li>
  <li><a href="#stdmove" id="toc-stdmove" class="nav-link" data-scroll-target="#stdmove"><code>std::move()</code></a>
  <ul class="collapse">
  <li><a href="#header-file-for-stdmove" id="toc-header-file-for-stdmove" class="nav-link" data-scroll-target="#header-file-for-stdmove">Header file for <code>std::move()</code></a></li>
  <li><a href="#implementation-of-stdmove" id="toc-implementation-of-stdmove" class="nav-link" data-scroll-target="#implementation-of-stdmove">Implementation of <code>std::move()</code></a></li>
  </ul></li>
  <li><a href="#moved-from-objects" id="toc-moved-from-objects" class="nav-link" data-scroll-target="#moved-from-objects">Moved-from objects</a>
  <ul class="collapse">
  <li><a href="#valid-but-unspecified-state" id="toc-valid-but-unspecified-state" class="nav-link" data-scroll-target="#valid-but-unspecified-state">Valid but unspecified state</a></li>
  <li><a href="#reusing-moved-from-objects" id="toc-reusing-moved-from-objects" class="nav-link" data-scroll-target="#reusing-moved-from-objects">Reusing moved-from objects</a></li>
  <li><a href="#move-assignments-of-objects-to-themselves" id="toc-move-assignments-of-objects-to-themselves" class="nav-link" data-scroll-target="#move-assignments-of-objects-to-themselves">Move assignments of objects to themselves</a></li>
  </ul></li>
  <li><a href="#the-canonical-move-constructor-and-move-assignment-operator" id="toc-the-canonical-move-constructor-and-move-assignment-operator" class="nav-link" data-scroll-target="#the-canonical-move-constructor-and-move-assignment-operator">The canonical move constructor and move assignment operator</a></li>
  <li><a href="#avoiding-unnecessary-stdmove" id="toc-avoiding-unnecessary-stdmove" class="nav-link" data-scroll-target="#avoiding-unnecessary-stdmove">Avoiding unnecessary <code>std::move()</code></a></li>
  <li><a href="#value-categories-in-detail" id="toc-value-categories-in-detail" class="nav-link" data-scroll-target="#value-categories-in-detail">Value categories in detail</a>
  <ul class="collapse">
  <li><a href="#value-categories-since-c11" id="toc-value-categories-since-c11" class="nav-link" data-scroll-target="#value-categories-since-c11">Value categories since C++11</a></li>
  <li><a href="#copy-elison-since-c17" id="toc-copy-elison-since-c17" class="nav-link" data-scroll-target="#copy-elison-since-c17">Copy Elison since C++17</a></li>
  <li><a href="#value-categories-since-c17" id="toc-value-categories-since-c17" class="nav-link" data-scroll-target="#value-categories-since-c17">Value Categories since C++17</a></li>
  </ul></li>
  <li><a href="#perfect-forwarding" id="toc-perfect-forwarding" class="nav-link" data-scroll-target="#perfect-forwarding">Perfect Forwarding</a>
  <ul class="collapse">
  <li><a href="#motivation-for-perfect-forwarding" id="toc-motivation-for-perfect-forwarding" class="nav-link" data-scroll-target="#motivation-for-perfect-forwarding">Motivation for perfect forwarding</a></li>
  <li><a href="#implementing-perfect-forwarding" id="toc-implementing-perfect-forwarding" class="nav-link" data-scroll-target="#implementing-perfect-forwarding">Implementing perfect forwarding</a></li>
  <li><a href="#universal-and-forwarding-references" id="toc-universal-and-forwarding-references" class="nav-link" data-scroll-target="#universal-and-forwarding-references">Universal and Forwarding references</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="motivation-for-move-semantics" class="level2">
<h2 class="anchored" data-anchor-id="motivation-for-move-semantics">Motivation for Move Semantics</h2>
<p>To understand the basic principles of move semantics, let’s look at the execution of a small piece of code. I’ve written a toy <code>Vector</code> class. I choose the manage the memory myself, so I will follow the <a href="https://en.wikipedia.org/wiki/Rule_of_three_%28C++_programming%29">rule of three</a>. I will supply a copy-constructor, copy-assignment operator and a destructor. I have also overloaded <code>operator+()</code> to support element-wise addition of two vectors.</p>
<section id="value-semantics" class="level3">
<h3 class="anchored" data-anchor-id="value-semantics">Value Semantics</h3>
<p>Assume that we have the following program:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">//basics/copy_semantics.cpp</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdexcept&gt;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;initializer_list&gt;</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Vector <span class="op">{</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="va">capacity_</span><span class="op">;</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="va">size_</span><span class="op">;</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    T<span class="op">*</span> <span class="va">ptr_</span><span class="op">;</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>    Vector<span class="op">()</span> <span class="op">:</span><span class="va">capacity_</span><span class="op">{</span> <span class="dv">0</span> <span class="op">},</span> <span class="va">size_</span><span class="op">{</span> <span class="dv">0</span> <span class="op">},</span> <span class="va">ptr_</span><span class="op">{</span> <span class="kw">nullptr</span> <span class="op">}</span> <span class="op">{}</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    Vector<span class="op">(</span><span class="dt">int</span> size<span class="op">)</span> <span class="op">:</span> <span class="va">capacity_</span><span class="op">{</span> size <span class="op">},</span> <span class="va">ptr_</span><span class="op">{</span> <span class="kw">new</span> T<span class="op">[</span>size<span class="op">]</span> <span class="op">},</span> <span class="va">size_</span><span class="op">{</span> size <span class="op">}</span> <span class="op">{}</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>    Vector<span class="op">(</span><span class="dt">int</span> size<span class="op">,</span> T data<span class="op">)</span> <span class="op">:</span> Vector<span class="op">(</span>size<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i<span class="op">{</span> <span class="dv">0</span> <span class="op">};</span> i <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>            <span class="va">ptr_</span><span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> data<span class="op">;</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>    Vector<span class="op">(</span><span class="bu">std::</span>initializer_list<span class="op">&lt;</span>T<span class="op">&gt;</span> list<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>        clear<span class="op">();</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="at">const</span> T<span class="op">&amp;</span> elem <span class="op">:</span> list<span class="op">)</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>            push_back<span class="op">(</span>elem<span class="op">);</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>    <span class="co">//Destructor</span></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>    <span class="op">~</span>Vector<span class="op">()</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>        clear<span class="op">();</span></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>    <span class="co">//Copy constructor</span></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>    Vector<span class="op">(</span><span class="at">const</span> Vector<span class="op">&amp;</span> v<span class="op">)</span></span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span><span class="kw">this</span> <span class="op">==</span> <span class="op">&amp;</span>v<span class="op">)</span></span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span><span class="op">;</span></span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a>        <span class="va">capacity_</span> <span class="op">=</span> v<span class="op">.</span><span class="va">capacity_</span><span class="op">;</span></span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>        <span class="va">size_</span> <span class="op">=</span> v<span class="op">.</span><span class="va">size_</span><span class="op">;</span></span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a>        <span class="va">ptr_</span> <span class="op">=</span> <span class="kw">new</span> T<span class="op">[</span>v<span class="op">.</span><span class="va">size_</span><span class="op">];</span></span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i<span class="op">{</span> <span class="dv">0</span> <span class="op">};</span> i <span class="op">&lt;</span> v<span class="op">.</span><span class="va">size_</span><span class="op">;</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a>            <span class="va">ptr_</span><span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> v<span class="op">.</span><span class="va">ptr_</span><span class="op">[</span>i<span class="op">];</span></span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a>    <span class="co">//Copy assignment operator</span></span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a>    Vector<span class="op">&lt;</span>T<span class="op">&gt;&amp;</span> <span class="kw">operator</span><span class="op">=(</span><span class="at">const</span> Vector<span class="op">&lt;</span>T<span class="op">&gt;&amp;</span> v<span class="op">)</span></span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span><span class="kw">this</span> <span class="op">!=</span> <span class="op">&amp;</span>v<span class="op">)</span></span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true" tabindex="-1"></a>            <span class="kw">delete</span><span class="op">[]</span> <span class="va">ptr_</span><span class="op">;</span></span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true" tabindex="-1"></a>            <span class="va">ptr_</span> <span class="op">=</span> <span class="kw">nullptr</span><span class="op">;</span></span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true" tabindex="-1"></a>            <span class="va">capacity_</span> <span class="op">=</span> v<span class="op">.</span><span class="va">capacity_</span><span class="op">;</span></span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true" tabindex="-1"></a>            <span class="va">size_</span> <span class="op">=</span> v<span class="op">.</span><span class="va">size_</span><span class="op">;</span></span>
<span id="cb1-58"><a href="#cb1-58" aria-hidden="true" tabindex="-1"></a>            <span class="va">ptr_</span> <span class="op">=</span> <span class="kw">new</span> T<span class="op">[</span><span class="va">capacity_</span><span class="op">];</span></span>
<span id="cb1-59"><a href="#cb1-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-60"><a href="#cb1-60" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i<span class="op">{</span> <span class="dv">0</span> <span class="op">};</span> i <span class="op">&lt;</span> v<span class="op">.</span><span class="va">size_</span><span class="op">;</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb1-61"><a href="#cb1-61" aria-hidden="true" tabindex="-1"></a>                <span class="va">ptr_</span><span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> v<span class="op">.</span><span class="va">ptr_</span><span class="op">[</span>i<span class="op">];</span></span>
<span id="cb1-62"><a href="#cb1-62" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-63"><a href="#cb1-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-64"><a href="#cb1-64" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">*</span><span class="kw">this</span><span class="op">;</span></span>
<span id="cb1-65"><a href="#cb1-65" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-66"><a href="#cb1-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-67"><a href="#cb1-67" aria-hidden="true" tabindex="-1"></a>    T<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">[](</span><span class="dt">int</span> i<span class="op">)</span></span>
<span id="cb1-68"><a href="#cb1-68" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb1-69"><a href="#cb1-69" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>i <span class="op">&gt;=</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> i <span class="op">&lt;</span> <span class="va">size_</span><span class="op">)</span></span>
<span id="cb1-70"><a href="#cb1-70" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">ptr_</span><span class="op">[</span>i<span class="op">];</span></span>
<span id="cb1-71"><a href="#cb1-71" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span></span>
<span id="cb1-72"><a href="#cb1-72" aria-hidden="true" tabindex="-1"></a>            <span class="cf">throw</span> <span class="bu">std::</span>out_of_range<span class="op">(</span><span class="st">"Index out of bounds."</span><span class="op">);</span></span>
<span id="cb1-73"><a href="#cb1-73" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-74"><a href="#cb1-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-75"><a href="#cb1-75" aria-hidden="true" tabindex="-1"></a>    T<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">[](</span><span class="dt">int</span> i<span class="op">)</span> <span class="at">const</span></span>
<span id="cb1-76"><a href="#cb1-76" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb1-77"><a href="#cb1-77" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>i <span class="op">&gt;=</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> i <span class="op">&lt;</span> <span class="va">size_</span><span class="op">)</span></span>
<span id="cb1-78"><a href="#cb1-78" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">ptr_</span><span class="op">[</span>i<span class="op">];</span></span>
<span id="cb1-79"><a href="#cb1-79" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span></span>
<span id="cb1-80"><a href="#cb1-80" aria-hidden="true" tabindex="-1"></a>            <span class="cf">throw</span> <span class="bu">std::</span>out_of_range<span class="op">(</span><span class="st">"Index out of bounds."</span><span class="op">);</span></span>
<span id="cb1-81"><a href="#cb1-81" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-82"><a href="#cb1-82" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-83"><a href="#cb1-83" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> reserve<span class="op">(</span><span class="dt">int</span> size<span class="op">)</span></span>
<span id="cb1-84"><a href="#cb1-84" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb1-85"><a href="#cb1-85" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span><span class="va">size_</span> <span class="op">&lt;</span> <span class="va">capacity_</span><span class="op">)</span> <span class="cf">return</span><span class="op">;</span></span>
<span id="cb1-86"><a href="#cb1-86" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-87"><a href="#cb1-87" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span><span class="va">ptr_</span> <span class="op">==</span> <span class="kw">nullptr</span><span class="op">)</span></span>
<span id="cb1-88"><a href="#cb1-88" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb1-89"><a href="#cb1-89" aria-hidden="true" tabindex="-1"></a>            <span class="va">size_</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-90"><a href="#cb1-90" aria-hidden="true" tabindex="-1"></a>            <span class="va">capacity_</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-91"><a href="#cb1-91" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-92"><a href="#cb1-92" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-93"><a href="#cb1-93" aria-hidden="true" tabindex="-1"></a>        T<span class="op">*</span> bufferNew <span class="op">=</span> <span class="kw">new</span> T<span class="op">[</span>size<span class="op">];</span></span>
<span id="cb1-94"><a href="#cb1-94" aria-hidden="true" tabindex="-1"></a>        <span class="dt">unsigned</span> <span class="dt">int</span> l_size <span class="op">=</span> <span class="bu">std::</span>min<span class="op">(</span><span class="va">capacity_</span><span class="op">,</span> size<span class="op">);</span></span>
<span id="cb1-95"><a href="#cb1-95" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i<span class="op">{</span> <span class="dv">0</span> <span class="op">};</span> i <span class="op">&lt;</span> l_size<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb1-96"><a href="#cb1-96" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb1-97"><a href="#cb1-97" aria-hidden="true" tabindex="-1"></a>            bufferNew<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="va">ptr_</span><span class="op">[</span>i<span class="op">];</span></span>
<span id="cb1-98"><a href="#cb1-98" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-99"><a href="#cb1-99" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-100"><a href="#cb1-100" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span><span class="va">ptr_</span> <span class="op">!=</span> <span class="kw">nullptr</span><span class="op">)</span></span>
<span id="cb1-101"><a href="#cb1-101" aria-hidden="true" tabindex="-1"></a>            <span class="kw">delete</span><span class="op">[]</span> <span class="va">ptr_</span><span class="op">;</span></span>
<span id="cb1-102"><a href="#cb1-102" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-103"><a href="#cb1-103" aria-hidden="true" tabindex="-1"></a>        <span class="va">ptr_</span> <span class="op">=</span> bufferNew<span class="op">;</span></span>
<span id="cb1-104"><a href="#cb1-104" aria-hidden="true" tabindex="-1"></a>        <span class="va">capacity_</span> <span class="op">=</span> size<span class="op">;</span></span>
<span id="cb1-105"><a href="#cb1-105" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-106"><a href="#cb1-106" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-107"><a href="#cb1-107" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> clear<span class="op">()</span></span>
<span id="cb1-108"><a href="#cb1-108" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb1-109"><a href="#cb1-109" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span><span class="va">ptr_</span> <span class="op">!=</span> <span class="kw">nullptr</span><span class="op">)</span></span>
<span id="cb1-110"><a href="#cb1-110" aria-hidden="true" tabindex="-1"></a>            <span class="kw">delete</span><span class="op">[]</span> <span class="va">ptr_</span><span class="op">;</span></span>
<span id="cb1-111"><a href="#cb1-111" aria-hidden="true" tabindex="-1"></a>        <span class="va">ptr_</span> <span class="op">=</span> <span class="kw">nullptr</span><span class="op">;</span></span>
<span id="cb1-112"><a href="#cb1-112" aria-hidden="true" tabindex="-1"></a>        <span class="va">size_</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-113"><a href="#cb1-113" aria-hidden="true" tabindex="-1"></a>        <span class="va">capacity_</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-114"><a href="#cb1-114" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-115"><a href="#cb1-115" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-116"><a href="#cb1-116" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> size<span class="op">()</span> <span class="at">const</span></span>
<span id="cb1-117"><a href="#cb1-117" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb1-118"><a href="#cb1-118" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">size_</span><span class="op">;</span></span>
<span id="cb1-119"><a href="#cb1-119" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-120"><a href="#cb1-120" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-121"><a href="#cb1-121" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> capacity<span class="op">()</span></span>
<span id="cb1-122"><a href="#cb1-122" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb1-123"><a href="#cb1-123" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">capacity_</span><span class="op">;</span></span>
<span id="cb1-124"><a href="#cb1-124" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-125"><a href="#cb1-125" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-126"><a href="#cb1-126" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> push_back<span class="op">(</span><span class="at">const</span> T<span class="op">&amp;</span> elem<span class="op">)</span></span>
<span id="cb1-127"><a href="#cb1-127" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb1-128"><a href="#cb1-128" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span><span class="va">size_</span> <span class="op">&gt;=</span> <span class="va">capacity_</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-129"><a href="#cb1-129" aria-hidden="true" tabindex="-1"></a>            reserve<span class="op">(</span><span class="va">capacity_</span> <span class="op">+</span> <span class="dv">5</span><span class="op">);</span> <span class="co">// Double the capacity</span></span>
<span id="cb1-130"><a href="#cb1-130" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-131"><a href="#cb1-131" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-132"><a href="#cb1-132" aria-hidden="true" tabindex="-1"></a>        <span class="va">ptr_</span><span class="op">[</span><span class="va">size_</span><span class="op">++]</span> <span class="op">=</span> elem<span class="op">;</span></span>
<span id="cb1-133"><a href="#cb1-133" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-134"><a href="#cb1-134" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-135"><a href="#cb1-135" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> pop_back<span class="op">()</span></span>
<span id="cb1-136"><a href="#cb1-136" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb1-137"><a href="#cb1-137" aria-hidden="true" tabindex="-1"></a>        <span class="op">--</span><span class="va">size_</span><span class="op">;</span></span>
<span id="cb1-138"><a href="#cb1-138" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-139"><a href="#cb1-139" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-140"><a href="#cb1-140" aria-hidden="true" tabindex="-1"></a>    T front<span class="op">()</span></span>
<span id="cb1-141"><a href="#cb1-141" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb1-142"><a href="#cb1-142" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span><span class="va">size_</span> <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb1-143"><a href="#cb1-143" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">ptr_</span><span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb1-144"><a href="#cb1-144" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span></span>
<span id="cb1-145"><a href="#cb1-145" aria-hidden="true" tabindex="-1"></a>            <span class="cf">throw</span> <span class="bu">std::</span>out_of_range<span class="op">(</span><span class="st">"Index out of bounds."</span><span class="op">);</span></span>
<span id="cb1-146"><a href="#cb1-146" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-147"><a href="#cb1-147" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-148"><a href="#cb1-148" aria-hidden="true" tabindex="-1"></a>    T back<span class="op">()</span></span>
<span id="cb1-149"><a href="#cb1-149" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb1-150"><a href="#cb1-150" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span><span class="va">size_</span> <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb1-151"><a href="#cb1-151" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">ptr_</span><span class="op">[</span><span class="va">size_</span> <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb1-152"><a href="#cb1-152" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span></span>
<span id="cb1-153"><a href="#cb1-153" aria-hidden="true" tabindex="-1"></a>            <span class="cf">throw</span> <span class="bu">std::</span>out_of_range<span class="op">(</span><span class="st">"Index out of bounds."</span><span class="op">);</span></span>
<span id="cb1-154"><a href="#cb1-154" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-155"><a href="#cb1-155" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-156"><a href="#cb1-156" aria-hidden="true" tabindex="-1"></a>    T<span class="op">*</span> getRawPointer<span class="op">()</span></span>
<span id="cb1-157"><a href="#cb1-157" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb1-158"><a href="#cb1-158" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">ptr_</span><span class="op">;</span></span>
<span id="cb1-159"><a href="#cb1-159" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-160"><a href="#cb1-160" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb1-161"><a href="#cb1-161" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-162"><a href="#cb1-162" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb1-163"><a href="#cb1-163" aria-hidden="true" tabindex="-1"></a>Vector<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="kw">operator</span><span class="op">+(</span><span class="at">const</span> Vector<span class="op">&lt;</span>T<span class="op">&gt;&amp;</span> v1<span class="op">,</span> <span class="at">const</span> Vector<span class="op">&lt;</span>T<span class="op">&gt;&amp;</span> v2<span class="op">)</span></span>
<span id="cb1-164"><a href="#cb1-164" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb1-165"><a href="#cb1-165" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>v1<span class="op">.</span>size<span class="op">()</span> <span class="op">!=</span> v2<span class="op">.</span>size<span class="op">())</span></span>
<span id="cb1-166"><a href="#cb1-166" aria-hidden="true" tabindex="-1"></a>        <span class="cf">throw</span> <span class="bu">std::</span>logic_error<span class="op">(</span><span class="st">"Vector lengths must be equal."</span><span class="op">);</span></span>
<span id="cb1-167"><a href="#cb1-167" aria-hidden="true" tabindex="-1"></a>    Vector<span class="op">&lt;</span>T<span class="op">&gt;</span> result<span class="op">;</span></span>
<span id="cb1-168"><a href="#cb1-168" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i<span class="op">{</span> <span class="dv">0</span> <span class="op">};</span> i <span class="op">&lt;</span> v1<span class="op">.</span>size<span class="op">();</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb1-169"><a href="#cb1-169" aria-hidden="true" tabindex="-1"></a>        result<span class="op">.</span>push_back<span class="op">(</span>v1<span class="op">[</span>i<span class="op">]</span> <span class="op">+</span> v2<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb1-170"><a href="#cb1-170" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-171"><a href="#cb1-171" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result<span class="op">;</span></span>
<span id="cb1-172"><a href="#cb1-172" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-173"><a href="#cb1-173" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-174"><a href="#cb1-174" aria-hidden="true" tabindex="-1"></a>Vector<span class="op">&lt;</span>Vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;</span> createAndInsert<span class="op">()</span></span>
<span id="cb1-175"><a href="#cb1-175" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb1-176"><a href="#cb1-176" aria-hidden="true" tabindex="-1"></a>    Vector<span class="op">&lt;</span>Vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;</span> pts<span class="op">;</span></span>
<span id="cb1-177"><a href="#cb1-177" aria-hidden="true" tabindex="-1"></a>    pts<span class="op">.</span>reserve<span class="op">(</span><span class="dv">3</span><span class="op">);</span></span>
<span id="cb1-178"><a href="#cb1-178" aria-hidden="true" tabindex="-1"></a>    Vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> x<span class="op">{</span> <span class="fl">1.0</span><span class="op">,</span> <span class="fl">1.0</span> <span class="op">};</span></span>
<span id="cb1-179"><a href="#cb1-179" aria-hidden="true" tabindex="-1"></a>    pts<span class="op">.</span>push_back<span class="op">(</span>x<span class="op">);</span></span>
<span id="cb1-180"><a href="#cb1-180" aria-hidden="true" tabindex="-1"></a>    pts<span class="op">.</span>push_back<span class="op">(</span>x <span class="op">+</span> x<span class="op">);</span></span>
<span id="cb1-181"><a href="#cb1-181" aria-hidden="true" tabindex="-1"></a>    pts<span class="op">.</span>push_back<span class="op">(</span>x<span class="op">);</span></span>
<span id="cb1-182"><a href="#cb1-182" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> pts<span class="op">;</span></span>
<span id="cb1-183"><a href="#cb1-183" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-184"><a href="#cb1-184" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-185"><a href="#cb1-185" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb1-186"><a href="#cb1-186" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb1-187"><a href="#cb1-187" aria-hidden="true" tabindex="-1"></a>    Vector<span class="op">&lt;</span>Vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;</span> result <span class="op">=</span> createAndInsert<span class="op">();</span></span>
<span id="cb1-188"><a href="#cb1-188" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-189"><a href="#cb1-189" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><a href="https://godbolt.org/z/hEMKd99s5">Compiler Explorer</a></p>
<p>Let us look at the individual steps of the program (inspecting both stack and the heap) when we compile this program with a C++ compiler.</p>
<p>First in <code>main</code>, we create the empty vector <code>pts</code> which will be used to store points in the euclidean space <span class="math inline">\(\mathbf{R}^2\)</span>:</p>
<pre><code>Vector&lt;Vector&lt;double&gt;&gt; pts;</code></pre>
<p>which is placed on the stack as an object that has <code>size_ = 0</code>, <code>capacity_ = 0</code> and no memory allocated for elements.</p>
<p>Then, we call</p>
<pre><code>pts.reserve(3);</code></pre>
<p>This allocates memory for <code>3</code> elements on the heap. The member <code>pts_-&gt;capacity_</code> equals <code>3</code>, <code>pts-&gt;size_</code> equals <code>0</code> and <code>pts_-&gt;ptr_</code> contains the address to heap block. The allocated memory is not initialized, because the number of elements is still <code>0</code>.</p>
<p>Then, we create a <span class="math inline">\(2\)</span>-tuple to hold the cartesian coordinates of a point <span class="math inline">\((1.0,1.0)\)</span>. We create a <code>Vector&lt;double&gt;</code> initialized to <code>{1.0,1.0}</code>. Essentially, we create an object <code>x</code> on the stack with its members <code>x-&gt;size_ = 2</code>, <code>x-&gt;capacity_ = 5</code> and a pointer <code>x-&gt;ptr_</code> containing the address of newly allocated memory on the heap for <code>5</code> elements. Further, <code>x-&gt;ptr_[0]=1.0</code>, <code>x-&gt;ptr_[1]=1.0</code>.</p>
<pre><code>Vector&lt;double&gt; x{1.0, 1.0};</code></pre>
<p>After this statement, the program has the following state: we have two objects on the stack : <code>pts</code> and <code>x</code>. Both of them have memory allocated on the heap.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="move_semantics_00.png" class="img-fluid figure-img"></p>
<figcaption>Checkpoint #1</figcaption>
</figure>
</div>
<p>The next step is the command to insert <code>x</code> into the <code>pts</code> vector.</p>
<pre><code>pts.push_back(x);</code></pre>
<p>My toy <code>Vector</code> class is said to have value semantics, which means it creates copies of the values passed to it. As a result, we get a first element in the vector, which is a full(deep) copy of the passed value/object <code>x</code>:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="move_semantics_01.png" class="img-fluid figure-img"></p>
<figcaption>Checkpoint #2</figcaption>
</figure>
</div>
<p>The current state is that we have a vector <code>pts</code> and two copies of <code>x={1.0,1.0}</code>, one of which is the first element in <code>pts</code>.</p>
<p>Let’s now look at the next statement, which creates a new temporary vector and again inserts it into the <code>pts</code> vector:</p>
<pre><code>pts.push_back(x + x);</code></pre>
<p>This statement is performed in three steps:</p>
<p><em>Step 1</em>. We create a temporary <code>Vector&lt;double&gt;</code> object <code>x + x</code>.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="move_semantics_02.png" class="img-fluid figure-img"></p>
<figcaption>Step #1</figcaption>
</figure>
</div>
<p><em>Step 2</em>. <code>x+x</code> is a temporary. The <code>Vector&lt;T&gt;::push_back(const T&amp;)</code> function accepts a reference-to-<code>const</code> as an argument. Since <code>x+x</code> is a temporary, it cannot be modified and binds to a reference-to-<code>const</code>. Moreover, being a temporary object, it is likely to die soon. Referencing it extends the lifetime of the temporary <code>x + x={2.0,2.0}</code>.</p>
<p>Now, the statement <code>pts_[size++] = elem</code> will invoke the copy-assignment operator on the yet uninitialized second element <code>pts[1]</code> which is of type <code>Vector&lt;double&gt;</code>. This will force a full (deep) copy of <code>x + x={2.0,2.0}</code>. At this time, two copies of <code>{2.0,2.0}</code> exist on the heap. One of these is assigned to <code>pts[1]</code>.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="move_semantics_03.png" class="img-fluid figure-img"></p>
<figcaption>Step #2</figcaption>
</figure>
</div>
<p><em>Step 3</em>. When <code>push_back(const T&amp;)</code> returns, the temporary <code>x + x</code> will die and its destructor is called and the memory allocated on the heap is freed. You can see this on <a href="https://cppinsights.io/s/3f814c34">cppinsights</a>.</p>
<p>Our code is clearly not performing well: we create a copy of the temporary <code>x + x</code> and destroy the source of the copy immediately afterwards, which means we unnecessarily allocate and free memory that we could have just moved from source to the copy.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="move_semantics_04.png" class="img-fluid figure-img"></p>
<figcaption>Step #3</figcaption>
</figure>
</div>
<p>With the next statement, again we insert <code>x</code> into <code>pts</code>:</p>
<pre><code>pts.push_back(x)</code></pre>
<p>Again, <code>pts</code> copies <code>x</code>.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="move_semantics_05.png" class="img-fluid figure-img"></p>
<figcaption>Checkpoint #3</figcaption>
</figure>
</div>
<p>This is also something to improve. Because the value of <code>x</code> is no longer needed, some optimization could use the memory of <code>x</code> as the memory for the new element instead.</p>
<p>At the end of <code>createAndInsert()</code> we come to the return statement:</p>
<pre><code>return pts;</code></pre>
<p>Here, the behaviour of the program is a bit more complicated. We return by value (the return type is not a reference), which should be a copy of the value in the <code>return</code> statement. Creating a copy of <code>pts</code> means that we have create a deep copy of the whole vector with all of its elements. Thus, we have to allocate heap memory for the array of elements in the <code>pts</code> and heap memory for the value of each 2-tuple. Here, we would have to allocate memory 4 times.</p>
<p>However, since at the same time <code>pts</code> is destroyed because we leave the scope where it is declared, the compiler is allowed to perform <em>named return value optimization (NRVO)</em>. This means that the compiler can generate code so that <code>pts</code> is used as the return value.</p>
<p>Let us assume that we have the named return value optimization. In that case, at the end of the <code>return</code> statement, <code>pts</code> simply becomes the return value and the destructor of <code>x</code> is called, which frees the memory allocated when it was declared.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="move_semantics_06.png" class="img-fluid figure-img"></p>
<figcaption>Return statement</figcaption>
</figure>
</div>
<p>Finally, we come to the assignment of the return value to <code>result</code>:</p>
<pre><code>result = createAndInsert()</code></pre>
<p>Here, we really get behavior that can be improved: the usual assignment operator has the goal of giving <code>result</code> the same value as the source value that is assigned. In general, any source(assigned) value should not be modified and should independent from the object that the value was assigned to. So, the assignment operator will create a deep-copy of the whole return value:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="move_semantics_07.png" class="img-fluid figure-img"></p>
<figcaption>Return statement</figcaption>
</figure>
</div>
<p>However, right after that we no longer need the temporary return value and we destroy it:</p>
<p>Again, we create a copy of a temporary object and destroy the source of the copy immediately afterwards, which means that we again unnecessarily allocate and free memory. This time it applies to four allocations</p>
<p>For the state of the program after this assignment in <code>main()</code>, we allocated memory numerous times and released it. Unnecessary memory allocations were caused by:</p>
<ul>
<li>Inserting a temporary object into <code>pts</code>.</li>
<li>Inserting an object into <code>pts</code> where we no longer need the value.</li>
<li>Assigning a temporary vector with all its elements.</li>
</ul>
<p>We can more or less avoid these performance pennalties.</p>
</section>
</section>
<section id="copy-elison" class="level2">
<h2 class="anchored" data-anchor-id="copy-elison">Copy elison</h2>
<p>Copy-elison is based on the fact that the compiler is allowed to follow the <a href="https://en.cppreference.com/w/cpp/language/as_if">as-if</a> rule. The compiler is allowed to generate any code which has the same effect as the code you told it to add. The standard actually says, that if the compiler is told to copy something, but the copy is not really necessary, because the original is not going to be used again, then the compiler is allowed to elide(omit) the copy. The compiler is allowed to elide copies, where the results are <em>as-if</em> copies were made.</p>
<p>Consider the function below:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cmath&gt;</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> discountFactor<span class="op">(</span><span class="dt">double</span> r<span class="op">,</span> <span class="dt">double</span> t<span class="op">){</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> result <span class="op">=</span> exp<span class="op">(-</span>r <span class="op">*</span> t<span class="op">);</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result<span class="op">;</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> df <span class="op">{</span>discountFactor<span class="op">(</span><span class="fl">0.05</span><span class="op">,</span> <span class="fl">1.00</span><span class="op">)};</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>How many parameters are passed to the function <code>discountFactor(double, double)</code>? C++ programmers answer <span class="math inline">\(2\)</span>, assembly-language programmers answer <span class="math inline">\(3\)</span>. Why? At a low-level, when we have a return-value, we have to tell the generated code, where to put the return value. The function is passed the address where the results should be written.</p>
<p>Alright, so this is what’s going on. Our function <code>main()</code> is going to call <code>discountFactor(double, double)</code> in order to populate a local <code>df</code>. The stack frame for the function <code>main()</code> looks like this:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="move_semantics_08.png" class="img-fluid figure-img"></p>
<figcaption>Stack frame for main()</figcaption>
</figure>
</div>
<p>Now, we are going to call the function <code>discountFactor(double, double)</code>. When we call <code>discountFactor(double, double)</code>, we have to create the stack-frame for <code>discountFactor(double, double)</code>.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="move_semantics_09.png" class="img-fluid figure-img"></p>
<figcaption>Call to discountFactor()</figcaption>
</figure>
</div>
<p>Okay, now we execute the function <code>discountFactor(double, double)</code> and now the return value is now stored directly at the address given by <code>&amp;df</code>.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="move_semantics_10.png" class="img-fluid figure-img"></p>
<figcaption>Return statement</figcaption>
</figure>
</div>
<p>So, this is going to elide the copy. This form of copy elison is called <em>Return Value Optimization</em>(RVO). The calling function allocates space for the return value on the stack, and passes the address of that memory to the callee. The callee can then construct a return value directly into that space, which eliminates the need to copy from the inside to the outside.</p>
<p>Also, although the compiler is normally required to make a copy when a function parameter is passed by value (so modifications to the parameter inside the function can’t affect the caller), it is allowed to elide the copy, when the source is a temporary.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f<span class="op">(</span><span class="bu">std::</span>string a<span class="op">)</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> b<span class="op">{</span><span class="dv">123</span><span class="op">};</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">//some code</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span><span class="op">;</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> g<span class="op">()</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>    f<span class="op">(</span><span class="bu">std::</span>string<span class="op">(</span><span class="st">"A"</span><span class="op">));</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> y<span class="op">;</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This is how it actually works. We are going to create our temporary - the string <code>"A"</code> in the place, where we would have actually copied it, that is, in the local variable <code>a</code> in the stack frame of <code>f(std::string)</code>.</p>
</section>
<section id="copy-and-swap-idiom" class="level2">
<h2 class="anchored" data-anchor-id="copy-and-swap-idiom">Copy and swap idiom</h2>
<p>Any class which manages resources (a wrapper like a <em>smart pointer</em>) needs to implement <a href="https://stackoverflow.com/questions/4172722/what-is-the-rule-of-three">The Big Three</a>. While the goals of the copy constructor and destructor are straightforward, the copy-assignment operator is arguably the most nuanced and difficult. What pitfalls need to be avoided?</p>
<p>Consider our naive implementation of the assignment operator:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co">//Copy assignment operator</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>Vector<span class="op">&lt;</span>T<span class="op">&gt;&amp;</span> <span class="kw">operator</span><span class="op">=(</span><span class="at">const</span> Vector<span class="op">&lt;</span>T<span class="op">&gt;&amp;</span> v<span class="op">)</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span><span class="kw">this</span> <span class="op">!=</span> <span class="op">&amp;</span>v<span class="op">)</span>     <span class="co">//(1)</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">delete</span><span class="op">[]</span> <span class="va">ptr_</span><span class="op">;</span>  <span class="co">//(2)</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>        <span class="va">ptr_</span> <span class="op">=</span> <span class="kw">nullptr</span><span class="op">;</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>        <span class="va">capacity_</span> <span class="op">=</span> v<span class="op">.</span><span class="va">capacity_</span><span class="op">;</span>    <span class="co">//(2)</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>        <span class="va">size_</span> <span class="op">=</span> v<span class="op">.</span><span class="va">size_</span><span class="op">;</span>            <span class="co">//(2)</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>        <span class="va">ptr_</span> <span class="op">=</span> <span class="kw">new</span> T<span class="op">[</span><span class="va">capacity_</span><span class="op">];</span>    <span class="co">//(2)</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i<span class="op">{</span> <span class="dv">0</span> <span class="op">};</span> i <span class="op">&lt;</span> v<span class="op">.</span><span class="va">size_</span><span class="op">;</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>            <span class="va">ptr_</span><span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> v<span class="op">.</span><span class="va">ptr_</span><span class="op">[</span>i<span class="op">];</span>                <span class="co">//(3)</span></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">*</span><span class="kw">this</span><span class="op">;</span></span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>While this manages the heap memory without leaks, it suffers from three problems, marked sequentially in the code as <code>(n)</code>.</p>
<ol type="1">
<li>The first is the self-assignment test. This check is an easy way to prevent us from running needless code on self-assignment. But, in all other cases, it merely serves to slow down the program and acts as noise in the code; self-assignment rarely occurs, so most of the time this check is a waste.</li>
<li>The seond is, it only provides a basic exception guarantee. If <code>new T[capacity_]</code> fails, <code>*this</code> will have been modified. Namely, the <code>size_</code> and <code>capacity_</code> are wrong and the old data referenced by <code>ptr_</code> is gone! For a strong exception guarantee, we need something akin to:</li>
</ol>
<div class="sourceCode" id="cb13"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co">//Copy assignment operator</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>Vector<span class="op">&lt;</span>T<span class="op">&gt;&amp;</span> <span class="kw">operator</span><span class="op">=(</span><span class="at">const</span> Vector<span class="op">&lt;</span>T<span class="op">&gt;&amp;</span> v<span class="op">)</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span><span class="kw">this</span> <span class="op">!=</span> <span class="op">&amp;</span>v<span class="op">)</span>     <span class="co">//(1)</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">// get the new data ready, before we replace the old data</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> newCapacity <span class="op">=</span> v<span class="op">.</span><span class="va">capacity_</span><span class="op">;</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> newSize <span class="op">=</span> v<span class="op">.</span><span class="va">size_</span><span class="op">;</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>        T<span class="op">*</span> <span class="va">newPtr_</span> <span class="op">=</span> <span class="kw">new</span> T<span class="op">[</span>newCapacity<span class="op">]();</span>  <span class="co">//(2)</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i<span class="op">{</span> <span class="dv">0</span> <span class="op">};</span> i <span class="op">&lt;</span> v<span class="op">.</span><span class="va">size_</span><span class="op">;</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>            <span class="va">newPtr_</span><span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> v<span class="op">.</span><span class="va">ptr_</span><span class="op">[</span>i<span class="op">];</span>         <span class="co">//(3)</span></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>        <span class="co">//replace the old data (all are non-throwing)</span></span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>        <span class="kw">delete</span><span class="op">[]</span> <span class="va">ptr_</span><span class="op">;</span></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a>        <span class="va">size_</span> <span class="op">=</span> newSize<span class="op">;</span>       </span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a>        <span class="va">capacity_</span> <span class="op">=</span> <span class="va">newCapacity_</span><span class="op">;</span>           </span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a>        <span class="va">ptr_</span> <span class="op">=</span> newPtr<span class="op">;</span>                      </span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">*</span><span class="kw">this</span><span class="op">;</span></span>
<span id="cb13-22"><a href="#cb13-22" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ol start="3" type="1">
<li>Our code has expanded! This leads us to the third problem: code duplication.</li>
</ol>
<p>In our case, the core of it is only two lines (the allocation and the copy), but with more complex resources, this code bloat can be quite a hassle. What if my class manages more than one resource?</p>
<p>The <em>copy-and-swap</em> idiom is the solution, and elegantly assists the assignment operator in achieving two things: avoiding code duplication and providing a strong exception guarantee.</p>
<p>While, the <em>rule-of-three</em> successfully entails our copy-constructor, assignment and destructor, it should really be called <em>The Big Three and A Half</em>: any time your class manages a resource, it also makes sense to provide a <code>swap</code> function.</p>
<p>A swap function is a <em>non-throwing</em> function that swaps two objects of a class member-for-member.</p>
<p>We need to add <code>swap</code> functionality to our class, and we do that as follows:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> swap<span class="op">(</span>Vector<span class="op">&amp;</span> other<span class="op">)</span> <span class="kw">noexcept</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>swap<span class="op">(</span><span class="va">size_</span><span class="op">,</span> other<span class="op">.</span><span class="va">size_</span><span class="op">);</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>swap<span class="op">(</span><span class="va">capacity_</span><span class="op">,</span>other<span class="op">.</span><span class="va">capacity_</span><span class="op">);</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>swap<span class="op">(</span><span class="va">ptr_</span><span class="op">,</span> other<span class="op">.</span><span class="va">ptr_</span><span class="op">);</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a><span class="kw">friend</span> <span class="dt">void</span> swap<span class="op">(</span>Vector<span class="op">&amp;</span> lhs<span class="op">,</span> Vector<span class="op">&amp;</span> rhs<span class="op">)</span> <span class="kw">noexcept</span><span class="op">{</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>swap<span class="op">(</span>lhs<span class="op">.</span><span class="va">size_</span><span class="op">,</span> rhs<span class="op">.</span><span class="va">size_</span><span class="op">);</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>swap<span class="op">(</span>lhs<span class="op">.</span><span class="va">capacity_</span><span class="op">,</span> rhs<span class="op">.</span><span class="va">capacity_</span><span class="op">);</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>swap<span class="op">(</span>lhs<span class="op">.</span><span class="va">ptr_</span><span class="op">,</span> rhs<span class="op">.</span><span class="va">ptr_</span><span class="op">);</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Now, this is extremely efficient, it merely swaps pointers and sizes rather than allocating and copying entire arrays. We are now ready to implement the copy-and-swap idiom.</p>
<p>Our assignment operator is:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>Vector<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">=(</span>Vector other<span class="op">)</span> </span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>swap<span class="op">(*</span><span class="kw">this</span><span class="op">,</span> other<span class="op">);</span>    <span class="co">//(2)</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">*</span><span class="kw">this</span><span class="op">;</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<section id="why-does-it-work" class="level3">
<h3 class="anchored" data-anchor-id="why-does-it-work">Why does it work?</h3>
<p>We first notice an important choice : the parameter argument is taken <em>by-value</em>. While one could just as easily do the following(and indeed many naive implementations of the idiom do):</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>Vector<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">=(</span><span class="at">const</span> Vector<span class="op">&amp;</span> other<span class="op">)</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    Vector temp <span class="op">{</span>other<span class="op">};</span> </span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>swap<span class="op">(*</span><span class="kw">this</span><span class="op">,</span> temp<span class="op">);</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">*</span><span class="kw">this</span><span class="op">;</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We lose an important optimization opportunity - if a temporary is passed, the compiler will not perform copy elison. Not only that, but this choice is critical in C++ 11, which is discussed later. (On a general note, a remarkably useful guideline is as follows: if you’re going to make a copy of something in a function, let the compiler do it in the parameter list).</p>
<p>Either way, this method of obtaining our resource is key to eliminating code duplication: we get to use the code from the copy-constructor to make the copy, and never need to repeat any bit of it. Now that, the copy is made, we are ready to swap.</p>
<p>Observe that upon entering the function, the new data is already allocated, copied and ready to be used. This is what gives us a strong exception guarantee: we won’t even enter the function if the construction of the copy fails, and therefore it’s not possible to alter the state of <code>*this</code>. The assignment operator guarantees that the operations call will be fully rolled back in case of an error, as if the error never happened.</p>
<p>Conceptually, it works by using the copy-constructor’s functionality to create a local copy of the data, then takes the copied data with a <code>swap()</code> function swapping the old data with the new data.</p>
<p>To summarize: in order to use the copy-and-swap idiom, we need three things: a working copy-constructor, working destructor (both are the basis of any wrapper, so should be complete anyway), and a <code>swap</code> function.</p>
</section>
</section>
<section id="value-categories" class="level2">
<h2 class="anchored" data-anchor-id="value-categories">Value Categories</h2>
<p>In C++, every expression is either an <em>lvalue</em> or an <em>rvalue</em>. Consider an object that owns some resources(file-descriptors, sockets, memory buffer).</p>
<ul>
<li><p>An <em>lvalue</em> denotes an object whose resources cannot be reused. The object is an <em>lvalue</em>, if you can’t take the guts(resources) out of this object and donate it to someone else. <em>lvalue</em>s include expressions that designate objects by their name. For example, in the expression <code>double y = f(x)</code>, <code>y</code> is an <em>lvalue</em>. Moreover, <em>lvalue</em>s have persistent storage and an identifiable memory address. For instance, if I declare <code>std::vector&lt;double&gt; v{1.0,2.0,3.0,4.0,5.0};</code>, then <code>v[0]</code> is an <em>lvalue</em>.</p></li>
<li><p>An <em>rvalue</em> denotes an object whose resources can be reused. The object is an <em>rvalue</em>, if you can take the guts(resources) out of it and donate it to another object. <em>rvalue</em>s typically include temporary objects as they can’t manipulated at the place they are created and are likely to be destroyed soon. For instance, if declare <code>int x = 5;</code>, <code>5</code> is an <em>rvalue</em>. Moreover, in the statement <code>double y = f(x);</code>, the expression <code>f(x)</code> is an <em>rvalue</em>.</p></li>
</ul>
</section>
<section id="moving-data" class="level2">
<h2 class="anchored" data-anchor-id="moving-data">Moving data</h2>
<p>As seen earlier, C++ sometimes performs unnecessary copying.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>Vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> x<span class="op">;</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> Vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;({</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>        <span class="fl">1.0</span><span class="op">,</span> <span class="fl">2.0</span><span class="op">,</span> <span class="fl">3.0</span><span class="op">,</span> <span class="fl">4.0</span><span class="op">,</span> <span class="fl">5.0</span><span class="op">,</span> </span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>        <span class="fl">6.0</span><span class="op">,</span> <span class="fl">7.0</span><span class="op">,</span> <span class="fl">8.0</span><span class="op">,</span> <span class="fl">9.0</span><span class="op">,</span> <span class="fl">10.0</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">});</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><a href="https://cppinsights.io/s/230e7f56">cppinsights</a> produces the following annotations:</p>
<pre><code>Vector&lt;double&gt; x = Vector&lt;double&gt;();
const double __temporary179_5[10] = {
    1.0, 2.0, 3.0, 4.0, 5.0, 
    6.0, 7.0, 8.0, 9.0, 10.0
};
const Vector&lt;double&gt; __temporary179_6 = Vector&lt;double&gt;(Vector&lt;double&gt;(std::initializer_list&lt;double&gt;{__temporary179_5, 10}));
x.operator=(__temporary179_6);
__temporary179_6.~Vector();
/* __temporary179_5 // lifetime ends here */</code></pre>
<p>In the above code snippet, the temporary vector of reals <span class="math inline">\(\{1.0,2.0,3.0,\ldots,10.0\}\)</span> is copied element-wise to <code>x</code> and then destroyed immediately after. We’ve wasted a lot of energy in deep-copying.</p>
<p>Similarly, appending to a full vector causes much copying before the append. That is not what we want to do.</p>
<p>What we really want to do is, transfer the contents of <code>__temporary19_6</code> vector to <code>x</code> in a very simple way. Firstly, we copy the pointers; we cannot stop there, because at this point there are two <code>Vector&lt;T&gt;</code> objects owning the same memory resource.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="move_semantics_11.png" class="img-fluid figure-img"></p>
<figcaption>Step 1. Copy the pointers</figcaption>
</figure>
</div>
<p>The second step is, of course to set the pointers of the temporary vector to <code>nullptr</code>.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="move_semantics_12.png" class="img-fluid figure-img"></p>
<figcaption>Step 2. Zero out the members of __temp</figcaption>
</figure>
</div>
<p>That looks great and this is cheap! We are doing the minimum amount of work to transfer the contents of the temporary into <code>x</code>.</p>
<p>At the end of the assignment operation, the temporary goes out of scope and the vector <span class="math inline">\(\{1,2,3,\ldots,10\}\)</span> is in <code>x</code>. How do we implement this logic programmatically?</p>
<p>In addition to the copy-constructor, we write a move constructor. A move constuctor simply moves the data by taking ownership of the pointer that refers to the data, leaving the data itself where it resides.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="co">// move constructor</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>Vector<span class="op">(</span>Vector<span class="op">&amp;&amp;</span> src<span class="op">)</span> <span class="kw">noexcept</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Just swap the memory pointers</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>swap<span class="op">(</span>src<span class="op">,</span> <span class="op">*</span><span class="kw">this</span><span class="op">);</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<section id="rvalue-references-in-detail" class="level3">
<h3 class="anchored" data-anchor-id="rvalue-references-in-detail"><em>rvalue</em> references in detail</h3>
<p>The constructor takes an argument of the type <em>rvalue</em> reference. <em>rvalue</em> references are declared two ampersands. <em>lvalue</em>s bind to <em>lvalue</em> references. When taking a reference to a temporary object, an <em>rvalue</em>, you have two choices. <em>rvalue</em>s can bind to:</p>
<ul>
<li>A <code>const</code> <em>lvalue</em> reference.</li>
<li>A mutable <em>rvalue</em> reference.</li>
</ul>
<div class="sourceCode" id="cb20"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="bu">std::</span>string<span class="op">&amp;</span> r1 <span class="op">{</span><span class="st">"hello"</span><span class="op">};</span>    </span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>string<span class="op">&amp;</span> r2 <span class="op">{</span><span class="st">"world"</span><span class="op">};</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> Vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> r3 <span class="op">{</span><span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span><span class="op">,</span><span class="dv">4</span><span class="op">,</span><span class="dv">5</span><span class="op">};</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>Vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;&amp;</span> r4<span class="op">{</span><span class="dv">6</span><span class="op">,</span><span class="dv">7</span><span class="op">,</span><span class="dv">8</span><span class="op">,</span><span class="dv">9</span><span class="op">,</span><span class="dv">10</span><span class="op">};</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>All these references have the semantics of - <em>we can steal/modify the resources of the object we refer to, provided the state of the object remains a valid state</em>. Technically, these semantics are not checked by compilers, so we can modify an <em>rvalue</em> reference as we can do with any non-<code>const</code> object of the type. We might also decide not to modify the value.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>string<span class="op">&amp;&amp;</span> r1 <span class="op">=</span> <span class="st">"hello"</span><span class="op">;</span>    </span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>r1 <span class="op">+=</span> <span class="st">"world"</span><span class="op">;</span> </span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>Vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;&amp;</span> r2 <span class="op">{</span><span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span><span class="op">,</span><span class="dv">4</span><span class="op">,</span><span class="dv">5</span><span class="op">};</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>r2<span class="op">.</span>push_back<span class="op">(</span><span class="dv">6</span><span class="op">);</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>And it’s a logic error to take a mutable <em>lvalue</em> reference to a temporary, so this is disallowed in the language:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="co">// std::string&amp; r1 = "hello";    //error: this is not possible</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="co">// r1 += "world"; </span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a><span class="co">// Vector&lt;int&gt;&amp; r2 {1,2,3,4,5};</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a><span class="co">// r2.push_back(6);</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Assigning a temporary to a reference extends the lifetime of the temporary so that it matches the lifetime of the reference. So, this is legal:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>        <span class="at">const</span> <span class="bu">std::</span>string<span class="op">&amp;</span> s <span class="op">=</span> foo<span class="op">();</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> s <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span>    <span class="co">//the temporary to which s refers is still alive</span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">//but now it's destroyed</span></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span>    </span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>And so is this:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>string foo<span class="op">(){</span> <span class="cf">return</span> <span class="st">"foo"</span><span class="op">;};</span>      <span class="co">//function that returns a string</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> bar<span class="op">(</span><span class="bu">std::</span>string<span class="op">&amp;&amp;</span> s<span class="op">){</span>              <span class="co">// extends the lifetime as before</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> s<span class="op">;</span> </span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>    </span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>    bar<span class="op">(</span>foo<span class="op">());</span>     </span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="rvalue-references-as-parameters" class="level3">
<h3 class="anchored" data-anchor-id="rvalue-references-as-parameters"><em>rvalue</em> references as parameters</h3>
<p>When we declare a parameter to be an <em>rvalue</em> reference, it has exactly the behavior and semantics as introduced above:</p>
<ul>
<li>The parameter can only bind to a temporary object or an <em>rvalue</em>.</li>
<li>According to the semantics of <em>rvalue</em> references:
<ul>
<li>The caller claims that it is no longer interested in the object. Therefore, you can steal the guts of object, take ownership of its resources.</li>
<li>However, the caller might still be interested in using the object. Therefore, any modification should keep the referenced object in a valid state.</li>
</ul></li>
</ul>
</section>
</section>
<section id="stdmove" class="level2">
<h2 class="anchored" data-anchor-id="stdmove"><code>std::move()</code></h2>
<p>Hey, this is cool! Why don’t we apply these ideas to the below example?</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>Vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> v1 <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span><span class="op">};</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>Vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> v2 <span class="op">{</span>v1<span class="op">};</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Well, in this case, we would have a problem. <code>v1</code> has a name, it has a persistent storage location and a memory address, it is an <em>lvalue</em>. You can’t steal the contents of <code>v1</code>.</p>
<p>But, we can do something about this. If indeed you are interested to transfer the contents of <code>v1</code> into <code>v2</code>, then all we need to do is use <code>std::move</code>.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>Vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> v1 <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span><span class="op">};</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>Vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> v2 <span class="op">{</span><span class="bu">std::</span>move<span class="op">(</span>v1<span class="op">)};</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><code>std::move()</code> is a function that you can think of as performing an unconditional cast of its argument to an <em>rvalue</em> reference. <code>std::move(v1)</code> marks <code>v1</code> to be movable. It does not physically move anything. It signals, that the object <code>v1</code> may be <em>moved from</em>.</p>
<p>If you have an <em>lvalue</em>, an object for which the lifetime does not end when you use it, you can mark it with <code>std::move()</code> to express <em>I no longer need this object here</em>. <code>std::move</code> does not move; it only sets a temporary marker in the context where the expression is used:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> foo1<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>string<span class="op">&amp;</span> lr<span class="op">);</span>    <span class="co">//binds to the passed object without modifying it</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> foo1<span class="op">(</span><span class="bu">std::</span>string<span class="op">&amp;&amp;</span> rv<span class="op">);</span>         <span class="co">//binds to the passed object and might steal/modify its contents</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>string s<span class="op">{</span><span class="st">"hello"</span><span class="op">};</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>foo1<span class="op">(</span>s<span class="op">);</span>                             <span class="co">//calls the first foo(), s keeps its value</span></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>foo1<span class="op">(</span><span class="bu">std::</span>move<span class="op">(</span>s<span class="op">));</span>                  <span class="co">//calls the second foo(), s might lose its value</span></span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a>                                     <span class="co">//semantically s no longer legal to access</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Objects marked with <code>std::move()</code> can still be passed to a function that takes an ordinary <code>const</code> <em>lvalue</em> reference. Consider another code snippet:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> foo2<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>string<span class="op">&amp;</span> lr<span class="op">);</span>   <span class="co">//binds to the passed object without modifying it</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>                                    <span class="co">//no other overload of foo2()</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>foo2<span class="op">(</span>s<span class="op">);</span>                            <span class="co">// calls foo2(), s keeps its value</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>foos<span class="op">(</span><span class="bu">std::</span>move<span class="op">(</span>s<span class="op">))</span>                  <span class="co">// calls foo2(), s keeps its value because we know that</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>                                    <span class="co">// foo2() can't modify or take ownership of the contents of s.</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Semantically, <code>s</code> is still legal to access after the execution of the last line. Because there’s overload of <code>foo2(const std::string&amp;&amp;)</code>, there is no ways its contents can be modified or transferred.</p>
<p>Note that, an object marked with <code>std::move()</code> cannot be passed to a non-<code>const</code> <em>lvalue</em> reference.</p>
<section id="header-file-for-stdmove" class="level3">
<h3 class="anchored" data-anchor-id="header-file-for-stdmove">Header file for <code>std::move()</code></h3>
<p><code>std::move()</code> is defined as a function in the C++ standard library. To use it, you have to include the header file <code>&lt;utility&gt;</code> where it is defined:</p>
</section>
<section id="implementation-of-stdmove" class="level3">
<h3 class="anchored" data-anchor-id="implementation-of-stdmove">Implementation of <code>std::move()</code></h3>
<p><code>std::move()</code> is nothing but a <code>static_cast</code> to an <em>rvalue</em> reference. You can achieve the same effect by calling <code>static_cast</code> manually as follows:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>foo<span class="op">(</span><span class="kw">static_cast</span><span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>obj<span class="op">)&amp;&amp;&gt;(</span>obj<span class="op">));</span>     <span class="co">//same effect foo(std::move(obj))</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Therefore, we could also write:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>string s<span class="op">{</span><span class="st">"hello"</span><span class="op">};</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>foo<span class="op">(</span><span class="kw">static_cast</span><span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&amp;&amp;&gt;(</span>s<span class="op">));</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
</section>
<section id="moved-from-objects" class="level2">
<h2 class="anchored" data-anchor-id="moved-from-objects">Moved-from objects</h2>
<p>After a <code>std::move()</code>, moved-from objects are not (partially) destroyed. They are still valid objects for which at least the destructor will be called. However, they should also be valid in the sense that they have a consistent state and all operations work as expected. The only thing you do not know is their contents.</p>
<section id="valid-but-unspecified-state" class="level3">
<h3 class="anchored" data-anchor-id="valid-but-unspecified-state">Valid but unspecified state</h3>
<p>The C++ standard library guarantees that moved-from objects are in a <em>valid but unspecified state</em>. Consider the following code:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>string s<span class="op">{</span><span class="st">"hello"</span><span class="op">};</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;</span> coll<span class="op">{};</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>coll<span class="op">.</span>push_back<span class="op">(</span><span class="bu">std::</span>move<span class="op">(</span>s<span class="op">));</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>After passing <code>s</code> with <code>std::move()</code> you can ask for the number of characters, print out the value, or even assign a new value. However, you cannot print the first character or any other character without checking the number of characters first:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;utility&gt;</span></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string s<span class="op">{</span><span class="st">"hello"</span><span class="op">};</span></span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;</span> coll<span class="op">{};</span></span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a>    coll<span class="op">.</span>push_back<span class="op">(</span><span class="bu">std::</span>move<span class="op">(</span>s<span class="op">));</span>   <span class="co">//keeps in a valid but unclear state</span></span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"Contents of s : "</span> <span class="op">&lt;&lt;</span> s <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span>     <span class="co">//ok (don't know which value is written)</span></span>
<span id="cb32-12"><a href="#cb32-12" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"size : "</span> <span class="op">&lt;&lt;</span> s<span class="op">.</span>size<span class="op">()</span> <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span> <span class="co">//ok (rites the number of characters)</span></span>
<span id="cb32-13"><a href="#cb32-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// std::cout &lt;&lt; "[0] = " &lt;&lt; s[0] &lt;&lt; "\n"; //error (potentially undefined behavior)</span></span>
<span id="cb32-14"><a href="#cb32-14" aria-hidden="true" tabindex="-1"></a>    s <span class="op">=</span> <span class="st">"new value"</span><span class="op">;</span>    <span class="co">// ok</span></span>
<span id="cb32-15"><a href="#cb32-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb32-16"><a href="#cb32-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><a href="https://godbolt.org/z/MY4Y576n1">Compiler Explorer</a></p>
<p>stdout</p>
<pre><code>Contents of s : 
size : 0</code></pre>
</section>
<section id="reusing-moved-from-objects" class="level3">
<h3 class="anchored" data-anchor-id="reusing-moved-from-objects">Reusing moved-from objects</h3>
<p>We might wonder why moved-from objects are still valid objects and are not (partially) destroyed. The reason is that there are useful applications of move semantics, where it makes sense to use moved-from objects again.</p>
<p>For example, consider code where we read chunks of data from a network socket or read strings line-by-line from a file stream and move them into a vector:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;</span> allRows<span class="op">;</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>string row<span class="op">;</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span><span class="op">(</span><span class="bu">std::</span>getline<span class="op">(</span>myStream<span class="op">,</span> row<span class="op">)){</span> <span class="co">//read next line into row</span></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>    allRows<span class="op">.</span>push_back<span class="op">(</span><span class="bu">std::</span>move<span class="op">(</span>row<span class="op">));</span>  <span class="co">//and move it to somewhere</span></span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Each time after we read a line into <code>row</code>, we use <code>std::move()</code> to move the value of <code>row</code> into the vector of all rows. Then, <code>std::getline()</code> uses the moved-from object <code>row</code> again to read the next line into it.</p>
<p>As a second example, consider a generic function that swaps two values:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> swap<span class="op">(</span>T<span class="op">&amp;</span> a<span class="op">,</span> T<span class="op">&amp;</span> b<span class="op">)</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>    T tmp<span class="op">{</span><span class="bu">std::</span>move<span class="op">(</span>a<span class="op">)};</span></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>    a <span class="op">=</span> <span class="bu">std::</span>move<span class="op">(</span>b<span class="op">);</span>       <span class="co">//assign new value to moved-from a</span></span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>    b <span class="op">=</span> <span class="bu">std::</span>move<span class="op">(</span>temp<span class="op">);</span>    <span class="co">//assign new value to moved-from b</span></span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Here, we move the value of <code>a</code> into a temporary object to be able t move-assign the value of <code>b</code> afterwards. The moved-from object <code>b</code> then receives the value of <code>tmp</code>, which is the former value of <code>a</code>.</p>
<p>Code like this is used in sorting algorithms for example, sorting a vector of buy/sell orders in the order book by the bid/ask prices.</p>
</section>
<section id="move-assignments-of-objects-to-themselves" class="level3">
<h3 class="anchored" data-anchor-id="move-assignments-of-objects-to-themselves">Move assignments of objects to themselves</h3>
<p>The rule that moved-from objects are in a <em>valid but unspecified state</em> usually also applies to objects after a direct or indirect self-move.</p>
<p>For example, after the following statement, the object <code>x</code> is usually valid without its value being known:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> <span class="bu">std::</span>move<span class="op">(</span>x<span class="op">);</span>   <span class="co">//afterwards x is valid but has an unclear value</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
</section>
<section id="the-canonical-move-constructor-and-move-assignment-operator" class="level2">
<h2 class="anchored" data-anchor-id="the-canonical-move-constructor-and-move-assignment-operator">The canonical move constructor and move assignment operator</h2>
<p>Consider the below <code>Widget</code> class as an example. The canonical move constructor and move assignment operators are written as follows:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Widget<span class="op">{</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span><span class="op">:</span></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> i<span class="op">;</span></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>string s<span class="op">{};</span></span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">*</span> resource<span class="op">;</span>            <span class="co">// Owning pointer</span></span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Move constructor</span></span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true" tabindex="-1"></a>    Widget<span class="op">(</span>Widget<span class="op">&amp;&amp;</span> rhs<span class="op">)</span> <span class="kw">noexcept</span> <span class="co">//Phase 1: member-wise swap</span></span>
<span id="cb37-10"><a href="#cb37-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">:</span> i <span class="op">{</span><span class="bu">std::</span>move<span class="op">(</span>rhs<span class="op">.</span>i<span class="op">)}</span></span>
<span id="cb37-11"><a href="#cb37-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">,</span> s <span class="op">{</span><span class="bu">std::</span>move<span class="op">(</span>rhs<span class="op">.</span>s<span class="op">)}</span></span>
<span id="cb37-12"><a href="#cb37-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">,</span> resource<span class="op">{</span><span class="bu">std::</span>move<span class="op">(</span>rhs<span class="op">.</span>resource<span class="op">)}</span></span>
<span id="cb37-13"><a href="#cb37-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb37-14"><a href="#cb37-14" aria-hidden="true" tabindex="-1"></a>        rhs<span class="op">.</span>resource <span class="op">=</span> <span class="kw">nullptr</span><span class="op">;</span> <span class="co">// Phase 2: reset the move-from object</span></span>
<span id="cb37-15"><a href="#cb37-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb37-16"><a href="#cb37-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-17"><a href="#cb37-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Move assignment operator</span></span>
<span id="cb37-18"><a href="#cb37-18" aria-hidden="true" tabindex="-1"></a>    Widget<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">=(</span>Widget<span class="op">&amp;&amp;</span> src<span class="op">)</span></span>
<span id="cb37-19"><a href="#cb37-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb37-20"><a href="#cb37-20" aria-hidden="true" tabindex="-1"></a>        <span class="kw">delete</span> resource<span class="op">;</span>            <span class="co">//Phase 1: Cleanup</span></span>
<span id="cb37-21"><a href="#cb37-21" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>swap<span class="op">(</span>src<span class="op">,</span> <span class="op">*</span><span class="kw">this</span><span class="op">);</span>      <span class="co">//Phase 2: Member-wise move</span></span>
<span id="cb37-22"><a href="#cb37-22" aria-hidden="true" tabindex="-1"></a>        src<span class="op">-&gt;</span>resource <span class="op">=</span> <span class="kw">nullptr</span><span class="op">;</span>    <span class="co">//Phase 3: Reset</span></span>
<span id="cb37-23"><a href="#cb37-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">*</span><span class="kw">this</span><span class="op">;</span></span>
<span id="cb37-24"><a href="#cb37-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb37-25"><a href="#cb37-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-26"><a href="#cb37-26" aria-hidden="true" tabindex="-1"></a>    Widget<span class="op">::</span>Widget<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">=(</span>Widget src<span class="op">);</span></span>
<span id="cb37-27"><a href="#cb37-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>An owning-pointer such <code>int*</code> is special, and it has to be dealt with separately.</p>
<p>Raw pointers are bad (especially owning raw pointers). In this case, the declaration doesn’t indicate whether it points to an element or an array.</p>
<p>If instead, we have a smart-pointer, then what I can do is omit is phase 2.</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Widget<span class="op">{</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span><span class="op">:</span></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> i<span class="op">;</span></span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>string s<span class="op">{};</span></span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">*</span> resource<span class="op">;</span>      </span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Move constructor</span></span>
<span id="cb38-9"><a href="#cb38-9" aria-hidden="true" tabindex="-1"></a>    Widget<span class="op">(</span>Widget<span class="op">&amp;&amp;</span> rhs<span class="op">)</span> <span class="kw">noexcept</span> <span class="co">//Phase 1: member-wise swap</span></span>
<span id="cb38-10"><a href="#cb38-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">:</span> i <span class="op">{</span><span class="bu">std::</span>move<span class="op">(</span>rhs<span class="op">.</span>i<span class="op">)}</span></span>
<span id="cb38-11"><a href="#cb38-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">,</span> s <span class="op">{</span><span class="bu">std::</span>move<span class="op">(</span>rhs<span class="op">.</span>s<span class="op">)}</span></span>
<span id="cb38-12"><a href="#cb38-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">,</span> resource<span class="op">{</span><span class="bu">std::</span>move<span class="op">(</span>rhs<span class="op">.</span>resource<span class="op">)}</span></span>
<span id="cb38-13"><a href="#cb38-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">{}</span></span>
<span id="cb38-14"><a href="#cb38-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-15"><a href="#cb38-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Move assignment operator</span></span>
<span id="cb38-16"><a href="#cb38-16" aria-hidden="true" tabindex="-1"></a>    Widget<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">=(</span>Widget<span class="op">&amp;&amp;</span> src<span class="op">)</span></span>
<span id="cb38-17"><a href="#cb38-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb38-18"><a href="#cb38-18" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>swap<span class="op">(</span>src<span class="op">,</span> <span class="op">*</span><span class="kw">this</span><span class="op">);</span> </span>
<span id="cb38-19"><a href="#cb38-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">*</span><span class="kw">this</span><span class="op">;</span></span>
<span id="cb38-20"><a href="#cb38-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb38-21"><a href="#cb38-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-22"><a href="#cb38-22" aria-hidden="true" tabindex="-1"></a>    Widget<span class="op">::</span>Widget<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">=(</span>Widget src<span class="op">);</span></span>
<span id="cb38-23"><a href="#cb38-23" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>I would like to show you one more thing. The canonical copy assignment operator also doubles up as a move-assignment operator.</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Copy/Move assignment operator</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>Widget<span class="op">::</span>Widget<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">=(</span>Widget src<span class="op">)</span>  <span class="co">//Copy/move constructor called </span></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>swap<span class="op">(</span>src<span class="op">,</span> <span class="op">*</span><span class="kw">this</span><span class="op">);</span> </span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">*</span><span class="kw">this</span><span class="op">;</span></span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb39-10"><a href="#cb39-10" aria-hidden="true" tabindex="-1"></a>    Widget w1<span class="op">(</span><span class="dv">5</span><span class="op">,</span><span class="st">"hello"</span><span class="op">,</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">(</span><span class="dv">10</span><span class="op">)),</span></span>
<span id="cb39-11"><a href="#cb39-11" aria-hidden="true" tabindex="-1"></a>    Widget w2 <span class="op">=</span> w1<span class="op">;</span>     <span class="co">//copy/move assignment operator called</span></span>
<span id="cb39-12"><a href="#cb39-12" aria-hidden="true" tabindex="-1"></a>    Widget w3 <span class="op">=</span> <span class="bu">std::</span>move<span class="op">(</span>w1<span class="op">);</span>  <span class="co">//copy/move assignment operator called</span></span>
<span id="cb39-13"><a href="#cb39-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>In the assignment statement <code>Widget w2 = w1;</code>, first the copy constructor is called and the contents of <code>w1</code> are copied to <code>src</code>, before the control enters the body of <code>operator=(Widget)</code>. Whereas the assignment statement <code>Widget w3 = std::move(w1)</code> results in the invocation of the move constructor and the contents of <code>w1</code> are transferred to <code>w3</code> before we execute the body of the assignment operator.</p>
</section>
<section id="avoiding-unnecessary-stdmove" class="level2">
<h2 class="anchored" data-anchor-id="avoiding-unnecessary-stdmove">Avoiding unnecessary <code>std::move()</code></h2>
<p>As we saw, returning a local object by value automatically uses move semantics if supported. However, to be safe, programmers might try to force this with an explicit <code>std::move()</code>:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>string foo<span class="op">()</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string s<span class="op">;</span></span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// do something</span></span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">std::</span>move<span class="op">(</span>s<span class="op">);</span>    <span class="co">//Bad, don't do this</span></span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Remember that <code>std::move()</code> is just a <code>static_cast</code> to an <em>rvalue</em> reference. Therefore, <code>std::move</code> is an expression that yields the type <code>std::string&amp;&amp;</code>. However, this no longer matches the return type and therefore disables <em>return value optimization</em>, which usually allows the returned object to be used as a return value. For types where move semantics is not implemented, this might even force the copying of the return value instead of just using the returned object as the return value.</p>
</section>
<section id="value-categories-in-detail" class="level2">
<h2 class="anchored" data-anchor-id="value-categories-in-detail">Value categories in detail</h2>
<p>To compile an expression or statement it does not only matter whether the involved types fit. For example, you cannot assign an <code>int</code> to an <code>int</code>, when on the left hand side of the assignment, an <code>int</code> literal is used.</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> i<span class="op">{};</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> <span class="dv">88</span><span class="op">;</span>     <span class="co">//Ok</span></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a><span class="co">//88 = i;   //Error</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>For this reason, each expression in C++ has a value category. Besides the type, the value category is essential to decide what you can do with an expression.</p>
<section id="value-categories-since-c11" class="level3">
<h3 class="anchored" data-anchor-id="value-categories-since-c11">Value categories since C++11</h3>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="move_semantics_14.png" class="img-fluid figure-img"></p>
<figcaption>Value Categories</figcaption>
</figure>
</div>
<p>We have the following primary categories:</p>
<ul>
<li><em>lvalue</em> (Locator Value)</li>
<li><em>prvalue</em> (Pure Readable Value)</li>
<li><em>xvalue</em> (Expiring Value)</li>
</ul>
<p>The composite categories are: - <em>glvalue</em> (generalized <em>lvalue</em>) as a common term for <em>lvalue</em> or <em>xvalue</em> - <em>rvalue</em> as a common term for <em>xvalue</em> or <em>prvalue</em></p>
<p>Intuitively, it’s easy to understand the primary value categories, if you look at the following diagram:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="move_semantics_15.png" class="img-fluid figure-img"></p>
<figcaption>Value Categories</figcaption>
</figure>
</div>
<p>For example,</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> X<span class="op">{</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a>X v<span class="op">;</span></span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> X c<span class="op">;</span></span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a>f<span class="op">(</span>v<span class="op">);</span>   <span class="co">//passes a modifiable lvalue</span></span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true" tabindex="-1"></a>f<span class="op">(</span>c<span class="op">);</span>   <span class="co">//passes a non-modifiable lvalue</span></span>
<span id="cb42-9"><a href="#cb42-9" aria-hidden="true" tabindex="-1"></a>f<span class="op">(</span>X<span class="op">());</span> <span class="co">//passes a prvalue (old syntax of creating a temporary)</span></span>
<span id="cb42-10"><a href="#cb42-10" aria-hidden="true" tabindex="-1"></a>f<span class="op">(</span>X<span class="op">{});</span> <span class="co">//passes a prvalue (new syntax of creating a temporary)</span></span>
<span id="cb42-11"><a href="#cb42-11" aria-hidden="true" tabindex="-1"></a>f<span class="op">(</span><span class="bu">std::</span>move<span class="op">(</span>v<span class="op">));</span>  <span class="co">//passes an xvalue</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Roughly speaking, as a rule of thumb:</p>
<ul>
<li>All names used as expressions are <em>lvalues</em>.</li>
<li>All string literals used as expressions are <em>lvalues</em>.</li>
<li>All non-string literals used as expressions are <em>prvalues</em>.</li>
<li>All temporaries without a name (especially objects returned by value) are <em>prvalues</em>.</li>
<li>All objects marked with a <code>std::move</code> are <em>xvalues</em>.</li>
</ul>
</section>
<section id="copy-elison-since-c17" class="level3">
<h3 class="anchored" data-anchor-id="copy-elison-since-c17">Copy Elison since C++17</h3>
<p>C++17 added mandates to the standard, formally known as :</p>
<ul>
<li>Guaranteed copy elison</li>
<li>Guraranteed return value optimization</li>
<li>Copy evasion</li>
</ul>
<p>If, in an initialization of an object, when the initializer expression is <em>prvalue</em> of the same class type as the variable type, copy elison is guaranteed.</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> T<span class="op">{</span></span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a>    T<span class="op">(){</span> <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"c'tor T()</span><span class="sc">\n</span><span class="st">"</span><span class="op">;}</span></span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a>    T<span class="op">(</span><span class="at">const</span> T<span class="op">&amp;</span> t<span class="op">){</span> <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"c'tor T(const T&amp; t)</span><span class="sc">\n</span><span class="st">"</span><span class="op">;}</span></span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true" tabindex="-1"></a>    T<span class="op">(</span>T<span class="op">&amp;&amp;</span> t<span class="op">){</span> <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"c'tor T(T&amp;&amp; t)</span><span class="sc">\n</span><span class="st">"</span><span class="op">;}</span></span>
<span id="cb43-8"><a href="#cb43-8" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb44"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>T x<span class="op">{</span>T<span class="op">{}};</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>In C++17, this is equivalent to <code>T x{};</code>. The default constructor is invoked only once.</p>
<p>Similarly, if, in a <code>return</code> statement the operand is a <em>prvalue</em> of the same class type as the function return type, copy elison is guaranteed.</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a>T func<span class="op">()</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> T<span class="op">{};</span></span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true" tabindex="-1"></a>T x<span class="op">{</span>func<span class="op">()};</span> <span class="co">//Only one default construction of T allowed here</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Under the rules of C++17, under the hood, a <em>prvalue</em> will be used only as <em>unmaterialized</em> recipe of an object, until actual materialization is required.</p>
<p>A <em>prvalue</em> is an expression whose evaluation <em>initializes/materializes</em> an object. This is called as <em>temporary materialization conversion</em>.</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span>  T<span class="op">{</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a>    T<span class="op">(){</span></span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"c'tor T()</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span></span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">//delete move and copy constructors</span></span>
<span id="cb46-7"><a href="#cb46-7" aria-hidden="true" tabindex="-1"></a>    T<span class="op">(</span><span class="at">const</span> T<span class="op">&amp;</span> other<span class="op">)</span> <span class="op">=</span> <span class="kw">delete</span><span class="op">;</span></span>
<span id="cb46-8"><a href="#cb46-8" aria-hidden="true" tabindex="-1"></a>    T<span class="op">(</span>T<span class="op">&amp;&amp;</span> other<span class="op">)</span> <span class="op">=</span> <span class="kw">delete</span><span class="op">;</span></span>
<span id="cb46-9"><a href="#cb46-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb46-10"><a href="#cb46-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-11"><a href="#cb46-11" aria-hidden="true" tabindex="-1"></a>T make<span class="op">(){</span></span>
<span id="cb46-12"><a href="#cb46-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">//Creates the first temporary (pre C++17)</span></span>
<span id="cb46-13"><a href="#cb46-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> T<span class="op">{};</span></span>
<span id="cb46-14"><a href="#cb46-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb46-15"><a href="#cb46-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-16"><a href="#cb46-16" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb46-17"><a href="#cb46-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Construct the second temporary (pre C++17)</span></span>
<span id="cb46-18"><a href="#cb46-18" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Copy/move temporary into N using the = operator (pre C++17)</span></span>
<span id="cb46-19"><a href="#cb46-19" aria-hidden="true" tabindex="-1"></a>    T t <span class="op">=</span> make<span class="op">();</span></span>
<span id="cb46-20"><a href="#cb46-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb46-21"><a href="#cb46-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Pre C++17, the function <code>make()</code> would construct a temporary within its scope. This temporary would then be copied/moved into another temporary within the <code>main</code> scope. Finally, the <code>operator=</code> would build <code>t</code> via copy/move construction. All of this temporary business would be elided by (RVO) by any decent compiler resulting in <code>make()</code> constructing a single object within <code>t</code>. However, this elison is somewhat optional, so the compiler must also demand that copy and move constructors exist, just in case. The above code does not compile with any pre C++17 compiler.</p>
<p>Post C++17, <code>make()</code> creates an object of type <code>T</code> within <code>t</code>. Avoiding excessive use of temporary objects is now a language feature and the reliance on compiler optimization is removed. The above code does compiler with a post C++17 compiler.</p>
</section>
<section id="value-categories-since-c17" class="level3">
<h3 class="anchored" data-anchor-id="value-categories-since-c17">Value Categories since C++17</h3>
<p>C++17 has the same value categories but clarified the semantic meaning of the value categories as described in the figure above.</p>
<p>The key approach for explaining value categories now is that in general, we have two major kinds of expressions:</p>
<ul>
<li><em>glvalues</em>: expressions for locations of long-living objects or functions.</li>
<li><em>prvalues</em>: expressions for short-living values for initializations.</li>
</ul>
<p>An <em>xvalue</em> is then considered a special location, representing a (long-living) object, whose resources/values are no longer needed.</p>
<p>Loosely speaking, <em>prvalues</em> themselves do not exist somewhere in memory, they do not denote objects. They are used for initialization. In C++17, <em>prvalues</em> are not moved from. It doesn’t make sense to talk about whether you can steal it’s resources.</p>
</section>
</section>
<section id="perfect-forwarding" class="level2">
<h2 class="anchored" data-anchor-id="perfect-forwarding">Perfect Forwarding</h2>
<section id="motivation-for-perfect-forwarding" class="level3">
<h3 class="anchored" data-anchor-id="motivation-for-perfect-forwarding">Motivation for perfect forwarding</h3>
<p>Consider a function that declares the parameter as <em>rvalue</em> reference:</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f<span class="op">(</span><span class="bu">std::</span>string<span class="op">&amp;&amp;</span> s<span class="op">)</span></span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Do something</span></span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"string s : "</span> <span class="op">&lt;&lt;</span> s <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span></span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>As we’ve learned, we can only pass <em>rvalue</em>s to this function:</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>string s<span class="op">{</span><span class="st">"hello"</span><span class="op">};</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a><span class="co">// f(s);                // Error : passing an lvalue to an rvalue ref</span></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a>f<span class="op">(</span><span class="bu">std::</span>move<span class="op">(</span>s<span class="op">));</span>        <span class="co">// okay, passing an xvalue</span></span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a>f<span class="op">(</span><span class="bu">std::</span>string<span class="op">(</span><span class="st">"world"</span><span class="op">));</span><span class="co">// okay, passing a prvalue</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>However, when we use the parameter <code>s</code> inside the function <code>f(std::string&amp;&amp;)</code>, we are dealing with an object that has a name. This means that we use <code>s</code> as an <em>lvalue</em>. We can do only what we are allowed to do with an <em>lvalue</em>. This means that we cannot call our function recursively.</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f<span class="op">(</span><span class="bu">std::</span>string<span class="op">&amp;&amp;</span> s<span class="op">)</span></span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Do something</span></span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"string s : "</span> <span class="op">&lt;&lt;</span> s <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span></span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// f(s);    // Error: passing an lvalue to an rvalue reference</span></span>
<span id="cb49-6"><a href="#cb49-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We have to mark <code>s</code> with <code>std::move()</code> again:</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f<span class="op">(</span><span class="bu">std::</span>string<span class="op">&amp;&amp;</span> s<span class="op">)</span></span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Do something</span></span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"string s : "</span> <span class="op">&lt;&lt;</span> s <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span></span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a>    f<span class="op">(</span><span class="bu">std::</span>move<span class="op">(</span>s<span class="op">));</span>    <span class="co">// Ok, passing an xvalue</span></span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This is the formal specification of the rule that <strong>move semantics is not passed through</strong>.</p>
<p>To forward an object that is passed with move semantics to a function, it not only has to be bound to an <em>rvalue</em> reference; you have to use <code>std::move()</code> again to forward its move semantics to another function.</p>
<p>For example:</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> X<span class="op">{</span></span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a><span class="co">//forward declarations</span></span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> foo<span class="op">(</span><span class="at">const</span> X<span class="op">&amp;);</span>     <span class="co">//for constant values (read-only access)</span></span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> foo<span class="op">(</span>X<span class="op">&amp;);</span>           <span class="co">//for variable values (out parameters)</span></span>
<span id="cb51-8"><a href="#cb51-8" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> foo<span class="op">(</span>X<span class="op">&amp;&amp;);</span>          <span class="co">//for values that are no longer used(move semantics)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We have the following rules when calling these functions:</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a>X v<span class="op">;</span></span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> X c<span class="op">;</span></span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a>foo<span class="op">(</span>v<span class="op">);</span>     <span class="co">//calls foo(X&amp;)</span></span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true" tabindex="-1"></a>foo<span class="op">(</span>c<span class="op">);</span>     <span class="co">//calls foo(const X&amp;)</span></span>
<span id="cb52-6"><a href="#cb52-6" aria-hidden="true" tabindex="-1"></a>foo<span class="op">(</span>X<span class="op">{});</span>   <span class="co">//calls foo(X&amp;&amp;)</span></span>
<span id="cb52-7"><a href="#cb52-7" aria-hidden="true" tabindex="-1"></a>foo<span class="op">(</span><span class="bu">std::</span>move<span class="op">(</span>v<span class="op">))</span>   <span class="co">//calls foo(X&amp;&amp;)</span></span>
<span id="cb52-8"><a href="#cb52-8" aria-hidden="true" tabindex="-1"></a>foo<span class="op">(</span><span class="bu">std::</span>move<span class="op">(</span>c<span class="op">))</span>   <span class="co">//calls foo(const X&amp;)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Now, assume that we want to call <code>foo()</code> for the same arguments indirectly via a helper function <code>callFoo()</code>. That helper function would also need the three overloads.</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> callFoo<span class="op">(</span><span class="at">const</span> X<span class="op">&amp;</span> arg<span class="op">){</span>     <span class="co">//arg binds to all const objects</span></span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a>    foo<span class="op">(</span>arg<span class="op">);</span>                   <span class="co">//calls foo(const X&amp;)</span></span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> callFoo<span class="op">(</span>X<span class="op">&amp;</span> arg<span class="op">)</span>            <span class="co">//arg binds to lvalues</span></span>
<span id="cb53-6"><a href="#cb53-6" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb53-7"><a href="#cb53-7" aria-hidden="true" tabindex="-1"></a>    foo<span class="op">(</span>arg<span class="op">);</span>                   <span class="co">//calls foo(&amp;)</span></span>
<span id="cb53-8"><a href="#cb53-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb53-9"><a href="#cb53-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-10"><a href="#cb53-10" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> callFoo<span class="op">(</span>X<span class="op">&amp;&amp;</span> arg<span class="op">){</span>          <span class="co">//arg binds to rvalues</span></span>
<span id="cb53-11"><a href="#cb53-11" aria-hidden="true" tabindex="-1"></a>    foo<span class="op">(</span><span class="bu">std::</span>move<span class="op">(</span>arg<span class="op">));</span>        <span class="co">//needs std::move() to call foo(X&amp;&amp;)</span></span>
<span id="cb53-12"><a href="#cb53-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>In all cases, <code>arg</code> is used as an <em>lvalue</em> (being an object with a name). The first version forwards it as a <code>const</code> object, but the other two cases implement two different ways to forward the non-<code>const</code> argument.</p>
<ul>
<li>Arguments declared as <em>lvalue</em> references (that bind to objects that do not have move semantics) are passed as they are.</li>
<li>Arguments declared as <em>rvalue</em> references (that bind to objects that have move semantics) are passed with <code>std::move</code>.</li>
</ul>
<p>This allows us to forward move semantics perfectly: for any argument that is passed with move semantics, we keep the move semantics; but we do not add move semantics when we get an argument that does not have it.</p>
<p>Only with this implementation is the use of <code>callFoo</code> to call <code>foo</code> transparent.</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a>X v<span class="op">;</span></span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> X c<span class="op">;</span></span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a>callFoo<span class="op">(</span>v<span class="op">);</span>     <span class="co">//calls foo(X&amp;)</span></span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true" tabindex="-1"></a>callFoo<span class="op">(</span>c<span class="op">);</span>     <span class="co">//calls foo(const X&amp;)</span></span>
<span id="cb54-6"><a href="#cb54-6" aria-hidden="true" tabindex="-1"></a>callFoo<span class="op">(</span>X<span class="op">{});</span>   <span class="co">//calls foo(X&amp;&amp;)</span></span>
<span id="cb54-7"><a href="#cb54-7" aria-hidden="true" tabindex="-1"></a>callFoo<span class="op">(</span><span class="bu">std::</span>move<span class="op">(</span>v<span class="op">))</span>   <span class="co">//calls foo(X&amp;&amp;)</span></span>
<span id="cb54-8"><a href="#cb54-8" aria-hidden="true" tabindex="-1"></a>callFoo<span class="op">(</span><span class="bu">std::</span>move<span class="op">(</span>c<span class="op">))</span>   <span class="co">//calls foo(const X&amp;)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Remember that an <em>rvalue</em> passed to an <em>rvalue</em> reference becomes an <em>lvalue</em> when used, which means that we need <code>std::move()</code> to pass it as an <em>rvalue</em> again. However, we cannot use <code>std::move()</code> everywhere. For the other overloads, using <code>std::move()</code> would call the overload of <code>foo()</code> for <em>rvalue</em> references when an <em>lvalue</em> is passed.</p>
<p>For <em>perfect forwarding</em> in generic code, we would always need all these overloads for each parameter. To support all combinations, this means having <span class="math inline">\(3^2 = 9\)</span> overloads for <span class="math inline">\(2\)</span> generic arguments and <span class="math inline">\(3^3 = 27\)</span> overloads for <span class="math inline">\(3\)</span> generic arguments.</p>
<p>Therefore, C++11 introduced a special way to <em>perfectly forward</em> without any overloads but still keeping the type and the value category.</p>
</section>
<section id="implementing-perfect-forwarding" class="level3">
<h3 class="anchored" data-anchor-id="implementing-perfect-forwarding">Implementing perfect forwarding</h3>
<p>To avoid overloading functions for parameters with different value categories, C++ introduced the mechanism of perfect forwarding. You need three things:</p>
<ol type="1">
<li>Take the call parameter as a pure <em>rvalue</em> reference (delcared with <code>&amp;&amp;</code> but without <code>const</code> or <code>volatile</code>)</li>
<li>The type of the parameter has to be a template parameter of the function.</li>
<li>When forwarding the parameter to another function, use a helper function called <code>std::forward&lt;&gt;()</code> which is declared in <code>&lt;utility&gt;</code>.</li>
</ol>
<p>You have to implement a function that perfectly forwards an argument as follows:</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> callFoo<span class="op">(</span>T<span class="op">&amp;&amp;</span> arg<span class="op">)</span></span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a>    foo<span class="op">(</span><span class="bu">std::</span>forward<span class="op">&lt;</span>T<span class="op">&gt;(</span>arg<span class="op">));</span></span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><code>std::forward&lt;&gt;()</code> is defined as a conditional <code>std::move()</code>, so that we get the same behavior as the three (or four) overloads of <code>callFoo()</code> above:</p>
<ul>
<li>If we pass an <em>rvalue</em> to <code>arg</code>, we have the same effect as calling <code>foo(std::move(arg))</code>.</li>
<li>If we pass an <em>lvalue</em> to <code>arg</code>, we have the same effect as calling <code>foo(arg)</code>.</li>
</ul>
<p>What exactly is happening here, is pretty tricky and needs a careful explanation.</p>
</section>
<section id="universal-and-forwarding-references" class="level3">
<h3 class="anchored" data-anchor-id="universal-and-forwarding-references">Universal and Forwarding references</h3>
<p>First note that we declare <code>arg</code> as an <em>rvalue</em> reference parameter:</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> callFoo<span class="op">(</span>T<span class="op">&amp;&amp;</span> arg<span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This might give the impression that the rules of <em>rvalue</em> references apply. However, that is not the case. An <em>rvalue</em> reference (not qualified with <code>const</code> or <code>volatile</code>) of a function parameter does not follow the rules of ordinary <em>rvalue</em> references. It is a different thing.</p>


<!-- -->

</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb57" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a><span class="an">title:</span><span class="co"> "A hitchhiker's guide to move semantics and perfect forwarding"</span></span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a><span class="an">author:</span><span class="co"> "Quasar"</span></span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a><span class="an">date:</span><span class="co"> "2024-10-26"</span></span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true" tabindex="-1"></a><span class="an">categories:</span><span class="co"> [C++]      </span></span>
<span id="cb57-6"><a href="#cb57-6" aria-hidden="true" tabindex="-1"></a><span class="an">image:</span><span class="co"> "cpp.jpg"</span></span>
<span id="cb57-7"><a href="#cb57-7" aria-hidden="true" tabindex="-1"></a><span class="an">toc:</span><span class="co"> true</span></span>
<span id="cb57-8"><a href="#cb57-8" aria-hidden="true" tabindex="-1"></a><span class="an">toc-depth:</span><span class="co"> 3</span></span>
<span id="cb57-9"><a href="#cb57-9" aria-hidden="true" tabindex="-1"></a><span class="an">format:</span></span>
<span id="cb57-10"><a href="#cb57-10" aria-hidden="true" tabindex="-1"></a><span class="co">    html:</span></span>
<span id="cb57-11"><a href="#cb57-11" aria-hidden="true" tabindex="-1"></a><span class="co">        code-tools: true</span></span>
<span id="cb57-12"><a href="#cb57-12" aria-hidden="true" tabindex="-1"></a><span class="co">        code-block-border-left: true</span></span>
<span id="cb57-13"><a href="#cb57-13" aria-hidden="true" tabindex="-1"></a><span class="co">        code-annotations: below</span></span>
<span id="cb57-14"><a href="#cb57-14" aria-hidden="true" tabindex="-1"></a><span class="co">        highlight-style: pygments</span></span>
<span id="cb57-15"><a href="#cb57-15" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb57-16"><a href="#cb57-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-17"><a href="#cb57-17" aria-hidden="true" tabindex="-1"></a><span class="fu">## Motivation for Move Semantics</span></span>
<span id="cb57-18"><a href="#cb57-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-19"><a href="#cb57-19" aria-hidden="true" tabindex="-1"></a>To understand the basic principles of move semantics, let's look at the execution of a small piece of code. I've written a toy <span class="in">`Vector`</span> class. I choose the manage the memory myself, so I will follow the <span class="co">[</span><span class="ot">rule of three</span><span class="co">](https://en.wikipedia.org/wiki/Rule_of_three_%28C++_programming%29)</span>. I will supply a copy-constructor, copy-assignment operator and a destructor. I have also overloaded <span class="in">`operator+()`</span> to support element-wise addition of two vectors. </span>
<span id="cb57-20"><a href="#cb57-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-21"><a href="#cb57-21" aria-hidden="true" tabindex="-1"></a><span class="fu">### Value Semantics</span></span>
<span id="cb57-22"><a href="#cb57-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-23"><a href="#cb57-23" aria-hidden="true" tabindex="-1"></a>Assume that we have the following program:</span>
<span id="cb57-24"><a href="#cb57-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-25"><a href="#cb57-25" aria-hidden="true" tabindex="-1"></a><span class="in">```cpp</span></span>
<span id="cb57-26"><a href="#cb57-26" aria-hidden="true" tabindex="-1"></a><span class="co">//basics/copy_semantics.cpp</span></span>
<span id="cb57-27"><a href="#cb57-27" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb57-28"><a href="#cb57-28" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdexcept&gt;</span></span>
<span id="cb57-29"><a href="#cb57-29" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;initializer_list&gt;</span></span>
<span id="cb57-30"><a href="#cb57-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-31"><a href="#cb57-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-32"><a href="#cb57-32" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb57-33"><a href="#cb57-33" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Vector <span class="op">{</span></span>
<span id="cb57-34"><a href="#cb57-34" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="cb57-35"><a href="#cb57-35" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="va">capacity_</span><span class="op">;</span></span>
<span id="cb57-36"><a href="#cb57-36" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="va">size_</span><span class="op">;</span></span>
<span id="cb57-37"><a href="#cb57-37" aria-hidden="true" tabindex="-1"></a>    T<span class="op">*</span> <span class="va">ptr_</span><span class="op">;</span></span>
<span id="cb57-38"><a href="#cb57-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-39"><a href="#cb57-39" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb57-40"><a href="#cb57-40" aria-hidden="true" tabindex="-1"></a>    Vector<span class="op">()</span> <span class="op">:</span><span class="va">capacity_</span><span class="op">{</span> <span class="dv">0</span> <span class="op">},</span> <span class="va">size_</span><span class="op">{</span> <span class="dv">0</span> <span class="op">},</span> <span class="va">ptr_</span><span class="op">{</span> <span class="kw">nullptr</span> <span class="op">}</span> <span class="op">{}</span></span>
<span id="cb57-41"><a href="#cb57-41" aria-hidden="true" tabindex="-1"></a>    Vector<span class="op">(</span><span class="dt">int</span> size<span class="op">)</span> <span class="op">:</span> <span class="va">capacity_</span><span class="op">{</span> size <span class="op">},</span> <span class="va">ptr_</span><span class="op">{</span> <span class="kw">new</span> T<span class="op">[</span>size<span class="op">]</span> <span class="op">},</span> <span class="va">size_</span><span class="op">{</span> size <span class="op">}</span> <span class="op">{}</span></span>
<span id="cb57-42"><a href="#cb57-42" aria-hidden="true" tabindex="-1"></a>    Vector<span class="op">(</span><span class="dt">int</span> size<span class="op">,</span> T data<span class="op">)</span> <span class="op">:</span> Vector<span class="op">(</span>size<span class="op">)</span> <span class="op">{</span></span>
<span id="cb57-43"><a href="#cb57-43" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i<span class="op">{</span> <span class="dv">0</span> <span class="op">};</span> i <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb57-44"><a href="#cb57-44" aria-hidden="true" tabindex="-1"></a>            <span class="va">ptr_</span><span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> data<span class="op">;</span></span>
<span id="cb57-45"><a href="#cb57-45" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb57-46"><a href="#cb57-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-47"><a href="#cb57-47" aria-hidden="true" tabindex="-1"></a>    Vector<span class="op">(</span><span class="bu">std::</span>initializer_list<span class="op">&lt;</span>T<span class="op">&gt;</span> list<span class="op">)</span> <span class="op">{</span></span>
<span id="cb57-48"><a href="#cb57-48" aria-hidden="true" tabindex="-1"></a>        clear<span class="op">();</span></span>
<span id="cb57-49"><a href="#cb57-49" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="at">const</span> T<span class="op">&amp;</span> elem <span class="op">:</span> list<span class="op">)</span></span>
<span id="cb57-50"><a href="#cb57-50" aria-hidden="true" tabindex="-1"></a>            push_back<span class="op">(</span>elem<span class="op">);</span></span>
<span id="cb57-51"><a href="#cb57-51" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb57-52"><a href="#cb57-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-53"><a href="#cb57-53" aria-hidden="true" tabindex="-1"></a>    <span class="co">//Destructor</span></span>
<span id="cb57-54"><a href="#cb57-54" aria-hidden="true" tabindex="-1"></a>    <span class="op">~</span>Vector<span class="op">()</span></span>
<span id="cb57-55"><a href="#cb57-55" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb57-56"><a href="#cb57-56" aria-hidden="true" tabindex="-1"></a>        clear<span class="op">();</span></span>
<span id="cb57-57"><a href="#cb57-57" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb57-58"><a href="#cb57-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-59"><a href="#cb57-59" aria-hidden="true" tabindex="-1"></a>    <span class="co">//Copy constructor</span></span>
<span id="cb57-60"><a href="#cb57-60" aria-hidden="true" tabindex="-1"></a>    Vector<span class="op">(</span><span class="at">const</span> Vector<span class="op">&amp;</span> v<span class="op">)</span></span>
<span id="cb57-61"><a href="#cb57-61" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb57-62"><a href="#cb57-62" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span><span class="kw">this</span> <span class="op">==</span> <span class="op">&amp;</span>v<span class="op">)</span></span>
<span id="cb57-63"><a href="#cb57-63" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span><span class="op">;</span></span>
<span id="cb57-64"><a href="#cb57-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-65"><a href="#cb57-65" aria-hidden="true" tabindex="-1"></a>        <span class="va">capacity_</span> <span class="op">=</span> v<span class="op">.</span><span class="va">capacity_</span><span class="op">;</span></span>
<span id="cb57-66"><a href="#cb57-66" aria-hidden="true" tabindex="-1"></a>        <span class="va">size_</span> <span class="op">=</span> v<span class="op">.</span><span class="va">size_</span><span class="op">;</span></span>
<span id="cb57-67"><a href="#cb57-67" aria-hidden="true" tabindex="-1"></a>        <span class="va">ptr_</span> <span class="op">=</span> <span class="kw">new</span> T<span class="op">[</span>v<span class="op">.</span><span class="va">size_</span><span class="op">];</span></span>
<span id="cb57-68"><a href="#cb57-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-69"><a href="#cb57-69" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i<span class="op">{</span> <span class="dv">0</span> <span class="op">};</span> i <span class="op">&lt;</span> v<span class="op">.</span><span class="va">size_</span><span class="op">;</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb57-70"><a href="#cb57-70" aria-hidden="true" tabindex="-1"></a>            <span class="va">ptr_</span><span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> v<span class="op">.</span><span class="va">ptr_</span><span class="op">[</span>i<span class="op">];</span></span>
<span id="cb57-71"><a href="#cb57-71" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb57-72"><a href="#cb57-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-73"><a href="#cb57-73" aria-hidden="true" tabindex="-1"></a>    <span class="co">//Copy assignment operator</span></span>
<span id="cb57-74"><a href="#cb57-74" aria-hidden="true" tabindex="-1"></a>    Vector<span class="op">&lt;</span>T<span class="op">&gt;&amp;</span> <span class="kw">operator</span><span class="op">=(</span><span class="at">const</span> Vector<span class="op">&lt;</span>T<span class="op">&gt;&amp;</span> v<span class="op">)</span></span>
<span id="cb57-75"><a href="#cb57-75" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb57-76"><a href="#cb57-76" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span><span class="kw">this</span> <span class="op">!=</span> <span class="op">&amp;</span>v<span class="op">)</span></span>
<span id="cb57-77"><a href="#cb57-77" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb57-78"><a href="#cb57-78" aria-hidden="true" tabindex="-1"></a>            <span class="kw">delete</span><span class="op">[]</span> <span class="va">ptr_</span><span class="op">;</span></span>
<span id="cb57-79"><a href="#cb57-79" aria-hidden="true" tabindex="-1"></a>            <span class="va">ptr_</span> <span class="op">=</span> <span class="kw">nullptr</span><span class="op">;</span></span>
<span id="cb57-80"><a href="#cb57-80" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-81"><a href="#cb57-81" aria-hidden="true" tabindex="-1"></a>            <span class="va">capacity_</span> <span class="op">=</span> v<span class="op">.</span><span class="va">capacity_</span><span class="op">;</span></span>
<span id="cb57-82"><a href="#cb57-82" aria-hidden="true" tabindex="-1"></a>            <span class="va">size_</span> <span class="op">=</span> v<span class="op">.</span><span class="va">size_</span><span class="op">;</span></span>
<span id="cb57-83"><a href="#cb57-83" aria-hidden="true" tabindex="-1"></a>            <span class="va">ptr_</span> <span class="op">=</span> <span class="kw">new</span> T<span class="op">[</span><span class="va">capacity_</span><span class="op">];</span></span>
<span id="cb57-84"><a href="#cb57-84" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-85"><a href="#cb57-85" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i<span class="op">{</span> <span class="dv">0</span> <span class="op">};</span> i <span class="op">&lt;</span> v<span class="op">.</span><span class="va">size_</span><span class="op">;</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb57-86"><a href="#cb57-86" aria-hidden="true" tabindex="-1"></a>                <span class="va">ptr_</span><span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> v<span class="op">.</span><span class="va">ptr_</span><span class="op">[</span>i<span class="op">];</span></span>
<span id="cb57-87"><a href="#cb57-87" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb57-88"><a href="#cb57-88" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-89"><a href="#cb57-89" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">*</span><span class="kw">this</span><span class="op">;</span></span>
<span id="cb57-90"><a href="#cb57-90" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb57-91"><a href="#cb57-91" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-92"><a href="#cb57-92" aria-hidden="true" tabindex="-1"></a>    T<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">[](</span><span class="dt">int</span> i<span class="op">)</span></span>
<span id="cb57-93"><a href="#cb57-93" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb57-94"><a href="#cb57-94" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>i <span class="op">&gt;=</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> i <span class="op">&lt;</span> <span class="va">size_</span><span class="op">)</span></span>
<span id="cb57-95"><a href="#cb57-95" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">ptr_</span><span class="op">[</span>i<span class="op">];</span></span>
<span id="cb57-96"><a href="#cb57-96" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span></span>
<span id="cb57-97"><a href="#cb57-97" aria-hidden="true" tabindex="-1"></a>            <span class="cf">throw</span> <span class="bu">std::</span>out_of_range<span class="op">(</span><span class="st">"Index out of bounds."</span><span class="op">);</span></span>
<span id="cb57-98"><a href="#cb57-98" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb57-99"><a href="#cb57-99" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-100"><a href="#cb57-100" aria-hidden="true" tabindex="-1"></a>    T<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">[](</span><span class="dt">int</span> i<span class="op">)</span> <span class="at">const</span></span>
<span id="cb57-101"><a href="#cb57-101" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb57-102"><a href="#cb57-102" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>i <span class="op">&gt;=</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> i <span class="op">&lt;</span> <span class="va">size_</span><span class="op">)</span></span>
<span id="cb57-103"><a href="#cb57-103" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">ptr_</span><span class="op">[</span>i<span class="op">];</span></span>
<span id="cb57-104"><a href="#cb57-104" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span></span>
<span id="cb57-105"><a href="#cb57-105" aria-hidden="true" tabindex="-1"></a>            <span class="cf">throw</span> <span class="bu">std::</span>out_of_range<span class="op">(</span><span class="st">"Index out of bounds."</span><span class="op">);</span></span>
<span id="cb57-106"><a href="#cb57-106" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb57-107"><a href="#cb57-107" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-108"><a href="#cb57-108" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> reserve<span class="op">(</span><span class="dt">int</span> size<span class="op">)</span></span>
<span id="cb57-109"><a href="#cb57-109" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb57-110"><a href="#cb57-110" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span><span class="va">size_</span> <span class="op">&lt;</span> <span class="va">capacity_</span><span class="op">)</span> <span class="cf">return</span><span class="op">;</span></span>
<span id="cb57-111"><a href="#cb57-111" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-112"><a href="#cb57-112" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span><span class="va">ptr_</span> <span class="op">==</span> <span class="kw">nullptr</span><span class="op">)</span></span>
<span id="cb57-113"><a href="#cb57-113" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb57-114"><a href="#cb57-114" aria-hidden="true" tabindex="-1"></a>            <span class="va">size_</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb57-115"><a href="#cb57-115" aria-hidden="true" tabindex="-1"></a>            <span class="va">capacity_</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb57-116"><a href="#cb57-116" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb57-117"><a href="#cb57-117" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-118"><a href="#cb57-118" aria-hidden="true" tabindex="-1"></a>        T<span class="op">*</span> bufferNew <span class="op">=</span> <span class="kw">new</span> T<span class="op">[</span>size<span class="op">];</span></span>
<span id="cb57-119"><a href="#cb57-119" aria-hidden="true" tabindex="-1"></a>        <span class="dt">unsigned</span> <span class="dt">int</span> l_size <span class="op">=</span> <span class="bu">std::</span>min<span class="op">(</span><span class="va">capacity_</span><span class="op">,</span> size<span class="op">);</span></span>
<span id="cb57-120"><a href="#cb57-120" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i<span class="op">{</span> <span class="dv">0</span> <span class="op">};</span> i <span class="op">&lt;</span> l_size<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb57-121"><a href="#cb57-121" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb57-122"><a href="#cb57-122" aria-hidden="true" tabindex="-1"></a>            bufferNew<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="va">ptr_</span><span class="op">[</span>i<span class="op">];</span></span>
<span id="cb57-123"><a href="#cb57-123" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb57-124"><a href="#cb57-124" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-125"><a href="#cb57-125" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span><span class="va">ptr_</span> <span class="op">!=</span> <span class="kw">nullptr</span><span class="op">)</span></span>
<span id="cb57-126"><a href="#cb57-126" aria-hidden="true" tabindex="-1"></a>            <span class="kw">delete</span><span class="op">[]</span> <span class="va">ptr_</span><span class="op">;</span></span>
<span id="cb57-127"><a href="#cb57-127" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-128"><a href="#cb57-128" aria-hidden="true" tabindex="-1"></a>        <span class="va">ptr_</span> <span class="op">=</span> bufferNew<span class="op">;</span></span>
<span id="cb57-129"><a href="#cb57-129" aria-hidden="true" tabindex="-1"></a>        <span class="va">capacity_</span> <span class="op">=</span> size<span class="op">;</span></span>
<span id="cb57-130"><a href="#cb57-130" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb57-131"><a href="#cb57-131" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-132"><a href="#cb57-132" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> clear<span class="op">()</span></span>
<span id="cb57-133"><a href="#cb57-133" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb57-134"><a href="#cb57-134" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span><span class="va">ptr_</span> <span class="op">!=</span> <span class="kw">nullptr</span><span class="op">)</span></span>
<span id="cb57-135"><a href="#cb57-135" aria-hidden="true" tabindex="-1"></a>            <span class="kw">delete</span><span class="op">[]</span> <span class="va">ptr_</span><span class="op">;</span></span>
<span id="cb57-136"><a href="#cb57-136" aria-hidden="true" tabindex="-1"></a>        <span class="va">ptr_</span> <span class="op">=</span> <span class="kw">nullptr</span><span class="op">;</span></span>
<span id="cb57-137"><a href="#cb57-137" aria-hidden="true" tabindex="-1"></a>        <span class="va">size_</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb57-138"><a href="#cb57-138" aria-hidden="true" tabindex="-1"></a>        <span class="va">capacity_</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb57-139"><a href="#cb57-139" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb57-140"><a href="#cb57-140" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-141"><a href="#cb57-141" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> size<span class="op">()</span> <span class="at">const</span></span>
<span id="cb57-142"><a href="#cb57-142" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb57-143"><a href="#cb57-143" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">size_</span><span class="op">;</span></span>
<span id="cb57-144"><a href="#cb57-144" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb57-145"><a href="#cb57-145" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-146"><a href="#cb57-146" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> capacity<span class="op">()</span></span>
<span id="cb57-147"><a href="#cb57-147" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb57-148"><a href="#cb57-148" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">capacity_</span><span class="op">;</span></span>
<span id="cb57-149"><a href="#cb57-149" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb57-150"><a href="#cb57-150" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-151"><a href="#cb57-151" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> push_back<span class="op">(</span><span class="at">const</span> T<span class="op">&amp;</span> elem<span class="op">)</span></span>
<span id="cb57-152"><a href="#cb57-152" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb57-153"><a href="#cb57-153" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span><span class="va">size_</span> <span class="op">&gt;=</span> <span class="va">capacity_</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb57-154"><a href="#cb57-154" aria-hidden="true" tabindex="-1"></a>            reserve<span class="op">(</span><span class="va">capacity_</span> <span class="op">+</span> <span class="dv">5</span><span class="op">);</span> <span class="co">// Double the capacity</span></span>
<span id="cb57-155"><a href="#cb57-155" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb57-156"><a href="#cb57-156" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-157"><a href="#cb57-157" aria-hidden="true" tabindex="-1"></a>        <span class="va">ptr_</span><span class="op">[</span><span class="va">size_</span><span class="op">++]</span> <span class="op">=</span> elem<span class="op">;</span></span>
<span id="cb57-158"><a href="#cb57-158" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb57-159"><a href="#cb57-159" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-160"><a href="#cb57-160" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> pop_back<span class="op">()</span></span>
<span id="cb57-161"><a href="#cb57-161" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb57-162"><a href="#cb57-162" aria-hidden="true" tabindex="-1"></a>        <span class="op">--</span><span class="va">size_</span><span class="op">;</span></span>
<span id="cb57-163"><a href="#cb57-163" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb57-164"><a href="#cb57-164" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-165"><a href="#cb57-165" aria-hidden="true" tabindex="-1"></a>    T front<span class="op">()</span></span>
<span id="cb57-166"><a href="#cb57-166" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb57-167"><a href="#cb57-167" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span><span class="va">size_</span> <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb57-168"><a href="#cb57-168" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">ptr_</span><span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb57-169"><a href="#cb57-169" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span></span>
<span id="cb57-170"><a href="#cb57-170" aria-hidden="true" tabindex="-1"></a>            <span class="cf">throw</span> <span class="bu">std::</span>out_of_range<span class="op">(</span><span class="st">"Index out of bounds."</span><span class="op">);</span></span>
<span id="cb57-171"><a href="#cb57-171" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb57-172"><a href="#cb57-172" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-173"><a href="#cb57-173" aria-hidden="true" tabindex="-1"></a>    T back<span class="op">()</span></span>
<span id="cb57-174"><a href="#cb57-174" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb57-175"><a href="#cb57-175" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span><span class="va">size_</span> <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb57-176"><a href="#cb57-176" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">ptr_</span><span class="op">[</span><span class="va">size_</span> <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb57-177"><a href="#cb57-177" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span></span>
<span id="cb57-178"><a href="#cb57-178" aria-hidden="true" tabindex="-1"></a>            <span class="cf">throw</span> <span class="bu">std::</span>out_of_range<span class="op">(</span><span class="st">"Index out of bounds."</span><span class="op">);</span></span>
<span id="cb57-179"><a href="#cb57-179" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb57-180"><a href="#cb57-180" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-181"><a href="#cb57-181" aria-hidden="true" tabindex="-1"></a>    T<span class="op">*</span> getRawPointer<span class="op">()</span></span>
<span id="cb57-182"><a href="#cb57-182" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb57-183"><a href="#cb57-183" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">ptr_</span><span class="op">;</span></span>
<span id="cb57-184"><a href="#cb57-184" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb57-185"><a href="#cb57-185" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb57-186"><a href="#cb57-186" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-187"><a href="#cb57-187" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb57-188"><a href="#cb57-188" aria-hidden="true" tabindex="-1"></a>Vector<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="kw">operator</span><span class="op">+(</span><span class="at">const</span> Vector<span class="op">&lt;</span>T<span class="op">&gt;&amp;</span> v1<span class="op">,</span> <span class="at">const</span> Vector<span class="op">&lt;</span>T<span class="op">&gt;&amp;</span> v2<span class="op">)</span></span>
<span id="cb57-189"><a href="#cb57-189" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb57-190"><a href="#cb57-190" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>v1<span class="op">.</span>size<span class="op">()</span> <span class="op">!=</span> v2<span class="op">.</span>size<span class="op">())</span></span>
<span id="cb57-191"><a href="#cb57-191" aria-hidden="true" tabindex="-1"></a>        <span class="cf">throw</span> <span class="bu">std::</span>logic_error<span class="op">(</span><span class="st">"Vector lengths must be equal."</span><span class="op">);</span></span>
<span id="cb57-192"><a href="#cb57-192" aria-hidden="true" tabindex="-1"></a>    Vector<span class="op">&lt;</span>T<span class="op">&gt;</span> result<span class="op">;</span></span>
<span id="cb57-193"><a href="#cb57-193" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i<span class="op">{</span> <span class="dv">0</span> <span class="op">};</span> i <span class="op">&lt;</span> v1<span class="op">.</span>size<span class="op">();</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb57-194"><a href="#cb57-194" aria-hidden="true" tabindex="-1"></a>        result<span class="op">.</span>push_back<span class="op">(</span>v1<span class="op">[</span>i<span class="op">]</span> <span class="op">+</span> v2<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb57-195"><a href="#cb57-195" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-196"><a href="#cb57-196" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result<span class="op">;</span></span>
<span id="cb57-197"><a href="#cb57-197" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb57-198"><a href="#cb57-198" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-199"><a href="#cb57-199" aria-hidden="true" tabindex="-1"></a>Vector<span class="op">&lt;</span>Vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;</span> createAndInsert<span class="op">()</span></span>
<span id="cb57-200"><a href="#cb57-200" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb57-201"><a href="#cb57-201" aria-hidden="true" tabindex="-1"></a>    Vector<span class="op">&lt;</span>Vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;</span> pts<span class="op">;</span></span>
<span id="cb57-202"><a href="#cb57-202" aria-hidden="true" tabindex="-1"></a>    pts<span class="op">.</span>reserve<span class="op">(</span><span class="dv">3</span><span class="op">);</span></span>
<span id="cb57-203"><a href="#cb57-203" aria-hidden="true" tabindex="-1"></a>    Vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> x<span class="op">{</span> <span class="fl">1.0</span><span class="op">,</span> <span class="fl">1.0</span> <span class="op">};</span></span>
<span id="cb57-204"><a href="#cb57-204" aria-hidden="true" tabindex="-1"></a>    pts<span class="op">.</span>push_back<span class="op">(</span>x<span class="op">);</span></span>
<span id="cb57-205"><a href="#cb57-205" aria-hidden="true" tabindex="-1"></a>    pts<span class="op">.</span>push_back<span class="op">(</span>x <span class="op">+</span> x<span class="op">);</span></span>
<span id="cb57-206"><a href="#cb57-206" aria-hidden="true" tabindex="-1"></a>    pts<span class="op">.</span>push_back<span class="op">(</span>x<span class="op">);</span></span>
<span id="cb57-207"><a href="#cb57-207" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> pts<span class="op">;</span></span>
<span id="cb57-208"><a href="#cb57-208" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb57-209"><a href="#cb57-209" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-210"><a href="#cb57-210" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb57-211"><a href="#cb57-211" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb57-212"><a href="#cb57-212" aria-hidden="true" tabindex="-1"></a>    Vector<span class="op">&lt;</span>Vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;</span> result <span class="op">=</span> createAndInsert<span class="op">();</span></span>
<span id="cb57-213"><a href="#cb57-213" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb57-214"><a href="#cb57-214" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb57-215"><a href="#cb57-215" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb57-216"><a href="#cb57-216" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-217"><a href="#cb57-217" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">Compiler Explorer</span><span class="co">](https://godbolt.org/z/hEMKd99s5)</span></span>
<span id="cb57-218"><a href="#cb57-218" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-219"><a href="#cb57-219" aria-hidden="true" tabindex="-1"></a>Let us look at the individual steps of the program (inspecting both stack and the heap) when we compile this program with a C++ compiler.</span>
<span id="cb57-220"><a href="#cb57-220" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-221"><a href="#cb57-221" aria-hidden="true" tabindex="-1"></a>First in <span class="in">`main`</span>, we create the empty vector <span class="in">`pts`</span> which will be used to store points in the euclidean space $\mathbf{R}^2$:</span>
<span id="cb57-222"><a href="#cb57-222" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-223"><a href="#cb57-223" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb57-224"><a href="#cb57-224" aria-hidden="true" tabindex="-1"></a><span class="in">Vector&lt;Vector&lt;double&gt;&gt; pts;</span></span>
<span id="cb57-225"><a href="#cb57-225" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb57-226"><a href="#cb57-226" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-227"><a href="#cb57-227" aria-hidden="true" tabindex="-1"></a>which is placed on the stack as an object that has <span class="in">`size_ = 0`</span>, <span class="in">`capacity_ = 0`</span> and no memory allocated for elements.</span>
<span id="cb57-228"><a href="#cb57-228" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-229"><a href="#cb57-229" aria-hidden="true" tabindex="-1"></a>Then, we call </span>
<span id="cb57-230"><a href="#cb57-230" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-231"><a href="#cb57-231" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb57-232"><a href="#cb57-232" aria-hidden="true" tabindex="-1"></a><span class="in">pts.reserve(3);</span></span>
<span id="cb57-233"><a href="#cb57-233" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb57-234"><a href="#cb57-234" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-235"><a href="#cb57-235" aria-hidden="true" tabindex="-1"></a>This allocates memory for <span class="in">`3`</span> elements on the heap. The member <span class="in">`pts_-&gt;capacity_`</span> equals <span class="in">`3`</span>, <span class="in">`pts-&gt;size_`</span> equals <span class="in">`0`</span> and <span class="in">`pts_-&gt;ptr_`</span> contains the address to heap block. The allocated memory is not initialized, because the number of elements is still <span class="in">`0`</span>.</span>
<span id="cb57-236"><a href="#cb57-236" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-237"><a href="#cb57-237" aria-hidden="true" tabindex="-1"></a>Then, we create a $2$-tuple to hold the cartesian coordinates of a point $(1.0,1.0)$. We create a <span class="in">`Vector&lt;double&gt;`</span> initialized to <span class="in">`{1.0,1.0}`</span>. Essentially, we create an object <span class="in">`x`</span> on the stack with its members <span class="in">`x-&gt;size_ = 2`</span>, <span class="in">`x-&gt;capacity_ = 5`</span> and a pointer <span class="in">`x-&gt;ptr_`</span> containing the address of newly allocated memory on the heap for <span class="in">`5`</span> elements. Further, <span class="in">`x-&gt;ptr_[0]=1.0`</span>, <span class="in">`x-&gt;ptr_[1]=1.0`</span>. </span>
<span id="cb57-238"><a href="#cb57-238" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-239"><a href="#cb57-239" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb57-240"><a href="#cb57-240" aria-hidden="true" tabindex="-1"></a><span class="in">Vector&lt;double&gt; x{1.0, 1.0};</span></span>
<span id="cb57-241"><a href="#cb57-241" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb57-242"><a href="#cb57-242" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-243"><a href="#cb57-243" aria-hidden="true" tabindex="-1"></a>After this statement, the program has the following state: we have two objects on the stack : <span class="in">`pts`</span> and <span class="in">`x`</span>. Both of them have memory allocated on the heap. </span>
<span id="cb57-244"><a href="#cb57-244" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-245"><a href="#cb57-245" aria-hidden="true" tabindex="-1"></a><span class="al">![Checkpoint #1](move_semantics_00.png)</span></span>
<span id="cb57-246"><a href="#cb57-246" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-247"><a href="#cb57-247" aria-hidden="true" tabindex="-1"></a>The next step is the command to insert <span class="in">`x`</span> into the <span class="in">`pts`</span> vector. </span>
<span id="cb57-248"><a href="#cb57-248" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-249"><a href="#cb57-249" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb57-250"><a href="#cb57-250" aria-hidden="true" tabindex="-1"></a><span class="in">pts.push_back(x);</span></span>
<span id="cb57-251"><a href="#cb57-251" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb57-252"><a href="#cb57-252" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-253"><a href="#cb57-253" aria-hidden="true" tabindex="-1"></a>My toy <span class="in">`Vector`</span> class is said to have value semantics, which means it creates copies of the values passed to it. As a result, we get a first element in the vector, which is a full(deep) copy of the passed value/object <span class="in">`x`</span>:</span>
<span id="cb57-254"><a href="#cb57-254" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-255"><a href="#cb57-255" aria-hidden="true" tabindex="-1"></a><span class="al">![Checkpoint #2](move_semantics_01.png)</span></span>
<span id="cb57-256"><a href="#cb57-256" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-257"><a href="#cb57-257" aria-hidden="true" tabindex="-1"></a>The current state is that we have a vector <span class="in">`pts`</span> and two copies of <span class="in">`x={1.0,1.0}`</span>, one of which is the first element in <span class="in">`pts`</span>. </span>
<span id="cb57-258"><a href="#cb57-258" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-259"><a href="#cb57-259" aria-hidden="true" tabindex="-1"></a>Let's now look at the next statement, which creates a new temporary vector and again inserts it into the <span class="in">`pts`</span> vector:</span>
<span id="cb57-260"><a href="#cb57-260" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-261"><a href="#cb57-261" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb57-262"><a href="#cb57-262" aria-hidden="true" tabindex="-1"></a><span class="in">pts.push_back(x + x);</span></span>
<span id="cb57-263"><a href="#cb57-263" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb57-264"><a href="#cb57-264" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-265"><a href="#cb57-265" aria-hidden="true" tabindex="-1"></a>This statement is performed in three steps:</span>
<span id="cb57-266"><a href="#cb57-266" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-267"><a href="#cb57-267" aria-hidden="true" tabindex="-1"></a>*Step 1*. We create a temporary <span class="in">`Vector&lt;double&gt;`</span> object <span class="in">`x + x`</span>. </span>
<span id="cb57-268"><a href="#cb57-268" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-269"><a href="#cb57-269" aria-hidden="true" tabindex="-1"></a><span class="al">![Step #1](move_semantics_02.png)</span></span>
<span id="cb57-270"><a href="#cb57-270" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-271"><a href="#cb57-271" aria-hidden="true" tabindex="-1"></a>*Step 2*.  <span class="in">`x+x`</span> is a temporary.  The <span class="in">`Vector&lt;T&gt;::push_back(const T&amp;)`</span> function accepts a reference-to-<span class="in">`const`</span> as an argument. Since <span class="in">`x+x`</span> is a temporary, it cannot be modified and binds to a reference-to-<span class="in">`const`</span>. Moreover, being a temporary object, it is likely to die soon. Referencing it extends the lifetime of the temporary <span class="in">`x + x={2.0,2.0}`</span>. </span>
<span id="cb57-272"><a href="#cb57-272" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-273"><a href="#cb57-273" aria-hidden="true" tabindex="-1"></a>Now, the statement <span class="in">`pts_[size++] = elem`</span> will invoke the copy-assignment operator on the yet uninitialized second element  <span class="in">`pts[1]`</span> which is of type <span class="in">`Vector&lt;double&gt;`</span>. This will force a full (deep) copy of <span class="in">`x + x={2.0,2.0}`</span>. At this time, two copies of <span class="in">`{2.0,2.0}`</span>  exist on the heap. One of these is assigned to <span class="in">`pts[1]`</span>. </span>
<span id="cb57-274"><a href="#cb57-274" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-275"><a href="#cb57-275" aria-hidden="true" tabindex="-1"></a><span class="al">![Step #2](move_semantics_03.png)</span></span>
<span id="cb57-276"><a href="#cb57-276" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-277"><a href="#cb57-277" aria-hidden="true" tabindex="-1"></a>*Step 3*. When <span class="in">`push_back(const T&amp;)`</span> returns, the temporary <span class="in">`x + x`</span> will die and its destructor is called and the memory allocated on the heap is freed. You can see this on <span class="co">[</span><span class="ot">cppinsights</span><span class="co">](https://cppinsights.io/s/3f814c34)</span>.</span>
<span id="cb57-278"><a href="#cb57-278" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-279"><a href="#cb57-279" aria-hidden="true" tabindex="-1"></a>Our code is clearly not performing well: we create a copy of the temporary <span class="in">`x + x`</span> and destroy the source of the copy immediately afterwards, which means we unnecessarily allocate and free memory that we could have just moved from source to the copy.</span>
<span id="cb57-280"><a href="#cb57-280" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-281"><a href="#cb57-281" aria-hidden="true" tabindex="-1"></a><span class="al">![Step #3](move_semantics_04.png)</span></span>
<span id="cb57-282"><a href="#cb57-282" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-283"><a href="#cb57-283" aria-hidden="true" tabindex="-1"></a>With the next statement, again we insert <span class="in">`x`</span> into <span class="in">`pts`</span>:</span>
<span id="cb57-284"><a href="#cb57-284" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-285"><a href="#cb57-285" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb57-286"><a href="#cb57-286" aria-hidden="true" tabindex="-1"></a><span class="in">pts.push_back(x)</span></span>
<span id="cb57-287"><a href="#cb57-287" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb57-288"><a href="#cb57-288" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-289"><a href="#cb57-289" aria-hidden="true" tabindex="-1"></a>Again, <span class="in">`pts`</span> copies <span class="in">`x`</span>.</span>
<span id="cb57-290"><a href="#cb57-290" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-291"><a href="#cb57-291" aria-hidden="true" tabindex="-1"></a><span class="al">![Checkpoint #3](move_semantics_05.png)</span></span>
<span id="cb57-292"><a href="#cb57-292" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-293"><a href="#cb57-293" aria-hidden="true" tabindex="-1"></a>This is also something to improve. Because the value of <span class="in">`x`</span> is no longer needed, some optimization could use the memory of <span class="in">`x`</span> as the memory for the new element instead. </span>
<span id="cb57-294"><a href="#cb57-294" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-295"><a href="#cb57-295" aria-hidden="true" tabindex="-1"></a>At the end of <span class="in">`createAndInsert()`</span> we come to the return statement:</span>
<span id="cb57-296"><a href="#cb57-296" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-297"><a href="#cb57-297" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb57-298"><a href="#cb57-298" aria-hidden="true" tabindex="-1"></a><span class="in">return pts;</span></span>
<span id="cb57-299"><a href="#cb57-299" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb57-300"><a href="#cb57-300" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-301"><a href="#cb57-301" aria-hidden="true" tabindex="-1"></a>Here, the behaviour of the program is a bit more complicated. We return by value (the return type is not a reference), which should be a copy of the value in the <span class="in">`return`</span> statement. Creating a copy of <span class="in">`pts`</span> means that we have create a deep copy of the whole vector with all of its elements. Thus, we have to allocate heap memory for the array of elements in the <span class="in">`pts`</span> and heap memory for the value of each 2-tuple. Here, we would have to allocate memory 4 times.</span>
<span id="cb57-302"><a href="#cb57-302" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-303"><a href="#cb57-303" aria-hidden="true" tabindex="-1"></a>However, since at the same time <span class="in">`pts`</span> is destroyed because we leave the scope where it is declared, the compiler is allowed to perform *named return value optimization (NRVO)*. This means that the compiler can generate code so that <span class="in">`pts`</span> is used as the return value.  </span>
<span id="cb57-304"><a href="#cb57-304" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-305"><a href="#cb57-305" aria-hidden="true" tabindex="-1"></a>Let us assume that we have the named return value optimization. In that case, at the end of the <span class="in">`return`</span> statement, <span class="in">`pts`</span> simply becomes the return value and the destructor of <span class="in">`x`</span> is called, which frees the memory allocated when it was declared.</span>
<span id="cb57-306"><a href="#cb57-306" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-307"><a href="#cb57-307" aria-hidden="true" tabindex="-1"></a><span class="al">![Return statement](move_semantics_06.png)</span></span>
<span id="cb57-308"><a href="#cb57-308" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-309"><a href="#cb57-309" aria-hidden="true" tabindex="-1"></a>Finally, we come to the assignment of the return value to <span class="in">`result`</span>:</span>
<span id="cb57-310"><a href="#cb57-310" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-311"><a href="#cb57-311" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb57-312"><a href="#cb57-312" aria-hidden="true" tabindex="-1"></a><span class="in">result = createAndInsert()</span></span>
<span id="cb57-313"><a href="#cb57-313" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb57-314"><a href="#cb57-314" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-315"><a href="#cb57-315" aria-hidden="true" tabindex="-1"></a>Here, we really get behavior that can be improved: the usual assignment operator has the goal of giving <span class="in">`result`</span> the same value as the source value that is assigned. In general, any source(assigned) value should not be modified and should independent from the object that the value was assigned to. So, the assignment operator will create a deep-copy of the whole return value:</span>
<span id="cb57-316"><a href="#cb57-316" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-317"><a href="#cb57-317" aria-hidden="true" tabindex="-1"></a><span class="al">![Return statement](move_semantics_07.png)</span></span>
<span id="cb57-318"><a href="#cb57-318" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-319"><a href="#cb57-319" aria-hidden="true" tabindex="-1"></a>However, right after that we no longer need the temporary return value and we destroy it:</span>
<span id="cb57-320"><a href="#cb57-320" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-321"><a href="#cb57-321" aria-hidden="true" tabindex="-1"></a>Again, we create a copy of a temporary object and destroy the source of the copy immediately afterwards, which means that we again unnecessarily allocate and free memory. This time it applies to four allocations</span>
<span id="cb57-322"><a href="#cb57-322" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-323"><a href="#cb57-323" aria-hidden="true" tabindex="-1"></a>For the state of the program after this assignment in <span class="in">`main()`</span>, we allocated memory numerous times and released it. Unnecessary memory allocations were caused by:</span>
<span id="cb57-324"><a href="#cb57-324" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-325"><a href="#cb57-325" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Inserting a temporary object into <span class="in">`pts`</span>.</span>
<span id="cb57-326"><a href="#cb57-326" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Inserting an object into <span class="in">`pts`</span> where we no longer need the value.</span>
<span id="cb57-327"><a href="#cb57-327" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Assigning a temporary vector with all its elements.</span>
<span id="cb57-328"><a href="#cb57-328" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-329"><a href="#cb57-329" aria-hidden="true" tabindex="-1"></a>We can more or less avoid these performance pennalties. </span>
<span id="cb57-330"><a href="#cb57-330" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-331"><a href="#cb57-331" aria-hidden="true" tabindex="-1"></a><span class="fu">## Copy elison</span></span>
<span id="cb57-332"><a href="#cb57-332" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-333"><a href="#cb57-333" aria-hidden="true" tabindex="-1"></a>Copy-elison is based on the fact that the compiler is allowed to follow the <span class="co">[</span><span class="ot">as-if</span><span class="co">](https://en.cppreference.com/w/cpp/language/as_if)</span> rule. The compiler is allowed to generate any code which has the same effect as the code you told it to add. The standard actually says, that if the compiler is told to copy something, but the copy is not really necessary, because the original is not going to be used again, then the compiler is allowed to elide(omit) the copy. The compiler is allowed to elide copies, where the results are *as-if* copies were made.</span>
<span id="cb57-334"><a href="#cb57-334" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-335"><a href="#cb57-335" aria-hidden="true" tabindex="-1"></a>Consider the function below:</span>
<span id="cb57-336"><a href="#cb57-336" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-337"><a href="#cb57-337" aria-hidden="true" tabindex="-1"></a><span class="in">```cpp</span></span>
<span id="cb57-338"><a href="#cb57-338" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-339"><a href="#cb57-339" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cmath&gt;</span></span>
<span id="cb57-340"><a href="#cb57-340" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> discountFactor<span class="op">(</span><span class="dt">double</span> r<span class="op">,</span> <span class="dt">double</span> t<span class="op">){</span></span>
<span id="cb57-341"><a href="#cb57-341" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> result <span class="op">=</span> exp<span class="op">(-</span>r <span class="op">*</span> t<span class="op">);</span></span>
<span id="cb57-342"><a href="#cb57-342" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result<span class="op">;</span></span>
<span id="cb57-343"><a href="#cb57-343" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb57-344"><a href="#cb57-344" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-345"><a href="#cb57-345" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb57-346"><a href="#cb57-346" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb57-347"><a href="#cb57-347" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> df <span class="op">{</span>discountFactor<span class="op">(</span><span class="fl">0.05</span><span class="op">,</span> <span class="fl">1.00</span><span class="op">)};</span></span>
<span id="cb57-348"><a href="#cb57-348" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb57-349"><a href="#cb57-349" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb57-350"><a href="#cb57-350" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb57-351"><a href="#cb57-351" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-352"><a href="#cb57-352" aria-hidden="true" tabindex="-1"></a>How many parameters are passed to the function <span class="in">`discountFactor(double, double)`</span>? C++ programmers answer $2$, assembly-language programmers answer $3$. Why? At a low-level, when we have a return-value, we have to tell the generated code, where to put the return value. The function is passed the address where the results should be written.</span>
<span id="cb57-353"><a href="#cb57-353" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-354"><a href="#cb57-354" aria-hidden="true" tabindex="-1"></a>Alright, so this is what's going on. Our function <span class="in">`main()`</span> is going to call <span class="in">`discountFactor(double, double)`</span> in order to populate a local <span class="in">`df`</span>. The stack frame for the function <span class="in">`main()`</span> looks like this:</span>
<span id="cb57-355"><a href="#cb57-355" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-356"><a href="#cb57-356" aria-hidden="true" tabindex="-1"></a><span class="al">![Stack frame for main()](move_semantics_08.png)</span></span>
<span id="cb57-357"><a href="#cb57-357" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-358"><a href="#cb57-358" aria-hidden="true" tabindex="-1"></a>Now, we are going to call the function <span class="in">`discountFactor(double, double)`</span>. When we call <span class="in">`discountFactor(double, double)`</span>, we have to create the stack-frame for <span class="in">`discountFactor(double, double)`</span>.</span>
<span id="cb57-359"><a href="#cb57-359" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-360"><a href="#cb57-360" aria-hidden="true" tabindex="-1"></a><span class="al">![Call to discountFactor()](move_semantics_09.png)</span></span>
<span id="cb57-361"><a href="#cb57-361" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-362"><a href="#cb57-362" aria-hidden="true" tabindex="-1"></a>Okay, now we execute the function <span class="in">`discountFactor(double, double)`</span> and now the return value is now stored directly at the address given by <span class="in">`&amp;df`</span>. </span>
<span id="cb57-363"><a href="#cb57-363" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-364"><a href="#cb57-364" aria-hidden="true" tabindex="-1"></a><span class="al">![Return statement](move_semantics_10.png)</span></span>
<span id="cb57-365"><a href="#cb57-365" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-366"><a href="#cb57-366" aria-hidden="true" tabindex="-1"></a>So, this is going to elide the copy. This form of copy elison is called *Return Value Optimization*(RVO). The calling function allocates space for the return value on the stack, and passes the address of that memory to the callee. The callee can then construct a return value directly into that space, which eliminates the need to copy from the inside to the outside.</span>
<span id="cb57-367"><a href="#cb57-367" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-368"><a href="#cb57-368" aria-hidden="true" tabindex="-1"></a>Also, although the compiler is normally required to make a copy when a function parameter is passed by value (so modifications to the parameter inside the function can’t affect the caller), it is allowed to elide the copy, when the source is a temporary.</span>
<span id="cb57-369"><a href="#cb57-369" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-370"><a href="#cb57-370" aria-hidden="true" tabindex="-1"></a><span class="in">```cpp</span></span>
<span id="cb57-371"><a href="#cb57-371" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f<span class="op">(</span><span class="bu">std::</span>string a<span class="op">)</span></span>
<span id="cb57-372"><a href="#cb57-372" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb57-373"><a href="#cb57-373" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> b<span class="op">{</span><span class="dv">123</span><span class="op">};</span></span>
<span id="cb57-374"><a href="#cb57-374" aria-hidden="true" tabindex="-1"></a>    <span class="co">//some code</span></span>
<span id="cb57-375"><a href="#cb57-375" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span><span class="op">;</span></span>
<span id="cb57-376"><a href="#cb57-376" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb57-377"><a href="#cb57-377" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-378"><a href="#cb57-378" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> g<span class="op">()</span></span>
<span id="cb57-379"><a href="#cb57-379" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb57-380"><a href="#cb57-380" aria-hidden="true" tabindex="-1"></a>    f<span class="op">(</span><span class="bu">std::</span>string<span class="op">(</span><span class="st">"A"</span><span class="op">));</span></span>
<span id="cb57-381"><a href="#cb57-381" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> y<span class="op">;</span></span>
<span id="cb57-382"><a href="#cb57-382" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb57-383"><a href="#cb57-383" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb57-384"><a href="#cb57-384" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-385"><a href="#cb57-385" aria-hidden="true" tabindex="-1"></a>This is how it actually works. We are going to create our temporary - the string <span class="in">`"A"`</span> in the place, where we would have actually copied it, that is, in the local variable <span class="in">`a`</span> in the stack frame of <span class="in">`f(std::string)`</span>. </span>
<span id="cb57-386"><a href="#cb57-386" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-387"><a href="#cb57-387" aria-hidden="true" tabindex="-1"></a><span class="fu">## Copy and swap idiom</span></span>
<span id="cb57-388"><a href="#cb57-388" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-389"><a href="#cb57-389" aria-hidden="true" tabindex="-1"></a>Any class which manages resources (a wrapper like a *smart pointer*) needs to implement <span class="co">[</span><span class="ot">The Big Three</span><span class="co">](https://stackoverflow.com/questions/4172722/what-is-the-rule-of-three)</span>. While the goals of the copy constructor and destructor are straightforward, the copy-assignment operator is arguably the most nuanced and difficult. What pitfalls need to be avoided?</span>
<span id="cb57-390"><a href="#cb57-390" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-391"><a href="#cb57-391" aria-hidden="true" tabindex="-1"></a>Consider our naive implementation of the assignment operator:</span>
<span id="cb57-392"><a href="#cb57-392" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-393"><a href="#cb57-393" aria-hidden="true" tabindex="-1"></a><span class="in">```cpp</span></span>
<span id="cb57-394"><a href="#cb57-394" aria-hidden="true" tabindex="-1"></a><span class="co">//Copy assignment operator</span></span>
<span id="cb57-395"><a href="#cb57-395" aria-hidden="true" tabindex="-1"></a>Vector<span class="op">&lt;</span>T<span class="op">&gt;&amp;</span> <span class="kw">operator</span><span class="op">=(</span><span class="at">const</span> Vector<span class="op">&lt;</span>T<span class="op">&gt;&amp;</span> v<span class="op">)</span></span>
<span id="cb57-396"><a href="#cb57-396" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb57-397"><a href="#cb57-397" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span><span class="kw">this</span> <span class="op">!=</span> <span class="op">&amp;</span>v<span class="op">)</span>     <span class="co">//(1)</span></span>
<span id="cb57-398"><a href="#cb57-398" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb57-399"><a href="#cb57-399" aria-hidden="true" tabindex="-1"></a>        <span class="kw">delete</span><span class="op">[]</span> <span class="va">ptr_</span><span class="op">;</span>  <span class="co">//(2)</span></span>
<span id="cb57-400"><a href="#cb57-400" aria-hidden="true" tabindex="-1"></a>        <span class="va">ptr_</span> <span class="op">=</span> <span class="kw">nullptr</span><span class="op">;</span></span>
<span id="cb57-401"><a href="#cb57-401" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-402"><a href="#cb57-402" aria-hidden="true" tabindex="-1"></a>        <span class="va">capacity_</span> <span class="op">=</span> v<span class="op">.</span><span class="va">capacity_</span><span class="op">;</span>    <span class="co">//(2)</span></span>
<span id="cb57-403"><a href="#cb57-403" aria-hidden="true" tabindex="-1"></a>        <span class="va">size_</span> <span class="op">=</span> v<span class="op">.</span><span class="va">size_</span><span class="op">;</span>            <span class="co">//(2)</span></span>
<span id="cb57-404"><a href="#cb57-404" aria-hidden="true" tabindex="-1"></a>        <span class="va">ptr_</span> <span class="op">=</span> <span class="kw">new</span> T<span class="op">[</span><span class="va">capacity_</span><span class="op">];</span>    <span class="co">//(2)</span></span>
<span id="cb57-405"><a href="#cb57-405" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-406"><a href="#cb57-406" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i<span class="op">{</span> <span class="dv">0</span> <span class="op">};</span> i <span class="op">&lt;</span> v<span class="op">.</span><span class="va">size_</span><span class="op">;</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb57-407"><a href="#cb57-407" aria-hidden="true" tabindex="-1"></a>            <span class="va">ptr_</span><span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> v<span class="op">.</span><span class="va">ptr_</span><span class="op">[</span>i<span class="op">];</span>                <span class="co">//(3)</span></span>
<span id="cb57-408"><a href="#cb57-408" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb57-409"><a href="#cb57-409" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-410"><a href="#cb57-410" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">*</span><span class="kw">this</span><span class="op">;</span></span>
<span id="cb57-411"><a href="#cb57-411" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb57-412"><a href="#cb57-412" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb57-413"><a href="#cb57-413" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-414"><a href="#cb57-414" aria-hidden="true" tabindex="-1"></a>While this manages the heap memory without leaks, it suffers from three problems, marked sequentially in the code as <span class="in">`(n)`</span>.</span>
<span id="cb57-415"><a href="#cb57-415" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-416"><a href="#cb57-416" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>The first is the self-assignment test. This check is an easy way to prevent us from running needless code on self-assignment. But, in all other cases, it merely serves to slow down the program and acts as noise in the code; self-assignment rarely occurs, so most of the time this check is a waste.</span>
<span id="cb57-417"><a href="#cb57-417" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>The seond is, it only provides a basic exception guarantee. If <span class="in">`new T[capacity_]`</span> fails, <span class="in">`*this`</span> will have been modified. Namely, the <span class="in">`size_`</span> and <span class="in">`capacity_`</span> are wrong and the old data referenced by <span class="in">`ptr_`</span> is gone! For a strong exception guarantee, we need something akin to:</span>
<span id="cb57-418"><a href="#cb57-418" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-419"><a href="#cb57-419" aria-hidden="true" tabindex="-1"></a><span class="in">```cpp</span></span>
<span id="cb57-420"><a href="#cb57-420" aria-hidden="true" tabindex="-1"></a><span class="co">//Copy assignment operator</span></span>
<span id="cb57-421"><a href="#cb57-421" aria-hidden="true" tabindex="-1"></a>Vector<span class="op">&lt;</span>T<span class="op">&gt;&amp;</span> <span class="kw">operator</span><span class="op">=(</span><span class="at">const</span> Vector<span class="op">&lt;</span>T<span class="op">&gt;&amp;</span> v<span class="op">)</span></span>
<span id="cb57-422"><a href="#cb57-422" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb57-423"><a href="#cb57-423" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span><span class="kw">this</span> <span class="op">!=</span> <span class="op">&amp;</span>v<span class="op">)</span>     <span class="co">//(1)</span></span>
<span id="cb57-424"><a href="#cb57-424" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb57-425"><a href="#cb57-425" aria-hidden="true" tabindex="-1"></a>        <span class="co">// get the new data ready, before we replace the old data</span></span>
<span id="cb57-426"><a href="#cb57-426" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> newCapacity <span class="op">=</span> v<span class="op">.</span><span class="va">capacity_</span><span class="op">;</span></span>
<span id="cb57-427"><a href="#cb57-427" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> newSize <span class="op">=</span> v<span class="op">.</span><span class="va">size_</span><span class="op">;</span></span>
<span id="cb57-428"><a href="#cb57-428" aria-hidden="true" tabindex="-1"></a>        T<span class="op">*</span> <span class="va">newPtr_</span> <span class="op">=</span> <span class="kw">new</span> T<span class="op">[</span>newCapacity<span class="op">]();</span>  <span class="co">//(2)</span></span>
<span id="cb57-429"><a href="#cb57-429" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-430"><a href="#cb57-430" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i<span class="op">{</span> <span class="dv">0</span> <span class="op">};</span> i <span class="op">&lt;</span> v<span class="op">.</span><span class="va">size_</span><span class="op">;</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb57-431"><a href="#cb57-431" aria-hidden="true" tabindex="-1"></a>            <span class="va">newPtr_</span><span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> v<span class="op">.</span><span class="va">ptr_</span><span class="op">[</span>i<span class="op">];</span>         <span class="co">//(3)</span></span>
<span id="cb57-432"><a href="#cb57-432" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-433"><a href="#cb57-433" aria-hidden="true" tabindex="-1"></a>        <span class="co">//replace the old data (all are non-throwing)</span></span>
<span id="cb57-434"><a href="#cb57-434" aria-hidden="true" tabindex="-1"></a>        <span class="kw">delete</span><span class="op">[]</span> <span class="va">ptr_</span><span class="op">;</span></span>
<span id="cb57-435"><a href="#cb57-435" aria-hidden="true" tabindex="-1"></a>        <span class="va">size_</span> <span class="op">=</span> newSize<span class="op">;</span>       </span>
<span id="cb57-436"><a href="#cb57-436" aria-hidden="true" tabindex="-1"></a>        <span class="va">capacity_</span> <span class="op">=</span> <span class="va">newCapacity_</span><span class="op">;</span>           </span>
<span id="cb57-437"><a href="#cb57-437" aria-hidden="true" tabindex="-1"></a>        <span class="va">ptr_</span> <span class="op">=</span> newPtr<span class="op">;</span>                      </span>
<span id="cb57-438"><a href="#cb57-438" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb57-439"><a href="#cb57-439" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-440"><a href="#cb57-440" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">*</span><span class="kw">this</span><span class="op">;</span></span>
<span id="cb57-441"><a href="#cb57-441" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb57-442"><a href="#cb57-442" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb57-443"><a href="#cb57-443" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-444"><a href="#cb57-444" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>Our code has expanded! This leads us to the third problem: code duplication. </span>
<span id="cb57-445"><a href="#cb57-445" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-446"><a href="#cb57-446" aria-hidden="true" tabindex="-1"></a>In our case, the core of it is only two lines (the allocation and the copy), but with more complex resources, this code bloat can be quite a hassle. What if my class manages more than one resource?</span>
<span id="cb57-447"><a href="#cb57-447" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-448"><a href="#cb57-448" aria-hidden="true" tabindex="-1"></a>The *copy-and-swap* idiom is the solution, and elegantly assists the assignment operator in achieving two things: avoiding code duplication and providing a strong exception guarantee.</span>
<span id="cb57-449"><a href="#cb57-449" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-450"><a href="#cb57-450" aria-hidden="true" tabindex="-1"></a>While, the *rule-of-three* successfully entails our copy-constructor, assignment and destructor, it should really be called *The Big Three and A Half*: any time your class manages a resource, it also makes sense to provide a <span class="in">`swap`</span> function. </span>
<span id="cb57-451"><a href="#cb57-451" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-452"><a href="#cb57-452" aria-hidden="true" tabindex="-1"></a>A swap function is a *non-throwing* function that swaps two objects of a class member-for-member. </span>
<span id="cb57-453"><a href="#cb57-453" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-454"><a href="#cb57-454" aria-hidden="true" tabindex="-1"></a>We need to add <span class="in">`swap`</span> functionality to our class, and we do that as follows:</span>
<span id="cb57-455"><a href="#cb57-455" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-456"><a href="#cb57-456" aria-hidden="true" tabindex="-1"></a><span class="in">```cpp</span></span>
<span id="cb57-457"><a href="#cb57-457" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> swap<span class="op">(</span>Vector<span class="op">&amp;</span> other<span class="op">)</span> <span class="kw">noexcept</span></span>
<span id="cb57-458"><a href="#cb57-458" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb57-459"><a href="#cb57-459" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>swap<span class="op">(</span><span class="va">size_</span><span class="op">,</span> other<span class="op">.</span><span class="va">size_</span><span class="op">);</span></span>
<span id="cb57-460"><a href="#cb57-460" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>swap<span class="op">(</span><span class="va">capacity_</span><span class="op">,</span>other<span class="op">.</span><span class="va">capacity_</span><span class="op">);</span></span>
<span id="cb57-461"><a href="#cb57-461" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>swap<span class="op">(</span><span class="va">ptr_</span><span class="op">,</span> other<span class="op">.</span><span class="va">ptr_</span><span class="op">);</span></span>
<span id="cb57-462"><a href="#cb57-462" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb57-463"><a href="#cb57-463" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-464"><a href="#cb57-464" aria-hidden="true" tabindex="-1"></a><span class="kw">friend</span> <span class="dt">void</span> swap<span class="op">(</span>Vector<span class="op">&amp;</span> lhs<span class="op">,</span> Vector<span class="op">&amp;</span> rhs<span class="op">)</span> <span class="kw">noexcept</span><span class="op">{</span></span>
<span id="cb57-465"><a href="#cb57-465" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>swap<span class="op">(</span>lhs<span class="op">.</span><span class="va">size_</span><span class="op">,</span> rhs<span class="op">.</span><span class="va">size_</span><span class="op">);</span></span>
<span id="cb57-466"><a href="#cb57-466" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>swap<span class="op">(</span>lhs<span class="op">.</span><span class="va">capacity_</span><span class="op">,</span> rhs<span class="op">.</span><span class="va">capacity_</span><span class="op">);</span></span>
<span id="cb57-467"><a href="#cb57-467" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>swap<span class="op">(</span>lhs<span class="op">.</span><span class="va">ptr_</span><span class="op">,</span> rhs<span class="op">.</span><span class="va">ptr_</span><span class="op">);</span></span>
<span id="cb57-468"><a href="#cb57-468" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb57-469"><a href="#cb57-469" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb57-470"><a href="#cb57-470" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-471"><a href="#cb57-471" aria-hidden="true" tabindex="-1"></a>Now, this is extremely efficient, it merely swaps pointers and sizes rather than allocating and copying entire arrays. We are now ready to implement the copy-and-swap idiom. </span>
<span id="cb57-472"><a href="#cb57-472" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-473"><a href="#cb57-473" aria-hidden="true" tabindex="-1"></a>Our assignment operator is:</span>
<span id="cb57-474"><a href="#cb57-474" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-475"><a href="#cb57-475" aria-hidden="true" tabindex="-1"></a><span class="in">```cpp</span></span>
<span id="cb57-476"><a href="#cb57-476" aria-hidden="true" tabindex="-1"></a>Vector<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">=(</span>Vector other<span class="op">)</span> </span>
<span id="cb57-477"><a href="#cb57-477" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb57-478"><a href="#cb57-478" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>swap<span class="op">(*</span><span class="kw">this</span><span class="op">,</span> other<span class="op">);</span>    <span class="co">//(2)</span></span>
<span id="cb57-479"><a href="#cb57-479" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">*</span><span class="kw">this</span><span class="op">;</span></span>
<span id="cb57-480"><a href="#cb57-480" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb57-481"><a href="#cb57-481" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb57-482"><a href="#cb57-482" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-483"><a href="#cb57-483" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-484"><a href="#cb57-484" aria-hidden="true" tabindex="-1"></a><span class="fu">### Why does it work?</span></span>
<span id="cb57-485"><a href="#cb57-485" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-486"><a href="#cb57-486" aria-hidden="true" tabindex="-1"></a>We first notice an important choice : the parameter argument is taken *by-value*. While one could just as easily do the following(and indeed many naive implementations of the idiom do):</span>
<span id="cb57-487"><a href="#cb57-487" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-488"><a href="#cb57-488" aria-hidden="true" tabindex="-1"></a><span class="in">```cpp</span></span>
<span id="cb57-489"><a href="#cb57-489" aria-hidden="true" tabindex="-1"></a>Vector<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">=(</span><span class="at">const</span> Vector<span class="op">&amp;</span> other<span class="op">)</span></span>
<span id="cb57-490"><a href="#cb57-490" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb57-491"><a href="#cb57-491" aria-hidden="true" tabindex="-1"></a>    Vector temp <span class="op">{</span>other<span class="op">};</span> </span>
<span id="cb57-492"><a href="#cb57-492" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>swap<span class="op">(*</span><span class="kw">this</span><span class="op">,</span> temp<span class="op">);</span></span>
<span id="cb57-493"><a href="#cb57-493" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">*</span><span class="kw">this</span><span class="op">;</span></span>
<span id="cb57-494"><a href="#cb57-494" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb57-495"><a href="#cb57-495" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb57-496"><a href="#cb57-496" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-497"><a href="#cb57-497" aria-hidden="true" tabindex="-1"></a>We lose an important optimization opportunity - if a temporary is passed, the compiler will not perform copy elison. Not only that, but this choice is critical in C++ 11, which is discussed later. (On a general note, a remarkably useful guideline is as follows: if you're going to make a copy of something in a function, let the compiler do it in the parameter list).</span>
<span id="cb57-498"><a href="#cb57-498" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-499"><a href="#cb57-499" aria-hidden="true" tabindex="-1"></a>Either way, this method of obtaining our resource is key to eliminating code duplication: we get to use the code from the copy-constructor to make the copy, and never need to repeat any bit of it. Now that, the copy is made, we are ready to swap.</span>
<span id="cb57-500"><a href="#cb57-500" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-501"><a href="#cb57-501" aria-hidden="true" tabindex="-1"></a>Observe that upon entering the function, the new data is already allocated, copied and ready to be used. This is what gives us a strong exception guarantee: we won't even enter the function if the construction of the copy fails, and therefore it's not possible to alter the state of <span class="in">`*this`</span>. The assignment operator guarantees that the operations call will be fully rolled back in case of an error, as if the error never happened.</span>
<span id="cb57-502"><a href="#cb57-502" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-503"><a href="#cb57-503" aria-hidden="true" tabindex="-1"></a>Conceptually, it works by using the copy-constructor's functionality to create a local copy of the data, then takes the copied data with a <span class="in">`swap()`</span> function swapping the old data with the new data. </span>
<span id="cb57-504"><a href="#cb57-504" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-505"><a href="#cb57-505" aria-hidden="true" tabindex="-1"></a>To summarize: in order to use the copy-and-swap idiom, we need three things: a working copy-constructor, working destructor (both are the basis of any wrapper, so should be complete anyway), and a <span class="in">`swap`</span> function.</span>
<span id="cb57-506"><a href="#cb57-506" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-507"><a href="#cb57-507" aria-hidden="true" tabindex="-1"></a><span class="fu">## Value Categories</span></span>
<span id="cb57-508"><a href="#cb57-508" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-509"><a href="#cb57-509" aria-hidden="true" tabindex="-1"></a>In C++, every expression is either an *lvalue* or an *rvalue*. Consider an object that owns some resources(file-descriptors, sockets, memory buffer).</span>
<span id="cb57-510"><a href="#cb57-510" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-511"><a href="#cb57-511" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>An *lvalue* denotes an object whose resources cannot be reused. The object is an *lvalue*, if you can't take the guts(resources) out of this object and donate it to someone else. *lvalue*s include expressions that designate objects by their name. For example, in the expression `double y = f(x)`, `y` is an *lvalue*. Moreover, *lvalue*s have persistent storage and an identifiable memory address. For instance, if I declare `std::vector&lt;double&gt; v{1.0,2.0,3.0,4.0,5.0};`, then `v[0]` is an *lvalue*.</span>
<span id="cb57-512"><a href="#cb57-512" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-513"><a href="#cb57-513" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>An *rvalue* denotes an object whose resources can be reused. The object is an *rvalue*, if you can take the guts(resources) out of it and donate it to another object. *rvalue*s typically include temporary objects as they can't manipulated at the place they are created and are likely to be destroyed soon. For instance, if declare `int x = 5;`, `5` is an *rvalue*. Moreover, in the statement `double y = f(x);`, the expression `f(x)` is an *rvalue*. </span>
<span id="cb57-514"><a href="#cb57-514" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-515"><a href="#cb57-515" aria-hidden="true" tabindex="-1"></a><span class="fu">## Moving data</span></span>
<span id="cb57-516"><a href="#cb57-516" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-517"><a href="#cb57-517" aria-hidden="true" tabindex="-1"></a>As seen earlier, C++ sometimes performs unnecessary copying. </span>
<span id="cb57-518"><a href="#cb57-518" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-519"><a href="#cb57-519" aria-hidden="true" tabindex="-1"></a><span class="in">```cpp</span></span>
<span id="cb57-520"><a href="#cb57-520" aria-hidden="true" tabindex="-1"></a>Vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> x<span class="op">;</span></span>
<span id="cb57-521"><a href="#cb57-521" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> Vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;({</span></span>
<span id="cb57-522"><a href="#cb57-522" aria-hidden="true" tabindex="-1"></a>        <span class="fl">1.0</span><span class="op">,</span> <span class="fl">2.0</span><span class="op">,</span> <span class="fl">3.0</span><span class="op">,</span> <span class="fl">4.0</span><span class="op">,</span> <span class="fl">5.0</span><span class="op">,</span> </span>
<span id="cb57-523"><a href="#cb57-523" aria-hidden="true" tabindex="-1"></a>        <span class="fl">6.0</span><span class="op">,</span> <span class="fl">7.0</span><span class="op">,</span> <span class="fl">8.0</span><span class="op">,</span> <span class="fl">9.0</span><span class="op">,</span> <span class="fl">10.0</span></span>
<span id="cb57-524"><a href="#cb57-524" aria-hidden="true" tabindex="-1"></a>    <span class="op">});</span></span>
<span id="cb57-525"><a href="#cb57-525" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb57-526"><a href="#cb57-526" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-527"><a href="#cb57-527" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">cppinsights</span><span class="co">](https://cppinsights.io/s/230e7f56)</span> produces the following annotations:</span>
<span id="cb57-528"><a href="#cb57-528" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-529"><a href="#cb57-529" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb57-530"><a href="#cb57-530" aria-hidden="true" tabindex="-1"></a><span class="in">Vector&lt;double&gt; x = Vector&lt;double&gt;();</span></span>
<span id="cb57-531"><a href="#cb57-531" aria-hidden="true" tabindex="-1"></a><span class="in">const double __temporary179_5[10] = {</span></span>
<span id="cb57-532"><a href="#cb57-532" aria-hidden="true" tabindex="-1"></a><span class="in">    1.0, 2.0, 3.0, 4.0, 5.0, </span></span>
<span id="cb57-533"><a href="#cb57-533" aria-hidden="true" tabindex="-1"></a><span class="in">    6.0, 7.0, 8.0, 9.0, 10.0</span></span>
<span id="cb57-534"><a href="#cb57-534" aria-hidden="true" tabindex="-1"></a><span class="in">};</span></span>
<span id="cb57-535"><a href="#cb57-535" aria-hidden="true" tabindex="-1"></a><span class="in">const Vector&lt;double&gt; __temporary179_6 = Vector&lt;double&gt;(Vector&lt;double&gt;(std::initializer_list&lt;double&gt;{__temporary179_5, 10}));</span></span>
<span id="cb57-536"><a href="#cb57-536" aria-hidden="true" tabindex="-1"></a><span class="in">x.operator=(__temporary179_6);</span></span>
<span id="cb57-537"><a href="#cb57-537" aria-hidden="true" tabindex="-1"></a><span class="in">__temporary179_6.~Vector();</span></span>
<span id="cb57-538"><a href="#cb57-538" aria-hidden="true" tabindex="-1"></a><span class="in">/* __temporary179_5 // lifetime ends here */</span></span>
<span id="cb57-539"><a href="#cb57-539" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb57-540"><a href="#cb57-540" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-541"><a href="#cb57-541" aria-hidden="true" tabindex="-1"></a>In the above code snippet, the temporary vector of reals $<span class="sc">\{</span>1.0,2.0,3.0,\ldots,10.0<span class="sc">\}</span>$ is copied element-wise to <span class="in">`x`</span> and then destroyed immediately after. We've wasted a lot of energy in deep-copying. </span>
<span id="cb57-542"><a href="#cb57-542" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-543"><a href="#cb57-543" aria-hidden="true" tabindex="-1"></a>Similarly, appending to a full vector causes much copying before the append. That is not what we want to do.</span>
<span id="cb57-544"><a href="#cb57-544" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-545"><a href="#cb57-545" aria-hidden="true" tabindex="-1"></a>What we really want to do is, transfer the contents of <span class="in">`__temporary19_6`</span> vector to <span class="in">`x`</span> in a very simple way. Firstly, we copy the pointers; we cannot stop there, because at this point there are two <span class="in">`Vector&lt;T&gt;`</span> objects owning the same memory resource. </span>
<span id="cb57-546"><a href="#cb57-546" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-547"><a href="#cb57-547" aria-hidden="true" tabindex="-1"></a><span class="al">![Step 1. Copy the pointers](move_semantics_11.png)</span></span>
<span id="cb57-548"><a href="#cb57-548" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-549"><a href="#cb57-549" aria-hidden="true" tabindex="-1"></a>The second step is, of course to set the pointers of the temporary vector to <span class="in">`nullptr`</span>. </span>
<span id="cb57-550"><a href="#cb57-550" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-551"><a href="#cb57-551" aria-hidden="true" tabindex="-1"></a><span class="al">![Step 2. Zero out the members of __temp](move_semantics_12.png)</span></span>
<span id="cb57-552"><a href="#cb57-552" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-553"><a href="#cb57-553" aria-hidden="true" tabindex="-1"></a>That looks great and this is cheap! We are doing the minimum amount of work to transfer the contents of the temporary into <span class="in">`x`</span>.</span>
<span id="cb57-554"><a href="#cb57-554" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-555"><a href="#cb57-555" aria-hidden="true" tabindex="-1"></a>At the end of the assignment operation, the temporary goes out of scope and the vector $<span class="sc">\{</span>1,2,3,\ldots,10<span class="sc">\}</span>$ is in <span class="in">`x`</span>. How do we implement this logic programmatically?</span>
<span id="cb57-556"><a href="#cb57-556" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-557"><a href="#cb57-557" aria-hidden="true" tabindex="-1"></a>In addition to the copy-constructor, we write a move constructor. A move constuctor simply moves the data by taking ownership of the pointer that refers to the data, leaving the data itself where it resides.</span>
<span id="cb57-558"><a href="#cb57-558" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-559"><a href="#cb57-559" aria-hidden="true" tabindex="-1"></a><span class="in">```cpp</span></span>
<span id="cb57-560"><a href="#cb57-560" aria-hidden="true" tabindex="-1"></a><span class="co">// move constructor</span></span>
<span id="cb57-561"><a href="#cb57-561" aria-hidden="true" tabindex="-1"></a>Vector<span class="op">(</span>Vector<span class="op">&amp;&amp;</span> src<span class="op">)</span> <span class="kw">noexcept</span></span>
<span id="cb57-562"><a href="#cb57-562" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb57-563"><a href="#cb57-563" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Just swap the memory pointers</span></span>
<span id="cb57-564"><a href="#cb57-564" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>swap<span class="op">(</span>src<span class="op">,</span> <span class="op">*</span><span class="kw">this</span><span class="op">);</span></span>
<span id="cb57-565"><a href="#cb57-565" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb57-566"><a href="#cb57-566" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb57-567"><a href="#cb57-567" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-568"><a href="#cb57-568" aria-hidden="true" tabindex="-1"></a><span class="fu">### *rvalue* references in detail</span></span>
<span id="cb57-569"><a href="#cb57-569" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-570"><a href="#cb57-570" aria-hidden="true" tabindex="-1"></a>The constructor takes an argument of the type *rvalue* reference. *rvalue* references are declared two ampersands. *lvalue*s bind to *lvalue* references. When taking a reference to a temporary object, an *rvalue*, you have two choices. *rvalue*s can bind to:</span>
<span id="cb57-571"><a href="#cb57-571" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-572"><a href="#cb57-572" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>A <span class="in">`const`</span> *lvalue* reference.</span>
<span id="cb57-573"><a href="#cb57-573" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>A mutable *rvalue* reference. </span>
<span id="cb57-574"><a href="#cb57-574" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-575"><a href="#cb57-575" aria-hidden="true" tabindex="-1"></a><span class="in">```cpp</span></span>
<span id="cb57-576"><a href="#cb57-576" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="bu">std::</span>string<span class="op">&amp;</span> r1 <span class="op">{</span><span class="st">"hello"</span><span class="op">};</span>    </span>
<span id="cb57-577"><a href="#cb57-577" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>string<span class="op">&amp;</span> r2 <span class="op">{</span><span class="st">"world"</span><span class="op">};</span></span>
<span id="cb57-578"><a href="#cb57-578" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-579"><a href="#cb57-579" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> Vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> r3 <span class="op">{</span><span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span><span class="op">,</span><span class="dv">4</span><span class="op">,</span><span class="dv">5</span><span class="op">};</span></span>
<span id="cb57-580"><a href="#cb57-580" aria-hidden="true" tabindex="-1"></a>Vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;&amp;</span> r4<span class="op">{</span><span class="dv">6</span><span class="op">,</span><span class="dv">7</span><span class="op">,</span><span class="dv">8</span><span class="op">,</span><span class="dv">9</span><span class="op">,</span><span class="dv">10</span><span class="op">};</span></span>
<span id="cb57-581"><a href="#cb57-581" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb57-582"><a href="#cb57-582" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-583"><a href="#cb57-583" aria-hidden="true" tabindex="-1"></a>All these references have the semantics of - *we can steal/modify the resources of the object we refer to, provided the state of the object remains a valid state*. Technically, these semantics are not checked by compilers, so we can modify an *rvalue* reference as we can do with any non-<span class="in">`const`</span> object of the type. We might also decide not to  modify the value.</span>
<span id="cb57-584"><a href="#cb57-584" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-585"><a href="#cb57-585" aria-hidden="true" tabindex="-1"></a><span class="in">```cpp</span></span>
<span id="cb57-586"><a href="#cb57-586" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>string<span class="op">&amp;&amp;</span> r1 <span class="op">=</span> <span class="st">"hello"</span><span class="op">;</span>    </span>
<span id="cb57-587"><a href="#cb57-587" aria-hidden="true" tabindex="-1"></a>r1 <span class="op">+=</span> <span class="st">"world"</span><span class="op">;</span> </span>
<span id="cb57-588"><a href="#cb57-588" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-589"><a href="#cb57-589" aria-hidden="true" tabindex="-1"></a>Vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;&amp;</span> r2 <span class="op">{</span><span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span><span class="op">,</span><span class="dv">4</span><span class="op">,</span><span class="dv">5</span><span class="op">};</span></span>
<span id="cb57-590"><a href="#cb57-590" aria-hidden="true" tabindex="-1"></a>r2<span class="op">.</span>push_back<span class="op">(</span><span class="dv">6</span><span class="op">);</span></span>
<span id="cb57-591"><a href="#cb57-591" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb57-592"><a href="#cb57-592" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-593"><a href="#cb57-593" aria-hidden="true" tabindex="-1"></a>And it's a logic error to take a mutable *lvalue* reference to a temporary, so this is disallowed in the language:</span>
<span id="cb57-594"><a href="#cb57-594" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-595"><a href="#cb57-595" aria-hidden="true" tabindex="-1"></a><span class="in">```cpp</span></span>
<span id="cb57-596"><a href="#cb57-596" aria-hidden="true" tabindex="-1"></a><span class="co">// std::string&amp; r1 = "hello";    //error: this is not possible</span></span>
<span id="cb57-597"><a href="#cb57-597" aria-hidden="true" tabindex="-1"></a><span class="co">// r1 += "world"; </span></span>
<span id="cb57-598"><a href="#cb57-598" aria-hidden="true" tabindex="-1"></a><span class="co">// Vector&lt;int&gt;&amp; r2 {1,2,3,4,5};</span></span>
<span id="cb57-599"><a href="#cb57-599" aria-hidden="true" tabindex="-1"></a><span class="co">// r2.push_back(6);</span></span>
<span id="cb57-600"><a href="#cb57-600" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb57-601"><a href="#cb57-601" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-602"><a href="#cb57-602" aria-hidden="true" tabindex="-1"></a>Assigning a temporary to a reference extends the lifetime of the temporary so that it matches the lifetime of the reference. So, this is legal:</span>
<span id="cb57-603"><a href="#cb57-603" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-604"><a href="#cb57-604" aria-hidden="true" tabindex="-1"></a><span class="in">```cpp</span></span>
<span id="cb57-605"><a href="#cb57-605" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb57-606"><a href="#cb57-606" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb57-607"><a href="#cb57-607" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb57-608"><a href="#cb57-608" aria-hidden="true" tabindex="-1"></a>        <span class="at">const</span> <span class="bu">std::</span>string<span class="op">&amp;</span> s <span class="op">=</span> foo<span class="op">();</span></span>
<span id="cb57-609"><a href="#cb57-609" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> s <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span>    <span class="co">//the temporary to which s refers is still alive</span></span>
<span id="cb57-610"><a href="#cb57-610" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb57-611"><a href="#cb57-611" aria-hidden="true" tabindex="-1"></a>    <span class="co">//but now it's destroyed</span></span>
<span id="cb57-612"><a href="#cb57-612" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span>    </span>
<span id="cb57-613"><a href="#cb57-613" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb57-614"><a href="#cb57-614" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-615"><a href="#cb57-615" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb57-616"><a href="#cb57-616" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-617"><a href="#cb57-617" aria-hidden="true" tabindex="-1"></a>And so is this:</span>
<span id="cb57-618"><a href="#cb57-618" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-619"><a href="#cb57-619" aria-hidden="true" tabindex="-1"></a><span class="in">```cpp</span></span>
<span id="cb57-620"><a href="#cb57-620" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>string foo<span class="op">(){</span> <span class="cf">return</span> <span class="st">"foo"</span><span class="op">;};</span>      <span class="co">//function that returns a string</span></span>
<span id="cb57-621"><a href="#cb57-621" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-622"><a href="#cb57-622" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> bar<span class="op">(</span><span class="bu">std::</span>string<span class="op">&amp;&amp;</span> s<span class="op">){</span>              <span class="co">// extends the lifetime as before</span></span>
<span id="cb57-623"><a href="#cb57-623" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> s<span class="op">;</span> </span>
<span id="cb57-624"><a href="#cb57-624" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>    </span>
<span id="cb57-625"><a href="#cb57-625" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-626"><a href="#cb57-626" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb57-627"><a href="#cb57-627" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb57-628"><a href="#cb57-628" aria-hidden="true" tabindex="-1"></a>    bar<span class="op">(</span>foo<span class="op">());</span>     </span>
<span id="cb57-629"><a href="#cb57-629" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb57-630"><a href="#cb57-630" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb57-631"><a href="#cb57-631" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb57-632"><a href="#cb57-632" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-633"><a href="#cb57-633" aria-hidden="true" tabindex="-1"></a><span class="fu">### *rvalue* references as parameters</span></span>
<span id="cb57-634"><a href="#cb57-634" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-635"><a href="#cb57-635" aria-hidden="true" tabindex="-1"></a>When we declare a parameter to be an *rvalue* reference, it has exactly the behavior and semantics as introduced above:</span>
<span id="cb57-636"><a href="#cb57-636" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-637"><a href="#cb57-637" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>The parameter can only bind to a temporary object or an *rvalue*.</span>
<span id="cb57-638"><a href="#cb57-638" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>According to the semantics of *rvalue* references:</span>
<span id="cb57-639"><a href="#cb57-639" aria-hidden="true" tabindex="-1"></a><span class="ss">  - </span>The caller claims that it is no longer interested in the object. Therefore, you can steal the guts of object, take ownership of its resources.</span>
<span id="cb57-640"><a href="#cb57-640" aria-hidden="true" tabindex="-1"></a><span class="ss">  - </span>However, the caller might still be interested in using the object. Therefore, any modification should keep the referenced object in a valid state.</span>
<span id="cb57-641"><a href="#cb57-641" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-642"><a href="#cb57-642" aria-hidden="true" tabindex="-1"></a><span class="fu">## `std::move()`</span></span>
<span id="cb57-643"><a href="#cb57-643" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-644"><a href="#cb57-644" aria-hidden="true" tabindex="-1"></a>Hey, this is cool! Why don't we apply these ideas to the below example?</span>
<span id="cb57-645"><a href="#cb57-645" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-646"><a href="#cb57-646" aria-hidden="true" tabindex="-1"></a><span class="in">```cpp</span></span>
<span id="cb57-647"><a href="#cb57-647" aria-hidden="true" tabindex="-1"></a>Vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> v1 <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span><span class="op">};</span></span>
<span id="cb57-648"><a href="#cb57-648" aria-hidden="true" tabindex="-1"></a>Vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> v2 <span class="op">{</span>v1<span class="op">};</span></span>
<span id="cb57-649"><a href="#cb57-649" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb57-650"><a href="#cb57-650" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-651"><a href="#cb57-651" aria-hidden="true" tabindex="-1"></a>Well, in this case, we would have a problem. <span class="in">`v1`</span> has a name, it has a persistent storage location and a memory address, it is an *lvalue*. You can't steal the contents of <span class="in">`v1`</span>.  </span>
<span id="cb57-652"><a href="#cb57-652" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-653"><a href="#cb57-653" aria-hidden="true" tabindex="-1"></a>But, we can do something about this. If indeed you are interested to transfer the contents of <span class="in">`v1`</span> into <span class="in">`v2`</span>, then all we need to do is use <span class="in">`std::move`</span>. </span>
<span id="cb57-654"><a href="#cb57-654" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-655"><a href="#cb57-655" aria-hidden="true" tabindex="-1"></a><span class="in">```cpp</span></span>
<span id="cb57-656"><a href="#cb57-656" aria-hidden="true" tabindex="-1"></a>Vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> v1 <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span><span class="op">};</span></span>
<span id="cb57-657"><a href="#cb57-657" aria-hidden="true" tabindex="-1"></a>Vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> v2 <span class="op">{</span><span class="bu">std::</span>move<span class="op">(</span>v1<span class="op">)};</span></span>
<span id="cb57-658"><a href="#cb57-658" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb57-659"><a href="#cb57-659" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-660"><a href="#cb57-660" aria-hidden="true" tabindex="-1"></a><span class="in">`std::move()`</span> is a function that you can think of as performing an unconditional cast of its argument to an *rvalue* reference. `std::move(v1)` marks `v1` to be movable. It does not physically move anything. It signals, that the object `v1` may be *moved from*.  </span>
<span id="cb57-661"><a href="#cb57-661" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-662"><a href="#cb57-662" aria-hidden="true" tabindex="-1"></a>If you have an *lvalue*, an object for which the lifetime does not end when you use it, you can mark it with `std::move()` to express *I no longer need this object here*. <span class="in">`std::move`</span> does not move; it only sets a temporary marker in the context where the expression is used:</span>
<span id="cb57-663"><a href="#cb57-663" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-664"><a href="#cb57-664" aria-hidden="true" tabindex="-1"></a><span class="in">```cpp</span></span>
<span id="cb57-665"><a href="#cb57-665" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> foo1<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>string<span class="op">&amp;</span> lr<span class="op">);</span>    <span class="co">//binds to the passed object without modifying it</span></span>
<span id="cb57-666"><a href="#cb57-666" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> foo1<span class="op">(</span><span class="bu">std::</span>string<span class="op">&amp;&amp;</span> rv<span class="op">);</span>         <span class="co">//binds to the passed object and might steal/modify its contents</span></span>
<span id="cb57-667"><a href="#cb57-667" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-668"><a href="#cb57-668" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>string s<span class="op">{</span><span class="st">"hello"</span><span class="op">};</span></span>
<span id="cb57-669"><a href="#cb57-669" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-670"><a href="#cb57-670" aria-hidden="true" tabindex="-1"></a>foo1<span class="op">(</span>s<span class="op">);</span>                             <span class="co">//calls the first foo(), s keeps its value</span></span>
<span id="cb57-671"><a href="#cb57-671" aria-hidden="true" tabindex="-1"></a>foo1<span class="op">(</span><span class="bu">std::</span>move<span class="op">(</span>s<span class="op">));</span>                  <span class="co">//calls the second foo(), s might lose its value</span></span>
<span id="cb57-672"><a href="#cb57-672" aria-hidden="true" tabindex="-1"></a>                                     <span class="co">//semantically s no longer legal to access</span></span>
<span id="cb57-673"><a href="#cb57-673" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb57-674"><a href="#cb57-674" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-675"><a href="#cb57-675" aria-hidden="true" tabindex="-1"></a>Objects marked with <span class="in">`std::move()`</span> can still be passed to a function that takes an ordinary <span class="in">`const`</span> *lvalue* reference. Consider another code snippet:</span>
<span id="cb57-676"><a href="#cb57-676" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-677"><a href="#cb57-677" aria-hidden="true" tabindex="-1"></a><span class="in">```cpp</span></span>
<span id="cb57-678"><a href="#cb57-678" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> foo2<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>string<span class="op">&amp;</span> lr<span class="op">);</span>   <span class="co">//binds to the passed object without modifying it</span></span>
<span id="cb57-679"><a href="#cb57-679" aria-hidden="true" tabindex="-1"></a>                                    <span class="co">//no other overload of foo2()</span></span>
<span id="cb57-680"><a href="#cb57-680" aria-hidden="true" tabindex="-1"></a>foo2<span class="op">(</span>s<span class="op">);</span>                            <span class="co">// calls foo2(), s keeps its value</span></span>
<span id="cb57-681"><a href="#cb57-681" aria-hidden="true" tabindex="-1"></a>foos<span class="op">(</span><span class="bu">std::</span>move<span class="op">(</span>s<span class="op">))</span>                  <span class="co">// calls foo2(), s keeps its value because we know that</span></span>
<span id="cb57-682"><a href="#cb57-682" aria-hidden="true" tabindex="-1"></a>                                    <span class="co">// foo2() can't modify or take ownership of the contents of s.</span></span>
<span id="cb57-683"><a href="#cb57-683" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb57-684"><a href="#cb57-684" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-685"><a href="#cb57-685" aria-hidden="true" tabindex="-1"></a>Semantically, <span class="in">`s`</span> is still legal to access after the execution of the last line. Because there's overload of <span class="in">`foo2(const std::string&amp;&amp;)`</span>, there is no ways its contents can be modified or transferred. </span>
<span id="cb57-686"><a href="#cb57-686" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-687"><a href="#cb57-687" aria-hidden="true" tabindex="-1"></a>Note that, an object marked with <span class="in">`std::move()`</span> cannot be passed to a non-<span class="in">`const`</span> *lvalue* reference.</span>
<span id="cb57-688"><a href="#cb57-688" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-689"><a href="#cb57-689" aria-hidden="true" tabindex="-1"></a><span class="fu">### Header file for `std::move()`</span></span>
<span id="cb57-690"><a href="#cb57-690" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-691"><a href="#cb57-691" aria-hidden="true" tabindex="-1"></a><span class="in">`std::move()`</span> is defined as a function in the C++ standard library. To use it, you have to include the header file <span class="in">`&lt;utility&gt;`</span> where it is defined:</span>
<span id="cb57-692"><a href="#cb57-692" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-693"><a href="#cb57-693" aria-hidden="true" tabindex="-1"></a><span class="fu">### Implementation of `std::move()`</span></span>
<span id="cb57-694"><a href="#cb57-694" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-695"><a href="#cb57-695" aria-hidden="true" tabindex="-1"></a><span class="in">`std::move()`</span> is nothing but a <span class="in">`static_cast`</span> to an *rvalue* reference. You can achieve the same effect by calling <span class="in">`static_cast`</span> manually as follows:</span>
<span id="cb57-696"><a href="#cb57-696" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-697"><a href="#cb57-697" aria-hidden="true" tabindex="-1"></a><span class="in">```cpp</span></span>
<span id="cb57-698"><a href="#cb57-698" aria-hidden="true" tabindex="-1"></a>foo<span class="op">(</span><span class="kw">static_cast</span><span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>obj<span class="op">)&amp;&amp;&gt;(</span>obj<span class="op">));</span>     <span class="co">//same effect foo(std::move(obj))</span></span>
<span id="cb57-699"><a href="#cb57-699" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb57-700"><a href="#cb57-700" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-701"><a href="#cb57-701" aria-hidden="true" tabindex="-1"></a>Therefore, we could also write:</span>
<span id="cb57-702"><a href="#cb57-702" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-703"><a href="#cb57-703" aria-hidden="true" tabindex="-1"></a><span class="in">```cpp</span></span>
<span id="cb57-704"><a href="#cb57-704" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>string s<span class="op">{</span><span class="st">"hello"</span><span class="op">};</span></span>
<span id="cb57-705"><a href="#cb57-705" aria-hidden="true" tabindex="-1"></a>foo<span class="op">(</span><span class="kw">static_cast</span><span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&amp;&amp;&gt;(</span>s<span class="op">));</span></span>
<span id="cb57-706"><a href="#cb57-706" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb57-707"><a href="#cb57-707" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-708"><a href="#cb57-708" aria-hidden="true" tabindex="-1"></a><span class="fu">## Moved-from objects</span></span>
<span id="cb57-709"><a href="#cb57-709" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-710"><a href="#cb57-710" aria-hidden="true" tabindex="-1"></a>After a <span class="in">`std::move()`</span>, moved-from objects are not (partially) destroyed. They are still valid objects for which at least the destructor will be called. However, they should also be valid in the sense that they have a consistent state and all operations work as expected. The only thing you do not know is their contents. </span>
<span id="cb57-711"><a href="#cb57-711" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-712"><a href="#cb57-712" aria-hidden="true" tabindex="-1"></a><span class="fu">### Valid but unspecified state</span></span>
<span id="cb57-713"><a href="#cb57-713" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-714"><a href="#cb57-714" aria-hidden="true" tabindex="-1"></a>The C++ standard library guarantees that moved-from objects are in a *valid but unspecified state*. Consider the following code:</span>
<span id="cb57-715"><a href="#cb57-715" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-716"><a href="#cb57-716" aria-hidden="true" tabindex="-1"></a><span class="in">```cpp</span></span>
<span id="cb57-717"><a href="#cb57-717" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>string s<span class="op">{</span><span class="st">"hello"</span><span class="op">};</span></span>
<span id="cb57-718"><a href="#cb57-718" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;</span> coll<span class="op">{};</span></span>
<span id="cb57-719"><a href="#cb57-719" aria-hidden="true" tabindex="-1"></a>coll<span class="op">.</span>push_back<span class="op">(</span><span class="bu">std::</span>move<span class="op">(</span>s<span class="op">));</span></span>
<span id="cb57-720"><a href="#cb57-720" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb57-721"><a href="#cb57-721" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-722"><a href="#cb57-722" aria-hidden="true" tabindex="-1"></a>After passing <span class="in">`s`</span> with <span class="in">`std::move()`</span> you can ask for the number of characters, print out the value, or even assign a new value. However, you cannot print the first character or any other character without checking the number of characters first:</span>
<span id="cb57-723"><a href="#cb57-723" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-724"><a href="#cb57-724" aria-hidden="true" tabindex="-1"></a><span class="in">```cpp</span></span>
<span id="cb57-725"><a href="#cb57-725" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb57-726"><a href="#cb57-726" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb57-727"><a href="#cb57-727" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb57-728"><a href="#cb57-728" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;utility&gt;</span></span>
<span id="cb57-729"><a href="#cb57-729" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-730"><a href="#cb57-730" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb57-731"><a href="#cb57-731" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb57-732"><a href="#cb57-732" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string s<span class="op">{</span><span class="st">"hello"</span><span class="op">};</span></span>
<span id="cb57-733"><a href="#cb57-733" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;</span> coll<span class="op">{};</span></span>
<span id="cb57-734"><a href="#cb57-734" aria-hidden="true" tabindex="-1"></a>    coll<span class="op">.</span>push_back<span class="op">(</span><span class="bu">std::</span>move<span class="op">(</span>s<span class="op">));</span>   <span class="co">//keeps in a valid but unclear state</span></span>
<span id="cb57-735"><a href="#cb57-735" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"Contents of s : "</span> <span class="op">&lt;&lt;</span> s <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span>     <span class="co">//ok (don't know which value is written)</span></span>
<span id="cb57-736"><a href="#cb57-736" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"size : "</span> <span class="op">&lt;&lt;</span> s<span class="op">.</span>size<span class="op">()</span> <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span> <span class="co">//ok (rites the number of characters)</span></span>
<span id="cb57-737"><a href="#cb57-737" aria-hidden="true" tabindex="-1"></a>    <span class="co">// std::cout &lt;&lt; "[0] = " &lt;&lt; s[0] &lt;&lt; "\n"; //error (potentially undefined behavior)</span></span>
<span id="cb57-738"><a href="#cb57-738" aria-hidden="true" tabindex="-1"></a>    s <span class="op">=</span> <span class="st">"new value"</span><span class="op">;</span>    <span class="co">// ok</span></span>
<span id="cb57-739"><a href="#cb57-739" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb57-740"><a href="#cb57-740" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb57-741"><a href="#cb57-741" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb57-742"><a href="#cb57-742" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">Compiler Explorer</span><span class="co">](https://godbolt.org/z/MY4Y576n1)</span></span>
<span id="cb57-743"><a href="#cb57-743" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-744"><a href="#cb57-744" aria-hidden="true" tabindex="-1"></a>stdout</span>
<span id="cb57-745"><a href="#cb57-745" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb57-746"><a href="#cb57-746" aria-hidden="true" tabindex="-1"></a><span class="in">Contents of s : </span></span>
<span id="cb57-747"><a href="#cb57-747" aria-hidden="true" tabindex="-1"></a><span class="in">size : 0</span></span>
<span id="cb57-748"><a href="#cb57-748" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb57-749"><a href="#cb57-749" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-750"><a href="#cb57-750" aria-hidden="true" tabindex="-1"></a><span class="fu">### Reusing moved-from objects</span></span>
<span id="cb57-751"><a href="#cb57-751" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-752"><a href="#cb57-752" aria-hidden="true" tabindex="-1"></a>We might wonder why moved-from objects are still valid objects and are not (partially) destroyed. The reason is that there are useful applications of move semantics, where it makes sense to use moved-from objects again.</span>
<span id="cb57-753"><a href="#cb57-753" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-754"><a href="#cb57-754" aria-hidden="true" tabindex="-1"></a>For example, consider code where we read chunks of data from a network socket or read strings line-by-line from a file stream and move them into a vector:</span>
<span id="cb57-755"><a href="#cb57-755" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-756"><a href="#cb57-756" aria-hidden="true" tabindex="-1"></a><span class="in">```cpp</span></span>
<span id="cb57-757"><a href="#cb57-757" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;</span> allRows<span class="op">;</span></span>
<span id="cb57-758"><a href="#cb57-758" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>string row<span class="op">;</span></span>
<span id="cb57-759"><a href="#cb57-759" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-760"><a href="#cb57-760" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span><span class="op">(</span><span class="bu">std::</span>getline<span class="op">(</span>myStream<span class="op">,</span> row<span class="op">)){</span> <span class="co">//read next line into row</span></span>
<span id="cb57-761"><a href="#cb57-761" aria-hidden="true" tabindex="-1"></a>    allRows<span class="op">.</span>push_back<span class="op">(</span><span class="bu">std::</span>move<span class="op">(</span>row<span class="op">));</span>  <span class="co">//and move it to somewhere</span></span>
<span id="cb57-762"><a href="#cb57-762" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb57-763"><a href="#cb57-763" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb57-764"><a href="#cb57-764" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-765"><a href="#cb57-765" aria-hidden="true" tabindex="-1"></a>Each time after we read a line into <span class="in">`row`</span>, we use <span class="in">`std::move()`</span> to move the value of <span class="in">`row`</span> into the vector of all rows. Then, <span class="in">`std::getline()`</span> uses the moved-from object <span class="in">`row`</span> again to read the next line into it.</span>
<span id="cb57-766"><a href="#cb57-766" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-767"><a href="#cb57-767" aria-hidden="true" tabindex="-1"></a>As a second example, consider a generic function that swaps two values:</span>
<span id="cb57-768"><a href="#cb57-768" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-769"><a href="#cb57-769" aria-hidden="true" tabindex="-1"></a><span class="in">```cpp</span></span>
<span id="cb57-770"><a href="#cb57-770" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb57-771"><a href="#cb57-771" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> swap<span class="op">(</span>T<span class="op">&amp;</span> a<span class="op">,</span> T<span class="op">&amp;</span> b<span class="op">)</span></span>
<span id="cb57-772"><a href="#cb57-772" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb57-773"><a href="#cb57-773" aria-hidden="true" tabindex="-1"></a>    T tmp<span class="op">{</span><span class="bu">std::</span>move<span class="op">(</span>a<span class="op">)};</span></span>
<span id="cb57-774"><a href="#cb57-774" aria-hidden="true" tabindex="-1"></a>    a <span class="op">=</span> <span class="bu">std::</span>move<span class="op">(</span>b<span class="op">);</span>       <span class="co">//assign new value to moved-from a</span></span>
<span id="cb57-775"><a href="#cb57-775" aria-hidden="true" tabindex="-1"></a>    b <span class="op">=</span> <span class="bu">std::</span>move<span class="op">(</span>temp<span class="op">);</span>    <span class="co">//assign new value to moved-from b</span></span>
<span id="cb57-776"><a href="#cb57-776" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb57-777"><a href="#cb57-777" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb57-778"><a href="#cb57-778" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-779"><a href="#cb57-779" aria-hidden="true" tabindex="-1"></a>Here, we move the value of <span class="in">`a`</span> into a temporary object to be able t move-assign the value of <span class="in">`b`</span> afterwards. The moved-from object <span class="in">`b`</span> then receives the value of <span class="in">`tmp`</span>, which is the former value of <span class="in">`a`</span>. </span>
<span id="cb57-780"><a href="#cb57-780" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-781"><a href="#cb57-781" aria-hidden="true" tabindex="-1"></a>Code like this is used in sorting algorithms for example, sorting a vector of buy/sell orders in the order book by the bid/ask prices. </span>
<span id="cb57-782"><a href="#cb57-782" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-783"><a href="#cb57-783" aria-hidden="true" tabindex="-1"></a><span class="fu">### Move assignments of objects to themselves</span></span>
<span id="cb57-784"><a href="#cb57-784" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-785"><a href="#cb57-785" aria-hidden="true" tabindex="-1"></a>The rule that moved-from objects are in a *valid but unspecified state* usually also applies to objects after a direct or indirect self-move.</span>
<span id="cb57-786"><a href="#cb57-786" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-787"><a href="#cb57-787" aria-hidden="true" tabindex="-1"></a>For example, after the following statement, the object <span class="in">`x`</span> is usually valid without its value being known:</span>
<span id="cb57-788"><a href="#cb57-788" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-789"><a href="#cb57-789" aria-hidden="true" tabindex="-1"></a><span class="in">```cpp</span></span>
<span id="cb57-790"><a href="#cb57-790" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> <span class="bu">std::</span>move<span class="op">(</span>x<span class="op">);</span>   <span class="co">//afterwards x is valid but has an unclear value</span></span>
<span id="cb57-791"><a href="#cb57-791" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb57-792"><a href="#cb57-792" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-793"><a href="#cb57-793" aria-hidden="true" tabindex="-1"></a><span class="fu">## The canonical move constructor and move assignment operator</span></span>
<span id="cb57-794"><a href="#cb57-794" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-795"><a href="#cb57-795" aria-hidden="true" tabindex="-1"></a>Consider the below <span class="in">`Widget`</span> class as an example. The canonical move constructor and move assignment operators are written as follows:</span>
<span id="cb57-796"><a href="#cb57-796" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-797"><a href="#cb57-797" aria-hidden="true" tabindex="-1"></a><span class="in">```cpp</span></span>
<span id="cb57-798"><a href="#cb57-798" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Widget<span class="op">{</span></span>
<span id="cb57-799"><a href="#cb57-799" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span><span class="op">:</span></span>
<span id="cb57-800"><a href="#cb57-800" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> i<span class="op">;</span></span>
<span id="cb57-801"><a href="#cb57-801" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>string s<span class="op">{};</span></span>
<span id="cb57-802"><a href="#cb57-802" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">*</span> resource<span class="op">;</span>            <span class="co">// Owning pointer</span></span>
<span id="cb57-803"><a href="#cb57-803" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-804"><a href="#cb57-804" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb57-805"><a href="#cb57-805" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Move constructor</span></span>
<span id="cb57-806"><a href="#cb57-806" aria-hidden="true" tabindex="-1"></a>    Widget<span class="op">(</span>Widget<span class="op">&amp;&amp;</span> rhs<span class="op">)</span> <span class="kw">noexcept</span> <span class="co">//Phase 1: member-wise swap</span></span>
<span id="cb57-807"><a href="#cb57-807" aria-hidden="true" tabindex="-1"></a>        <span class="op">:</span> i <span class="op">{</span><span class="bu">std::</span>move<span class="op">(</span>rhs<span class="op">.</span>i<span class="op">)}</span></span>
<span id="cb57-808"><a href="#cb57-808" aria-hidden="true" tabindex="-1"></a>        <span class="op">,</span> s <span class="op">{</span><span class="bu">std::</span>move<span class="op">(</span>rhs<span class="op">.</span>s<span class="op">)}</span></span>
<span id="cb57-809"><a href="#cb57-809" aria-hidden="true" tabindex="-1"></a>        <span class="op">,</span> resource<span class="op">{</span><span class="bu">std::</span>move<span class="op">(</span>rhs<span class="op">.</span>resource<span class="op">)}</span></span>
<span id="cb57-810"><a href="#cb57-810" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb57-811"><a href="#cb57-811" aria-hidden="true" tabindex="-1"></a>        rhs<span class="op">.</span>resource <span class="op">=</span> <span class="kw">nullptr</span><span class="op">;</span> <span class="co">// Phase 2: reset the move-from object</span></span>
<span id="cb57-812"><a href="#cb57-812" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb57-813"><a href="#cb57-813" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-814"><a href="#cb57-814" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Move assignment operator</span></span>
<span id="cb57-815"><a href="#cb57-815" aria-hidden="true" tabindex="-1"></a>    Widget<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">=(</span>Widget<span class="op">&amp;&amp;</span> src<span class="op">)</span></span>
<span id="cb57-816"><a href="#cb57-816" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb57-817"><a href="#cb57-817" aria-hidden="true" tabindex="-1"></a>        <span class="kw">delete</span> resource<span class="op">;</span>            <span class="co">//Phase 1: Cleanup</span></span>
<span id="cb57-818"><a href="#cb57-818" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>swap<span class="op">(</span>src<span class="op">,</span> <span class="op">*</span><span class="kw">this</span><span class="op">);</span>      <span class="co">//Phase 2: Member-wise move</span></span>
<span id="cb57-819"><a href="#cb57-819" aria-hidden="true" tabindex="-1"></a>        src<span class="op">-&gt;</span>resource <span class="op">=</span> <span class="kw">nullptr</span><span class="op">;</span>    <span class="co">//Phase 3: Reset</span></span>
<span id="cb57-820"><a href="#cb57-820" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">*</span><span class="kw">this</span><span class="op">;</span></span>
<span id="cb57-821"><a href="#cb57-821" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb57-822"><a href="#cb57-822" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-823"><a href="#cb57-823" aria-hidden="true" tabindex="-1"></a>    Widget<span class="op">::</span>Widget<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">=(</span>Widget src<span class="op">);</span></span>
<span id="cb57-824"><a href="#cb57-824" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb57-825"><a href="#cb57-825" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb57-826"><a href="#cb57-826" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-827"><a href="#cb57-827" aria-hidden="true" tabindex="-1"></a>An owning-pointer such <span class="in">`int*`</span> is special, and it has to be dealt with separately. </span>
<span id="cb57-828"><a href="#cb57-828" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-829"><a href="#cb57-829" aria-hidden="true" tabindex="-1"></a>Raw pointers are bad (especially owning raw pointers). In this case, the declaration doesn't indicate whether it points to an element or an array. </span>
<span id="cb57-830"><a href="#cb57-830" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-831"><a href="#cb57-831" aria-hidden="true" tabindex="-1"></a>If instead, we have a smart-pointer, then what I can do is omit is phase 2. </span>
<span id="cb57-832"><a href="#cb57-832" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-833"><a href="#cb57-833" aria-hidden="true" tabindex="-1"></a><span class="in">```cpp</span></span>
<span id="cb57-834"><a href="#cb57-834" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Widget<span class="op">{</span></span>
<span id="cb57-835"><a href="#cb57-835" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span><span class="op">:</span></span>
<span id="cb57-836"><a href="#cb57-836" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> i<span class="op">;</span></span>
<span id="cb57-837"><a href="#cb57-837" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>string s<span class="op">{};</span></span>
<span id="cb57-838"><a href="#cb57-838" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">*</span> resource<span class="op">;</span>      </span>
<span id="cb57-839"><a href="#cb57-839" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-840"><a href="#cb57-840" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb57-841"><a href="#cb57-841" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Move constructor</span></span>
<span id="cb57-842"><a href="#cb57-842" aria-hidden="true" tabindex="-1"></a>    Widget<span class="op">(</span>Widget<span class="op">&amp;&amp;</span> rhs<span class="op">)</span> <span class="kw">noexcept</span> <span class="co">//Phase 1: member-wise swap</span></span>
<span id="cb57-843"><a href="#cb57-843" aria-hidden="true" tabindex="-1"></a>        <span class="op">:</span> i <span class="op">{</span><span class="bu">std::</span>move<span class="op">(</span>rhs<span class="op">.</span>i<span class="op">)}</span></span>
<span id="cb57-844"><a href="#cb57-844" aria-hidden="true" tabindex="-1"></a>        <span class="op">,</span> s <span class="op">{</span><span class="bu">std::</span>move<span class="op">(</span>rhs<span class="op">.</span>s<span class="op">)}</span></span>
<span id="cb57-845"><a href="#cb57-845" aria-hidden="true" tabindex="-1"></a>        <span class="op">,</span> resource<span class="op">{</span><span class="bu">std::</span>move<span class="op">(</span>rhs<span class="op">.</span>resource<span class="op">)}</span></span>
<span id="cb57-846"><a href="#cb57-846" aria-hidden="true" tabindex="-1"></a>    <span class="op">{}</span></span>
<span id="cb57-847"><a href="#cb57-847" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-848"><a href="#cb57-848" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Move assignment operator</span></span>
<span id="cb57-849"><a href="#cb57-849" aria-hidden="true" tabindex="-1"></a>    Widget<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">=(</span>Widget<span class="op">&amp;&amp;</span> src<span class="op">)</span></span>
<span id="cb57-850"><a href="#cb57-850" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb57-851"><a href="#cb57-851" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>swap<span class="op">(</span>src<span class="op">,</span> <span class="op">*</span><span class="kw">this</span><span class="op">);</span> </span>
<span id="cb57-852"><a href="#cb57-852" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">*</span><span class="kw">this</span><span class="op">;</span></span>
<span id="cb57-853"><a href="#cb57-853" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb57-854"><a href="#cb57-854" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-855"><a href="#cb57-855" aria-hidden="true" tabindex="-1"></a>    Widget<span class="op">::</span>Widget<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">=(</span>Widget src<span class="op">);</span></span>
<span id="cb57-856"><a href="#cb57-856" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb57-857"><a href="#cb57-857" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb57-858"><a href="#cb57-858" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-859"><a href="#cb57-859" aria-hidden="true" tabindex="-1"></a>I would like to show you one more thing. The canonical copy assignment operator also doubles up as a move-assignment operator. </span>
<span id="cb57-860"><a href="#cb57-860" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-861"><a href="#cb57-861" aria-hidden="true" tabindex="-1"></a><span class="in">```cpp</span></span>
<span id="cb57-862"><a href="#cb57-862" aria-hidden="true" tabindex="-1"></a><span class="co">// Copy/Move assignment operator</span></span>
<span id="cb57-863"><a href="#cb57-863" aria-hidden="true" tabindex="-1"></a>Widget<span class="op">::</span>Widget<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">=(</span>Widget src<span class="op">)</span>  <span class="co">//Copy/move constructor called </span></span>
<span id="cb57-864"><a href="#cb57-864" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb57-865"><a href="#cb57-865" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>swap<span class="op">(</span>src<span class="op">,</span> <span class="op">*</span><span class="kw">this</span><span class="op">);</span> </span>
<span id="cb57-866"><a href="#cb57-866" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">*</span><span class="kw">this</span><span class="op">;</span></span>
<span id="cb57-867"><a href="#cb57-867" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb57-868"><a href="#cb57-868" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-869"><a href="#cb57-869" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb57-870"><a href="#cb57-870" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb57-871"><a href="#cb57-871" aria-hidden="true" tabindex="-1"></a>    Widget w1<span class="op">(</span><span class="dv">5</span><span class="op">,</span><span class="st">"hello"</span><span class="op">,</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">(</span><span class="dv">10</span><span class="op">)),</span></span>
<span id="cb57-872"><a href="#cb57-872" aria-hidden="true" tabindex="-1"></a>    Widget w2 <span class="op">=</span> w1<span class="op">;</span>     <span class="co">//copy/move assignment operator called</span></span>
<span id="cb57-873"><a href="#cb57-873" aria-hidden="true" tabindex="-1"></a>    Widget w3 <span class="op">=</span> <span class="bu">std::</span>move<span class="op">(</span>w1<span class="op">);</span>  <span class="co">//copy/move assignment operator called</span></span>
<span id="cb57-874"><a href="#cb57-874" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb57-875"><a href="#cb57-875" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-876"><a href="#cb57-876" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb57-877"><a href="#cb57-877" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-878"><a href="#cb57-878" aria-hidden="true" tabindex="-1"></a>In the assignment statement <span class="in">`Widget w2 = w1;`</span>, first the copy constructor is called and the contents of <span class="in">`w1`</span> are copied to <span class="in">`src`</span>, before the control enters the body of <span class="in">`operator=(Widget)`</span>. Whereas the assignment statement <span class="in">`Widget w3 = std::move(w1)`</span> results in the invocation of the move constructor and the contents of <span class="in">`w1`</span> are transferred to <span class="in">`w3`</span> before we execute the body of the assignment operator.</span>
<span id="cb57-879"><a href="#cb57-879" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-880"><a href="#cb57-880" aria-hidden="true" tabindex="-1"></a><span class="fu">## Avoiding unnecessary `std::move()`</span></span>
<span id="cb57-881"><a href="#cb57-881" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-882"><a href="#cb57-882" aria-hidden="true" tabindex="-1"></a>As we saw, returning a local object by value automatically uses move semantics if supported. However, to be safe, programmers might try to force this with an explicit <span class="in">`std::move()`</span>:</span>
<span id="cb57-883"><a href="#cb57-883" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-884"><a href="#cb57-884" aria-hidden="true" tabindex="-1"></a><span class="in">```cpp</span></span>
<span id="cb57-885"><a href="#cb57-885" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>string foo<span class="op">()</span></span>
<span id="cb57-886"><a href="#cb57-886" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb57-887"><a href="#cb57-887" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string s<span class="op">;</span></span>
<span id="cb57-888"><a href="#cb57-888" aria-hidden="true" tabindex="-1"></a>    <span class="co">// do something</span></span>
<span id="cb57-889"><a href="#cb57-889" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb57-890"><a href="#cb57-890" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">std::</span>move<span class="op">(</span>s<span class="op">);</span>    <span class="co">//Bad, don't do this</span></span>
<span id="cb57-891"><a href="#cb57-891" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb57-892"><a href="#cb57-892" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb57-893"><a href="#cb57-893" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-894"><a href="#cb57-894" aria-hidden="true" tabindex="-1"></a>Remember that <span class="in">`std::move()`</span> is just a <span class="in">`static_cast`</span> to an *rvalue* reference. Therefore, `std::move` is an expression that yields the type `std::string&amp;&amp;`. However, this no longer matches the return type and therefore disables *return value optimization*, which usually allows the returned object to be used as a return value. For types where move semantics is not implemented, this might even force the copying of the return value instead of just using the returned object as the return value.</span>
<span id="cb57-895"><a href="#cb57-895" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-896"><a href="#cb57-896" aria-hidden="true" tabindex="-1"></a><span class="fu">## Value categories in detail</span></span>
<span id="cb57-897"><a href="#cb57-897" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-898"><a href="#cb57-898" aria-hidden="true" tabindex="-1"></a>To compile an expression or statement it does not only matter whether the involved types fit. For example, you cannot assign an <span class="in">`int`</span> to an <span class="in">`int`</span>, when on the left hand side of the assignment, an <span class="in">`int`</span> literal is used.</span>
<span id="cb57-899"><a href="#cb57-899" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-900"><a href="#cb57-900" aria-hidden="true" tabindex="-1"></a><span class="in">```cpp</span></span>
<span id="cb57-901"><a href="#cb57-901" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> i<span class="op">{};</span></span>
<span id="cb57-902"><a href="#cb57-902" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> <span class="dv">88</span><span class="op">;</span>     <span class="co">//Ok</span></span>
<span id="cb57-903"><a href="#cb57-903" aria-hidden="true" tabindex="-1"></a><span class="co">//88 = i;   //Error</span></span>
<span id="cb57-904"><a href="#cb57-904" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb57-905"><a href="#cb57-905" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-906"><a href="#cb57-906" aria-hidden="true" tabindex="-1"></a>For this reason, each expression in C++ has a value category. Besides the type, the value category is essential to decide what you can do with an expression.</span>
<span id="cb57-907"><a href="#cb57-907" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-908"><a href="#cb57-908" aria-hidden="true" tabindex="-1"></a><span class="fu">### Value categories since C++11</span></span>
<span id="cb57-909"><a href="#cb57-909" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-910"><a href="#cb57-910" aria-hidden="true" tabindex="-1"></a><span class="al">![Value Categories](move_semantics_14.png)</span></span>
<span id="cb57-911"><a href="#cb57-911" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-912"><a href="#cb57-912" aria-hidden="true" tabindex="-1"></a>We have the following primary categories:</span>
<span id="cb57-913"><a href="#cb57-913" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-914"><a href="#cb57-914" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>*lvalue* (Locator Value)</span>
<span id="cb57-915"><a href="#cb57-915" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>*prvalue* (Pure Readable Value)</span>
<span id="cb57-916"><a href="#cb57-916" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>*xvalue* (Expiring Value)</span>
<span id="cb57-917"><a href="#cb57-917" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-918"><a href="#cb57-918" aria-hidden="true" tabindex="-1"></a>The composite categories are:</span>
<span id="cb57-919"><a href="#cb57-919" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>*glvalue* (generalized *lvalue*) as a common term for *lvalue* or *xvalue*</span>
<span id="cb57-920"><a href="#cb57-920" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>*rvalue* as a common term for *xvalue* or *prvalue* </span>
<span id="cb57-921"><a href="#cb57-921" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-922"><a href="#cb57-922" aria-hidden="true" tabindex="-1"></a>Intuitively, it's easy to understand the primary value categories, if you look at the following diagram:</span>
<span id="cb57-923"><a href="#cb57-923" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-924"><a href="#cb57-924" aria-hidden="true" tabindex="-1"></a><span class="al">![Value Categories](move_semantics_15.png)</span></span>
<span id="cb57-925"><a href="#cb57-925" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-926"><a href="#cb57-926" aria-hidden="true" tabindex="-1"></a>For example,</span>
<span id="cb57-927"><a href="#cb57-927" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-928"><a href="#cb57-928" aria-hidden="true" tabindex="-1"></a><span class="in">```cpp</span></span>
<span id="cb57-929"><a href="#cb57-929" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> X<span class="op">{</span></span>
<span id="cb57-930"><a href="#cb57-930" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb57-931"><a href="#cb57-931" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-932"><a href="#cb57-932" aria-hidden="true" tabindex="-1"></a>X v<span class="op">;</span></span>
<span id="cb57-933"><a href="#cb57-933" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> X c<span class="op">;</span></span>
<span id="cb57-934"><a href="#cb57-934" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-935"><a href="#cb57-935" aria-hidden="true" tabindex="-1"></a>f<span class="op">(</span>v<span class="op">);</span>   <span class="co">//passes a modifiable lvalue</span></span>
<span id="cb57-936"><a href="#cb57-936" aria-hidden="true" tabindex="-1"></a>f<span class="op">(</span>c<span class="op">);</span>   <span class="co">//passes a non-modifiable lvalue</span></span>
<span id="cb57-937"><a href="#cb57-937" aria-hidden="true" tabindex="-1"></a>f<span class="op">(</span>X<span class="op">());</span> <span class="co">//passes a prvalue (old syntax of creating a temporary)</span></span>
<span id="cb57-938"><a href="#cb57-938" aria-hidden="true" tabindex="-1"></a>f<span class="op">(</span>X<span class="op">{});</span> <span class="co">//passes a prvalue (new syntax of creating a temporary)</span></span>
<span id="cb57-939"><a href="#cb57-939" aria-hidden="true" tabindex="-1"></a>f<span class="op">(</span><span class="bu">std::</span>move<span class="op">(</span>v<span class="op">));</span>  <span class="co">//passes an xvalue</span></span>
<span id="cb57-940"><a href="#cb57-940" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb57-941"><a href="#cb57-941" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-942"><a href="#cb57-942" aria-hidden="true" tabindex="-1"></a>Roughly speaking, as a rule of thumb:</span>
<span id="cb57-943"><a href="#cb57-943" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-944"><a href="#cb57-944" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>All names used as expressions are *lvalues*.</span>
<span id="cb57-945"><a href="#cb57-945" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>All string literals used as expressions are *lvalues*. </span>
<span id="cb57-946"><a href="#cb57-946" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>All non-string literals used as expressions are *prvalues*.</span>
<span id="cb57-947"><a href="#cb57-947" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>All temporaries without a name (especially objects returned by value) are *prvalues*. </span>
<span id="cb57-948"><a href="#cb57-948" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>All objects marked with a <span class="in">`std::move`</span> are *xvalues*.</span>
<span id="cb57-949"><a href="#cb57-949" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-950"><a href="#cb57-950" aria-hidden="true" tabindex="-1"></a><span class="fu">### Copy Elison since C++17</span></span>
<span id="cb57-951"><a href="#cb57-951" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-952"><a href="#cb57-952" aria-hidden="true" tabindex="-1"></a>C++17 added mandates to the standard, formally known as :</span>
<span id="cb57-953"><a href="#cb57-953" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-954"><a href="#cb57-954" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Guaranteed copy elison</span>
<span id="cb57-955"><a href="#cb57-955" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Guraranteed return value optimization</span>
<span id="cb57-956"><a href="#cb57-956" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Copy evasion</span>
<span id="cb57-957"><a href="#cb57-957" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-958"><a href="#cb57-958" aria-hidden="true" tabindex="-1"></a>If, in an initialization of an object, when the initializer expression is *prvalue* of the same class type as the variable type, copy elison is guaranteed.</span>
<span id="cb57-959"><a href="#cb57-959" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-960"><a href="#cb57-960" aria-hidden="true" tabindex="-1"></a><span class="in">```cpp</span></span>
<span id="cb57-961"><a href="#cb57-961" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb57-962"><a href="#cb57-962" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-963"><a href="#cb57-963" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> T<span class="op">{</span></span>
<span id="cb57-964"><a href="#cb57-964" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb57-965"><a href="#cb57-965" aria-hidden="true" tabindex="-1"></a>    T<span class="op">(){</span> <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"c'tor T()</span><span class="sc">\n</span><span class="st">"</span><span class="op">;}</span></span>
<span id="cb57-966"><a href="#cb57-966" aria-hidden="true" tabindex="-1"></a>    T<span class="op">(</span><span class="at">const</span> T<span class="op">&amp;</span> t<span class="op">){</span> <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"c'tor T(const T&amp; t)</span><span class="sc">\n</span><span class="st">"</span><span class="op">;}</span></span>
<span id="cb57-967"><a href="#cb57-967" aria-hidden="true" tabindex="-1"></a>    T<span class="op">(</span>T<span class="op">&amp;&amp;</span> t<span class="op">){</span> <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"c'tor T(T&amp;&amp; t)</span><span class="sc">\n</span><span class="st">"</span><span class="op">;}</span></span>
<span id="cb57-968"><a href="#cb57-968" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb57-969"><a href="#cb57-969" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb57-970"><a href="#cb57-970" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-971"><a href="#cb57-971" aria-hidden="true" tabindex="-1"></a><span class="in">```cpp</span></span>
<span id="cb57-972"><a href="#cb57-972" aria-hidden="true" tabindex="-1"></a>T x<span class="op">{</span>T<span class="op">{}};</span></span>
<span id="cb57-973"><a href="#cb57-973" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb57-974"><a href="#cb57-974" aria-hidden="true" tabindex="-1"></a>In C++17, this is equivalent to <span class="in">`T x{};`</span>. The default constructor is invoked only once.</span>
<span id="cb57-975"><a href="#cb57-975" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-976"><a href="#cb57-976" aria-hidden="true" tabindex="-1"></a>Similarly, if, in a <span class="in">`return`</span> statement the operand is a *prvalue* of the same class type as the function return type, copy elison is guaranteed.</span>
<span id="cb57-977"><a href="#cb57-977" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-978"><a href="#cb57-978" aria-hidden="true" tabindex="-1"></a><span class="in">```cpp</span></span>
<span id="cb57-979"><a href="#cb57-979" aria-hidden="true" tabindex="-1"></a>T func<span class="op">()</span></span>
<span id="cb57-980"><a href="#cb57-980" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb57-981"><a href="#cb57-981" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> T<span class="op">{};</span></span>
<span id="cb57-982"><a href="#cb57-982" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb57-983"><a href="#cb57-983" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-984"><a href="#cb57-984" aria-hidden="true" tabindex="-1"></a>T x<span class="op">{</span>func<span class="op">()};</span> <span class="co">//Only one default construction of T allowed here</span></span>
<span id="cb57-985"><a href="#cb57-985" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb57-986"><a href="#cb57-986" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-987"><a href="#cb57-987" aria-hidden="true" tabindex="-1"></a>Under the rules of C++17, under the hood, a *prvalue* will be used only as *unmaterialized* recipe of an object, until actual materialization is required. </span>
<span id="cb57-988"><a href="#cb57-988" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-989"><a href="#cb57-989" aria-hidden="true" tabindex="-1"></a>A *prvalue* is an expression whose evaluation *initializes/materializes* an object. This is called as *temporary materialization conversion*.</span>
<span id="cb57-990"><a href="#cb57-990" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-991"><a href="#cb57-991" aria-hidden="true" tabindex="-1"></a><span class="in">```cpp</span></span>
<span id="cb57-992"><a href="#cb57-992" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span>  T<span class="op">{</span></span>
<span id="cb57-993"><a href="#cb57-993" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb57-994"><a href="#cb57-994" aria-hidden="true" tabindex="-1"></a>    T<span class="op">(){</span></span>
<span id="cb57-995"><a href="#cb57-995" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"c'tor T()</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span></span>
<span id="cb57-996"><a href="#cb57-996" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb57-997"><a href="#cb57-997" aria-hidden="true" tabindex="-1"></a>    <span class="co">//delete move and copy constructors</span></span>
<span id="cb57-998"><a href="#cb57-998" aria-hidden="true" tabindex="-1"></a>    T<span class="op">(</span><span class="at">const</span> T<span class="op">&amp;</span> other<span class="op">)</span> <span class="op">=</span> <span class="kw">delete</span><span class="op">;</span></span>
<span id="cb57-999"><a href="#cb57-999" aria-hidden="true" tabindex="-1"></a>    T<span class="op">(</span>T<span class="op">&amp;&amp;</span> other<span class="op">)</span> <span class="op">=</span> <span class="kw">delete</span><span class="op">;</span></span>
<span id="cb57-1000"><a href="#cb57-1000" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb57-1001"><a href="#cb57-1001" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-1002"><a href="#cb57-1002" aria-hidden="true" tabindex="-1"></a>T make<span class="op">(){</span></span>
<span id="cb57-1003"><a href="#cb57-1003" aria-hidden="true" tabindex="-1"></a>    <span class="co">//Creates the first temporary (pre C++17)</span></span>
<span id="cb57-1004"><a href="#cb57-1004" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> T<span class="op">{};</span></span>
<span id="cb57-1005"><a href="#cb57-1005" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb57-1006"><a href="#cb57-1006" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-1007"><a href="#cb57-1007" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb57-1008"><a href="#cb57-1008" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Construct the second temporary (pre C++17)</span></span>
<span id="cb57-1009"><a href="#cb57-1009" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Copy/move temporary into N using the = operator (pre C++17)</span></span>
<span id="cb57-1010"><a href="#cb57-1010" aria-hidden="true" tabindex="-1"></a>    T t <span class="op">=</span> make<span class="op">();</span></span>
<span id="cb57-1011"><a href="#cb57-1011" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb57-1012"><a href="#cb57-1012" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb57-1013"><a href="#cb57-1013" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb57-1014"><a href="#cb57-1014" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-1015"><a href="#cb57-1015" aria-hidden="true" tabindex="-1"></a>Pre C++17, the function <span class="in">`make()`</span> would construct a temporary within its scope. This temporary would then be copied/moved into another temporary within the <span class="in">`main`</span> scope. Finally, the <span class="in">`operator=`</span> would build <span class="in">`t`</span> via copy/move construction. All of this temporary business would be elided by (RVO) by any decent compiler resulting in <span class="in">`make()`</span> constructing a single object within <span class="in">`t`</span>. However, this elison is somewhat optional, so the compiler must also demand that copy and move constructors exist, just in case. The above code does not compile with any pre C++17 compiler.</span>
<span id="cb57-1016"><a href="#cb57-1016" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-1017"><a href="#cb57-1017" aria-hidden="true" tabindex="-1"></a>Post C++17, <span class="in">`make()`</span> creates an object of type <span class="in">`T`</span> within <span class="in">`t`</span>. Avoiding excessive use of temporary objects is now a language feature and the reliance on compiler optimization is removed. The above code does compiler with a post C++17 compiler. </span>
<span id="cb57-1018"><a href="#cb57-1018" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-1019"><a href="#cb57-1019" aria-hidden="true" tabindex="-1"></a><span class="fu">### Value Categories since C++17</span></span>
<span id="cb57-1020"><a href="#cb57-1020" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-1021"><a href="#cb57-1021" aria-hidden="true" tabindex="-1"></a>C++17 has the same value categories but clarified the semantic meaning of the value categories as described in the figure above.</span>
<span id="cb57-1022"><a href="#cb57-1022" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-1023"><a href="#cb57-1023" aria-hidden="true" tabindex="-1"></a>The key approach for explaining value categories now is that in general, we have two major kinds of expressions:</span>
<span id="cb57-1024"><a href="#cb57-1024" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-1025"><a href="#cb57-1025" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>*glvalues*: expressions for locations of long-living objects or functions.</span>
<span id="cb57-1026"><a href="#cb57-1026" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>*prvalues*: expressions for short-living values for initializations.</span>
<span id="cb57-1027"><a href="#cb57-1027" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-1028"><a href="#cb57-1028" aria-hidden="true" tabindex="-1"></a>An *xvalue* is then considered a special location, representing a (long-living) object, whose resources/values are no longer needed. </span>
<span id="cb57-1029"><a href="#cb57-1029" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-1030"><a href="#cb57-1030" aria-hidden="true" tabindex="-1"></a>Loosely speaking, *prvalues* themselves do not exist somewhere in memory, they do not denote objects. They are used for initialization. In C++17, *prvalues* are not moved from. It doesn't make sense to talk about whether you can steal it's resources. </span>
<span id="cb57-1031"><a href="#cb57-1031" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-1032"><a href="#cb57-1032" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-1033"><a href="#cb57-1033" aria-hidden="true" tabindex="-1"></a><span class="fu">## Perfect Forwarding</span></span>
<span id="cb57-1034"><a href="#cb57-1034" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-1035"><a href="#cb57-1035" aria-hidden="true" tabindex="-1"></a><span class="fu">### Motivation for perfect forwarding</span></span>
<span id="cb57-1036"><a href="#cb57-1036" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-1037"><a href="#cb57-1037" aria-hidden="true" tabindex="-1"></a>Consider a function that declares the parameter as *rvalue* reference:</span>
<span id="cb57-1038"><a href="#cb57-1038" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-1039"><a href="#cb57-1039" aria-hidden="true" tabindex="-1"></a><span class="in">```cpp</span></span>
<span id="cb57-1040"><a href="#cb57-1040" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f<span class="op">(</span><span class="bu">std::</span>string<span class="op">&amp;&amp;</span> s<span class="op">)</span></span>
<span id="cb57-1041"><a href="#cb57-1041" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb57-1042"><a href="#cb57-1042" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Do something</span></span>
<span id="cb57-1043"><a href="#cb57-1043" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"string s : "</span> <span class="op">&lt;&lt;</span> s <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span></span>
<span id="cb57-1044"><a href="#cb57-1044" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb57-1045"><a href="#cb57-1045" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb57-1046"><a href="#cb57-1046" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-1047"><a href="#cb57-1047" aria-hidden="true" tabindex="-1"></a>As we've learned, we can only pass *rvalue*s to this function:</span>
<span id="cb57-1048"><a href="#cb57-1048" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-1049"><a href="#cb57-1049" aria-hidden="true" tabindex="-1"></a><span class="in">```cpp</span></span>
<span id="cb57-1050"><a href="#cb57-1050" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>string s<span class="op">{</span><span class="st">"hello"</span><span class="op">};</span></span>
<span id="cb57-1051"><a href="#cb57-1051" aria-hidden="true" tabindex="-1"></a><span class="co">// f(s);                // Error : passing an lvalue to an rvalue ref</span></span>
<span id="cb57-1052"><a href="#cb57-1052" aria-hidden="true" tabindex="-1"></a>f<span class="op">(</span><span class="bu">std::</span>move<span class="op">(</span>s<span class="op">));</span>        <span class="co">// okay, passing an xvalue</span></span>
<span id="cb57-1053"><a href="#cb57-1053" aria-hidden="true" tabindex="-1"></a>f<span class="op">(</span><span class="bu">std::</span>string<span class="op">(</span><span class="st">"world"</span><span class="op">));</span><span class="co">// okay, passing a prvalue</span></span>
<span id="cb57-1054"><a href="#cb57-1054" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb57-1055"><a href="#cb57-1055" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-1056"><a href="#cb57-1056" aria-hidden="true" tabindex="-1"></a>However, when we use the parameter <span class="in">`s`</span> inside the function <span class="in">`f(std::string&amp;&amp;)`</span>, we are dealing with an object that has a name. This means that we use <span class="in">`s`</span> as an *lvalue*. We can do only what we are allowed to do with an *lvalue*. This means that we cannot call our function recursively. </span>
<span id="cb57-1057"><a href="#cb57-1057" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-1058"><a href="#cb57-1058" aria-hidden="true" tabindex="-1"></a><span class="in">```cpp</span></span>
<span id="cb57-1059"><a href="#cb57-1059" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f<span class="op">(</span><span class="bu">std::</span>string<span class="op">&amp;&amp;</span> s<span class="op">)</span></span>
<span id="cb57-1060"><a href="#cb57-1060" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb57-1061"><a href="#cb57-1061" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Do something</span></span>
<span id="cb57-1062"><a href="#cb57-1062" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"string s : "</span> <span class="op">&lt;&lt;</span> s <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span></span>
<span id="cb57-1063"><a href="#cb57-1063" aria-hidden="true" tabindex="-1"></a>    <span class="co">// f(s);    // Error: passing an lvalue to an rvalue reference</span></span>
<span id="cb57-1064"><a href="#cb57-1064" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb57-1065"><a href="#cb57-1065" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb57-1066"><a href="#cb57-1066" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-1067"><a href="#cb57-1067" aria-hidden="true" tabindex="-1"></a>We have to mark <span class="in">`s`</span> with <span class="in">`std::move()`</span> again:</span>
<span id="cb57-1068"><a href="#cb57-1068" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-1069"><a href="#cb57-1069" aria-hidden="true" tabindex="-1"></a><span class="in">```cpp</span></span>
<span id="cb57-1070"><a href="#cb57-1070" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f<span class="op">(</span><span class="bu">std::</span>string<span class="op">&amp;&amp;</span> s<span class="op">)</span></span>
<span id="cb57-1071"><a href="#cb57-1071" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb57-1072"><a href="#cb57-1072" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Do something</span></span>
<span id="cb57-1073"><a href="#cb57-1073" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"string s : "</span> <span class="op">&lt;&lt;</span> s <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span></span>
<span id="cb57-1074"><a href="#cb57-1074" aria-hidden="true" tabindex="-1"></a>    f<span class="op">(</span><span class="bu">std::</span>move<span class="op">(</span>s<span class="op">));</span>    <span class="co">// Ok, passing an xvalue</span></span>
<span id="cb57-1075"><a href="#cb57-1075" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb57-1076"><a href="#cb57-1076" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb57-1077"><a href="#cb57-1077" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-1078"><a href="#cb57-1078" aria-hidden="true" tabindex="-1"></a>This is the formal specification of the rule that **move semantics is not passed through**. </span>
<span id="cb57-1079"><a href="#cb57-1079" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-1080"><a href="#cb57-1080" aria-hidden="true" tabindex="-1"></a>To forward an object that is passed with move semantics to a function, it not only has to be bound to an *rvalue* reference; you have to use <span class="in">`std::move()`</span> again to forward its move semantics to another function. </span>
<span id="cb57-1081"><a href="#cb57-1081" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-1082"><a href="#cb57-1082" aria-hidden="true" tabindex="-1"></a>For example:</span>
<span id="cb57-1083"><a href="#cb57-1083" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-1084"><a href="#cb57-1084" aria-hidden="true" tabindex="-1"></a><span class="in">```cpp</span></span>
<span id="cb57-1085"><a href="#cb57-1085" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> X<span class="op">{</span></span>
<span id="cb57-1086"><a href="#cb57-1086" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb57-1087"><a href="#cb57-1087" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb57-1088"><a href="#cb57-1088" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-1089"><a href="#cb57-1089" aria-hidden="true" tabindex="-1"></a><span class="co">//forward declarations</span></span>
<span id="cb57-1090"><a href="#cb57-1090" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> foo<span class="op">(</span><span class="at">const</span> X<span class="op">&amp;);</span>     <span class="co">//for constant values (read-only access)</span></span>
<span id="cb57-1091"><a href="#cb57-1091" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> foo<span class="op">(</span>X<span class="op">&amp;);</span>           <span class="co">//for variable values (out parameters)</span></span>
<span id="cb57-1092"><a href="#cb57-1092" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> foo<span class="op">(</span>X<span class="op">&amp;&amp;);</span>          <span class="co">//for values that are no longer used(move semantics)</span></span>
<span id="cb57-1093"><a href="#cb57-1093" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb57-1094"><a href="#cb57-1094" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-1095"><a href="#cb57-1095" aria-hidden="true" tabindex="-1"></a>We have the following rules when calling these functions:</span>
<span id="cb57-1096"><a href="#cb57-1096" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-1097"><a href="#cb57-1097" aria-hidden="true" tabindex="-1"></a><span class="in">```cpp</span></span>
<span id="cb57-1098"><a href="#cb57-1098" aria-hidden="true" tabindex="-1"></a>X v<span class="op">;</span></span>
<span id="cb57-1099"><a href="#cb57-1099" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> X c<span class="op">;</span></span>
<span id="cb57-1100"><a href="#cb57-1100" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-1101"><a href="#cb57-1101" aria-hidden="true" tabindex="-1"></a>foo<span class="op">(</span>v<span class="op">);</span>     <span class="co">//calls foo(X&amp;)</span></span>
<span id="cb57-1102"><a href="#cb57-1102" aria-hidden="true" tabindex="-1"></a>foo<span class="op">(</span>c<span class="op">);</span>     <span class="co">//calls foo(const X&amp;)</span></span>
<span id="cb57-1103"><a href="#cb57-1103" aria-hidden="true" tabindex="-1"></a>foo<span class="op">(</span>X<span class="op">{});</span>   <span class="co">//calls foo(X&amp;&amp;)</span></span>
<span id="cb57-1104"><a href="#cb57-1104" aria-hidden="true" tabindex="-1"></a>foo<span class="op">(</span><span class="bu">std::</span>move<span class="op">(</span>v<span class="op">))</span>   <span class="co">//calls foo(X&amp;&amp;)</span></span>
<span id="cb57-1105"><a href="#cb57-1105" aria-hidden="true" tabindex="-1"></a>foo<span class="op">(</span><span class="bu">std::</span>move<span class="op">(</span>c<span class="op">))</span>   <span class="co">//calls foo(const X&amp;)</span></span>
<span id="cb57-1106"><a href="#cb57-1106" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb57-1107"><a href="#cb57-1107" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-1108"><a href="#cb57-1108" aria-hidden="true" tabindex="-1"></a>Now, assume that we want to call <span class="in">`foo()`</span> for the same arguments indirectly via a helper function <span class="in">`callFoo()`</span>. That helper function would also need the three overloads.</span>
<span id="cb57-1109"><a href="#cb57-1109" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-1110"><a href="#cb57-1110" aria-hidden="true" tabindex="-1"></a><span class="in">```cpp</span></span>
<span id="cb57-1111"><a href="#cb57-1111" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> callFoo<span class="op">(</span><span class="at">const</span> X<span class="op">&amp;</span> arg<span class="op">){</span>     <span class="co">//arg binds to all const objects</span></span>
<span id="cb57-1112"><a href="#cb57-1112" aria-hidden="true" tabindex="-1"></a>    foo<span class="op">(</span>arg<span class="op">);</span>                   <span class="co">//calls foo(const X&amp;)</span></span>
<span id="cb57-1113"><a href="#cb57-1113" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb57-1114"><a href="#cb57-1114" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-1115"><a href="#cb57-1115" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> callFoo<span class="op">(</span>X<span class="op">&amp;</span> arg<span class="op">)</span>            <span class="co">//arg binds to lvalues</span></span>
<span id="cb57-1116"><a href="#cb57-1116" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb57-1117"><a href="#cb57-1117" aria-hidden="true" tabindex="-1"></a>    foo<span class="op">(</span>arg<span class="op">);</span>                   <span class="co">//calls foo(&amp;)</span></span>
<span id="cb57-1118"><a href="#cb57-1118" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb57-1119"><a href="#cb57-1119" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-1120"><a href="#cb57-1120" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> callFoo<span class="op">(</span>X<span class="op">&amp;&amp;</span> arg<span class="op">){</span>          <span class="co">//arg binds to rvalues</span></span>
<span id="cb57-1121"><a href="#cb57-1121" aria-hidden="true" tabindex="-1"></a>    foo<span class="op">(</span><span class="bu">std::</span>move<span class="op">(</span>arg<span class="op">));</span>        <span class="co">//needs std::move() to call foo(X&amp;&amp;)</span></span>
<span id="cb57-1122"><a href="#cb57-1122" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb57-1123"><a href="#cb57-1123" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb57-1124"><a href="#cb57-1124" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-1125"><a href="#cb57-1125" aria-hidden="true" tabindex="-1"></a>In all cases, <span class="in">`arg`</span> is used as an *lvalue* (being an object with a name). The first version forwards it as a <span class="in">`const`</span> object, but the other two cases implement two different ways to forward the non-<span class="in">`const`</span> argument. </span>
<span id="cb57-1126"><a href="#cb57-1126" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-1127"><a href="#cb57-1127" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Arguments declared as *lvalue* references (that bind to objects that do not have move semantics) are passed as they are.</span>
<span id="cb57-1128"><a href="#cb57-1128" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Arguments declared as *rvalue* references (that bind to objects that have move semantics) are passed with <span class="in">`std::move`</span>. </span>
<span id="cb57-1129"><a href="#cb57-1129" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-1130"><a href="#cb57-1130" aria-hidden="true" tabindex="-1"></a>This allows us to forward move semantics perfectly: for any argument that is passed with move semantics, we keep the move semantics; but we do not add move semantics when we get an argument that does not have it. </span>
<span id="cb57-1131"><a href="#cb57-1131" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-1132"><a href="#cb57-1132" aria-hidden="true" tabindex="-1"></a>Only with this implementation is the use of <span class="in">`callFoo`</span> to call <span class="in">`foo`</span> transparent.</span>
<span id="cb57-1133"><a href="#cb57-1133" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-1134"><a href="#cb57-1134" aria-hidden="true" tabindex="-1"></a><span class="in">```cpp</span></span>
<span id="cb57-1135"><a href="#cb57-1135" aria-hidden="true" tabindex="-1"></a>X v<span class="op">;</span></span>
<span id="cb57-1136"><a href="#cb57-1136" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> X c<span class="op">;</span></span>
<span id="cb57-1137"><a href="#cb57-1137" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-1138"><a href="#cb57-1138" aria-hidden="true" tabindex="-1"></a>callFoo<span class="op">(</span>v<span class="op">);</span>     <span class="co">//calls foo(X&amp;)</span></span>
<span id="cb57-1139"><a href="#cb57-1139" aria-hidden="true" tabindex="-1"></a>callFoo<span class="op">(</span>c<span class="op">);</span>     <span class="co">//calls foo(const X&amp;)</span></span>
<span id="cb57-1140"><a href="#cb57-1140" aria-hidden="true" tabindex="-1"></a>callFoo<span class="op">(</span>X<span class="op">{});</span>   <span class="co">//calls foo(X&amp;&amp;)</span></span>
<span id="cb57-1141"><a href="#cb57-1141" aria-hidden="true" tabindex="-1"></a>callFoo<span class="op">(</span><span class="bu">std::</span>move<span class="op">(</span>v<span class="op">))</span>   <span class="co">//calls foo(X&amp;&amp;)</span></span>
<span id="cb57-1142"><a href="#cb57-1142" aria-hidden="true" tabindex="-1"></a>callFoo<span class="op">(</span><span class="bu">std::</span>move<span class="op">(</span>c<span class="op">))</span>   <span class="co">//calls foo(const X&amp;)</span></span>
<span id="cb57-1143"><a href="#cb57-1143" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb57-1144"><a href="#cb57-1144" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-1145"><a href="#cb57-1145" aria-hidden="true" tabindex="-1"></a>Remember that an *rvalue* passed to an *rvalue* reference becomes an *lvalue* when used, which means that we need `std::move()` to pass it as an *rvalue* again. However, we cannot use `std::move()` everywhere. For the other overloads, using `std::move()` would call the overload of `foo()` for *rvalue* references when an *lvalue* is passed. </span>
<span id="cb57-1146"><a href="#cb57-1146" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-1147"><a href="#cb57-1147" aria-hidden="true" tabindex="-1"></a>For *perfect forwarding* in generic code, we would always need all these overloads for each parameter. To support all combinations, this means having $3^2 = 9$ overloads for $2$ generic arguments and $3^3 = 27$ overloads for $3$ generic arguments.</span>
<span id="cb57-1148"><a href="#cb57-1148" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-1149"><a href="#cb57-1149" aria-hidden="true" tabindex="-1"></a>Therefore, C++11 introduced a special way to *perfectly forward* without any overloads but still keeping the type and the value category.</span>
<span id="cb57-1150"><a href="#cb57-1150" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-1151"><a href="#cb57-1151" aria-hidden="true" tabindex="-1"></a><span class="fu">### Implementing perfect forwarding</span></span>
<span id="cb57-1152"><a href="#cb57-1152" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-1153"><a href="#cb57-1153" aria-hidden="true" tabindex="-1"></a>To avoid overloading functions for parameters with different value categories, C++ introduced the mechanism of perfect forwarding. You need three things:</span>
<span id="cb57-1154"><a href="#cb57-1154" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-1155"><a href="#cb57-1155" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>Take the call parameter as a pure *rvalue* reference (delcared with <span class="in">`&amp;&amp;`</span> but without <span class="in">`const`</span> or <span class="in">`volatile`</span>)</span>
<span id="cb57-1156"><a href="#cb57-1156" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>The type of the parameter has to be a template parameter of the function. </span>
<span id="cb57-1157"><a href="#cb57-1157" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>When forwarding the parameter to another function, use a helper function called <span class="in">`std::forward&lt;&gt;()`</span> which is declared in <span class="in">`&lt;utility&gt;`</span>.</span>
<span id="cb57-1158"><a href="#cb57-1158" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-1159"><a href="#cb57-1159" aria-hidden="true" tabindex="-1"></a>You have to implement a function that perfectly forwards an argument as follows:</span>
<span id="cb57-1160"><a href="#cb57-1160" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-1161"><a href="#cb57-1161" aria-hidden="true" tabindex="-1"></a><span class="in">```cpp</span></span>
<span id="cb57-1162"><a href="#cb57-1162" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb57-1163"><a href="#cb57-1163" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> callFoo<span class="op">(</span>T<span class="op">&amp;&amp;</span> arg<span class="op">)</span></span>
<span id="cb57-1164"><a href="#cb57-1164" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb57-1165"><a href="#cb57-1165" aria-hidden="true" tabindex="-1"></a>    foo<span class="op">(</span><span class="bu">std::</span>forward<span class="op">&lt;</span>T<span class="op">&gt;(</span>arg<span class="op">));</span></span>
<span id="cb57-1166"><a href="#cb57-1166" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb57-1167"><a href="#cb57-1167" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb57-1168"><a href="#cb57-1168" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-1169"><a href="#cb57-1169" aria-hidden="true" tabindex="-1"></a><span class="in">`std::forward&lt;&gt;()`</span> is defined as a conditional <span class="in">`std::move()`</span>, so that we get the same behavior as the three (or four) overloads of <span class="in">`callFoo()`</span> above:</span>
<span id="cb57-1170"><a href="#cb57-1170" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-1171"><a href="#cb57-1171" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>If we pass an *rvalue* to <span class="in">`arg`</span>, we have the same effect as calling <span class="in">`foo(std::move(arg))`</span>.</span>
<span id="cb57-1172"><a href="#cb57-1172" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>If we pass an *lvalue* to <span class="in">`arg`</span>, we have the same effect as calling <span class="in">`foo(arg)`</span>. </span>
<span id="cb57-1173"><a href="#cb57-1173" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-1174"><a href="#cb57-1174" aria-hidden="true" tabindex="-1"></a>What exactly is happening here, is pretty tricky and needs a careful explanation.</span>
<span id="cb57-1175"><a href="#cb57-1175" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-1176"><a href="#cb57-1176" aria-hidden="true" tabindex="-1"></a><span class="fu">### Universal and Forwarding references</span></span>
<span id="cb57-1177"><a href="#cb57-1177" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-1178"><a href="#cb57-1178" aria-hidden="true" tabindex="-1"></a>First note that we declare <span class="in">`arg`</span> as an *rvalue* reference parameter:</span>
<span id="cb57-1179"><a href="#cb57-1179" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-1180"><a href="#cb57-1180" aria-hidden="true" tabindex="-1"></a><span class="in">```cpp</span></span>
<span id="cb57-1181"><a href="#cb57-1181" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb57-1182"><a href="#cb57-1182" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> callFoo<span class="op">(</span>T<span class="op">&amp;&amp;</span> arg<span class="op">)</span></span>
<span id="cb57-1183"><a href="#cb57-1183" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb57-1184"><a href="#cb57-1184" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-1185"><a href="#cb57-1185" aria-hidden="true" tabindex="-1"></a>This might give the impression that the rules of *rvalue* references apply. However, that is not the case. An *rvalue* reference (not qualified with `const` or `volatile`) of a function parameter does not follow the rules of ordinary *rvalue* references. It is a different thing. </span></code><button title="Copy to Clipboard" class="code-copy-button" data-in-quarto-modal=""><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->




</body></html>