---
title: "Type Traits"
author: "Quasar"
date: "2024-11-25"
categories: [C++]      
image: "cpp.jpg"
toc: true
toc-depth: 3
format:
    html:
        code-tools: true
        code-block-border-left: true
        code-annotations: below
        highlight-style: pygments
---

*Meta-programs* are programs that treat other programs as data. They could be other programs or itself. A *meta-function* is not a function, but a `class` or `struct`. *Metafunctions* are not part of the language and have no formal language support. They exist purely as an idiomatic use of the existing language features. Now, since their use is not enforced by the language, their used has to be dictated by a convention. Over the years, the C++ community has created common set of standard conventions. Actually this work goes back all the way to [Boost `type_traits`](https://www.boost.org/doc/libs/1_79_0/libs/type_traits/doc/html/index.html).

*Metafunctions* are not functions. Technically, they are a class with zero or more template parameters and zero+ return types and values. The convention is that a *metafunction* should return just one thing, like a regular function. The convention was developed over time, so there are plenty of existing examples that do not follow this convention. More modern *metafunctions* do follow this convention. 

## How do we `return` from a metafunction

If we have to return a value, basically, we are going to expose a `public` field named `value`.

```cpp
template<typename T>
struct TheAnswer{
    static constexpr int value = 42;
};
```

And if we are going to return a type, we are going to expose a `public` field named `type`.

```cpp
template<typename T>
struct Echo{
    using type = T;
};
```

Now, here's kind of the difference between regular functions and *metafunctions*. A regular function in C++ always works on some form of data and it's always going to return to you some piece of data as well. Amongst *metafunctions*, we have value *metafunctions* that work on values like we are used to and then we have *metafunctions* that work entirely on types and they yield back some type to you. And so in the both of the examples above, we return something by exposing the public members of a class.

## Value metafunctions

A value *metafunction* is kind of like a simple regular function. Let's look at a simple regular function - the integer identity function. 

```cpp
int int_identity(int x)
{
    return x;
}

assert(42 == int_identity(42));
```

This function just applies the identity transformation on any integer passed to it, and spits out the same number. A simple *metafunction* for identity - we can call it the `intIdentity` metafunction would look like this:

```cpp
template<int X>
struct intIdentity{
    static constexpr int value = X;
};

static_assert(42 == IntIdentity<42>::value);
```

We see that it's not that much different. You return a value by having a `static` data-member called `value` and it has the *metafunction*'s return value. `IntIdentity<42>::value` is where we are calling the *metafunction*. Now, this convention needs to be adhered to, because if you give your *metafunction* some other name such as `my_value`, for example, if you write:

```cpp
template<int X>
struct intIdentity{
    static constexpr int my_value = X;
};

static_assert(42 == IntIdentity<42>::value);
```

it's not going to work well with other things. 

### Generic Identity Function 

Let's look at the generic identity function.

```cpp
template<typename T>
T identity(T x){
    return x;
}

//Returned type will be 42
assert(42 == identity(42));

// Returned type will be unsigned long long
assert(42ul == identity(42ul))
```

This is just a function that will be an identity for any type.