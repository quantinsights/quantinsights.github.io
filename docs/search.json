[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Quant Insights",
    "section": "",
    "text": "Cox-Ingersoll-Ross (CIR) model\n\n\n\ncox-ingersoll-ross-model\n\n\ninterest-rate-modelling\n\n\n\n\n\n\n\nQuasar\n\n\nMay 8, 2024\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBlack Scholes Formula for a European Call\n\n\n\nvanilla-option\n\n\n\n\n\n\n\nQuasar\n\n\nMay 3, 2024\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nExploring Option Greeks\n\n\n\nvanilla-option\n\n\n\n\n\n\n\nQuasar\n\n\nMay 3, 2024\n\n\n\n\n\n\n\n\n\n\n\n\nWelcome To My Blog\n\n\n\nnews\n\n\n\n\n\n\n\nTristan O’Malley\n\n\nApr 30, 2024\n\n\n\n\n\n\n\n\n\n\n\n\nC++ Refresher - Part I\n\n\n\nC++\n\n\n\n\n\n\n\nQuasar\n\n\nDec 18, 2023\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/exploring-option-greeks/index.html",
    "href": "posts/exploring-option-greeks/index.html",
    "title": "Exploring Option Greeks",
    "section": "",
    "text": "I derived the Black-Scholes formula for European style vanilla FX options in a previous post here. The Black-Scholes model \\(Bl(S_0,K,T,r_{DOM},r_{FOR},\\sigma)\\) equipped with a single flat volatility parameter \\(\\sigma\\) produces option prices which are NOT consistent with the observed market prices of FX options across different strikes and maturities.\nAlthough, the BS model suffers many flaws, it is still often used, at least for quoting purposes. Since all of the other inputs into the model - market data variables such as the stock price \\(S_0\\), the domestic depo rate \\(r_{DOM}\\), the foreign depo rate \\(r_{FOR}\\), and the parameters such as option strike \\(K\\), the time-to-maturity \\(T\\), can be either seen in the market or are known constants, we can easily solve for the value \\(\\sigma_{\\text{imp}}\\) of the parameter \\(\\sigma\\) such that:\n\\[Bl(S_0,K,T,r_{DOM},r_{FOR},\\sigma_{\\text{imp}}) = V_{\\text{market}}\\]\nThis value \\(\\sigma_{\\text{imp}}\\) implied from the market price of the option is called the implied volatility.\nThus, although the BS model suffers from flaws, it is mainly used as a quote converter. In the FX options market, option prices are quoted in terms of implied volatilities. The BS formula is used to convert implied vols \\(\\sigma_{\\text{imp}}\\) to prices and vice versa. The delta hedge to be exchanged between counterparties is calculated according to the BS formula, and this is also true for the Vega hedge of various exotic options. In many cases, the model is also used to run trading books.\nIn this note, I explore various delta conventions and derive the greeks. Check out FX Vol smile by Wyestup! The entire concept of the FX volatility smile is based on the parametrization with respect to delta."
  },
  {
    "objectID": "posts/exploring-option-greeks/index.html#introduction.",
    "href": "posts/exploring-option-greeks/index.html#introduction.",
    "title": "Exploring Option Greeks",
    "section": "",
    "text": "I derived the Black-Scholes formula for European style vanilla FX options in a previous post here. The Black-Scholes model \\(Bl(S_0,K,T,r_{DOM},r_{FOR},\\sigma)\\) equipped with a single flat volatility parameter \\(\\sigma\\) produces option prices which are NOT consistent with the observed market prices of FX options across different strikes and maturities.\nAlthough, the BS model suffers many flaws, it is still often used, at least for quoting purposes. Since all of the other inputs into the model - market data variables such as the stock price \\(S_0\\), the domestic depo rate \\(r_{DOM}\\), the foreign depo rate \\(r_{FOR}\\), and the parameters such as option strike \\(K\\), the time-to-maturity \\(T\\), can be either seen in the market or are known constants, we can easily solve for the value \\(\\sigma_{\\text{imp}}\\) of the parameter \\(\\sigma\\) such that:\n\\[Bl(S_0,K,T,r_{DOM},r_{FOR},\\sigma_{\\text{imp}}) = V_{\\text{market}}\\]\nThis value \\(\\sigma_{\\text{imp}}\\) implied from the market price of the option is called the implied volatility.\nThus, although the BS model suffers from flaws, it is mainly used as a quote converter. In the FX options market, option prices are quoted in terms of implied volatilities. The BS formula is used to convert implied vols \\(\\sigma_{\\text{imp}}\\) to prices and vice versa. The delta hedge to be exchanged between counterparties is calculated according to the BS formula, and this is also true for the Vega hedge of various exotic options. In many cases, the model is also used to run trading books.\nIn this note, I explore various delta conventions and derive the greeks. Check out FX Vol smile by Wyestup! The entire concept of the FX volatility smile is based on the parametrization with respect to delta."
  },
  {
    "objectID": "posts/exploring-option-greeks/index.html#quote-style-conversions.",
    "href": "posts/exploring-option-greeks/index.html#quote-style-conversions.",
    "title": "Exploring Option Greeks",
    "section": "Quote style conversions.",
    "text": "Quote style conversions.\nIn FX markets, options are quoted in one of 4 quote styles - domestic per foreign (d/f), percentage foreign (%f), percentage domestic (%d) and foreign per domestic (f/d).\nThe standard Black-Scholes formula is:\n\\[\n\\begin{align*}\nV_{d/f} &= \\omega [S_0 e^{-r_{FOR} T} \\Phi(d_{+}) - K e^{-r_{DOM}T} \\Phi(d_{-})\\\\\n&= \\omega e^{-r_{DOM}T}[F \\Phi(d_{+}) - K  \\Phi(d_{-})]\n\\end{align*}\n\\]\n\nImplementing the Bl Calculator and Option Greeks.\nimport numpy as np\nfrom scipy.stats import norm\nfrom enum import Enum\nimport datetime as dt\n\nclass CallPut(Enum):\n    CALL_OPTION = 1\n    PUT_OPTION = -1\n\nclass BlackCalculator:\n    \"\"\"Implements the Black formula to price a vanilla option\"\"\"\n    def __init__(\n        self,\n        s_t : float,\n        strike : float,\n        today : float,\n        expiry : float,\n        r_dom : float,\n        r_for : float,\n        sigma : float            \n    )\n        self._s_t = s_t\n        self._strike = strike\n        self._today = today\n        self._expiry = expiry\n        self._r_dom = r_dom\n        self._r_for = r_for\n        self._sigma = sigma\n\n    def at_the_money_forward(\n        self,\n    ) -&gt; float :\n        \"\"\"Computes the at-the-money forward\"\"\"\n\n        foreign_df = np.exp(self._r_for * (expiry - today))\n        domestic_df = np.exp(self._r_dom * (expiry - today))\n        fwd_points = foreign_df / domestic_df\n        return self._s_t * fwd_points \n            \n    def d_plus(S_t,K,t,T,r_DOM,r_FOR,sigma):\n        F = at_the_money_forward(S_t,K,t,T,r_DOM,r_FOR,sigma)\n        return (np.log(F/K) + (T-t)*(sigma**2)/2)/(sigma * np.sqrt(T - t))\n\n    def d_minus(S_t,K,t,T,r_DOM,r_FOR,sigma):\n        F = at_the_money_forward(S_t,K,t,T,r_DOM,r_FOR,sigma)\n        return (np.log(F/K) - (T-t)*(sigma**2)/2)/(sigma * np.sqrt(T - t))\n\n    def pv(S_t,K,t,T,r_DOM,r_FOR,sigma, CCY1Notional,callPut):\n        F = at_the_money_forward(S_t,K,t,T,r_DOM,r_FOR,sigma)\n        omega = callPut.value\n        d_plus = dPlus(S_t,K,t,T,r_DOM,r_FOR,sigma)\n        d_minus = dMinus(S_t,K,t,T,r_DOM,r_FOR,sigma)\n        domesticDF = np.exp(-r_DOM*(T-t))\n        \n        undiscountedPrice = omega* (F * norm.cdf(omega * d_plus) - K * norm.cdf(omega * d_minus))\n        pv = domesticDF * undiscountedPrice * CCY1Notional\n        return pv"
  },
  {
    "objectID": "posts/black-scholes-formula-for-a-european-call/index.html",
    "href": "posts/black-scholes-formula-for-a-european-call/index.html",
    "title": "Black Scholes Formula for a European Call",
    "section": "",
    "text": "The mean rate of growth of all assets under the risk-neutral measure \\(\\mathbb{Q}\\) is risk-free rate \\(r\\).\nThe stock price process has the \\(\\mathbb{Q}\\)-dynamics:\n\\[dS_t = r S_t dt + \\sigma S_t dW^{\\mathbb{Q}}(t) \\tag{1}\\]\nThe solution to this SDE is:\n\\[S(t) = S(0)\\exp \\left[ \\left(r - \\frac{\\sigma^2}{2}\\right)t + \\sigma W^{\\mathbb{Q}}(t)\\right]\\tag{2}\\]\nConsider a call option with maturity time \\(T\\). Then, the stock price at \\(T\\) is:\n\\[S(T) = S(0)\\exp \\left[ \\left(r - \\frac{\\sigma^2}{2}\\right)T + \\sigma W^{\\mathbb{Q}}(T)\\right]\\tag{3}\\]\nDenoting \\(\\tau = T - t\\), we have:\n\\[S(T) = S(t)\\exp \\left[ \\left(r - \\frac{\\sigma^2}{2}\\right)\\tau + \\sigma (W^{\\mathbb{Q}}(T)-W^{\\mathbb{Q}}(t))\\right]\\tag{4}\\]\nSince, \\(W^{\\mathbb{Q}}(T)-W^{\\mathbb{Q}}(t)\\) is a gaussian random variable with mean \\(0\\) and variance \\(\\tau = T-t\\), we can write \\(-(W^{\\mathbb{Q}}(T)-W^{\\mathbb{Q}}(t)) = \\sqrt{\\tau}Z\\), where \\(Z\\) is a standard normal random variable. Thus,\n\\[S(T) = S(t)\\exp \\left[ \\left(r - \\frac{\\sigma^2}{2}\\right)\\tau - \\sigma \\sqrt{\\tau}Z\\right]\\tag{5}\\]\nBy the risk-neutral pricing formula, the time-\\(t\\) price of the European call option is:\n\\[\n\\begin{align*}\nV(t) &= \\mathbb{E}^{\\mathbb{Q}}\\left[e^{-r(T-t)}\\max(S(T) - K,0)|\\mathcal{F}_t\\right] \\\\\n&= e^{-r(T-t)}\\mathbb{E}^{\\mathbb{Q}}\\left[\\left(S(t)\\exp \\left\\{ \\left(r - \\frac{\\sigma^2}{2}\\right)\\tau - \\sigma \\sqrt{\\tau}Z\\right\\} - K\\right)\\cdot 1_{S(T)&gt;K}|\\mathcal{F}_t\\right]\\\\\n&= e^{-r(T-t)}\\mathbb{E}^{\\mathbb{Q}}\\left[\\left(S(t)\\exp \\left\\{ \\left(r - \\frac{\\sigma^2}{2}\\right)\\tau - \\sigma \\sqrt{\\tau}Z\\right\\} - K\\right)\\cdot 1_{S_t e^{(r-\\sigma^2/2) - \\sigma\\tau Z}&gt;K}\\right]\n\\end{align*}\n\\]\nIn the last-but-one step, everything is \\(\\mathcal{F}_t\\)-measurable.\nThe domain of integration is all \\(z\\) satisfying:\n\\[\n\\begin{align*}\nS(t)\\exp \\left[ \\left(r - \\frac{\\sigma^2}{2}\\right)\\tau - \\sigma \\sqrt{\\tau}Z\\right] &&gt;  K\\\\\n\\log \\frac{S(t)}{K} + \\left(r - \\frac{\\sigma^2}{2}\\right)\\tau  &&gt; \\sigma \\sqrt{\\tau}Z\n\\end{align*}\n\\]\nDefine \\(d_{-} = \\frac{\\log \\frac{S(t)}{K} +(r-\\sigma^2/2)\\tau}{\\sigma\\sqrt{\\tau}}\\).\nThen, the region \\(D\\) is:\n\\[Z &lt; d_{-}\\]\nSo, we can expand the expectation in (6) as:\n\\[\n\\begin{align*}\nV(t) &=  \\int_{-\\infty}^{d_{-}} e^{-r\\tau}\\left(S(t)\\exp \\left\\{\\left(r - \\frac{\\sigma^2}{2}\\right)\\tau - \\sigma \\sqrt{\\tau}z \\right\\} - K\\right)d\\mathbb{Q} \\\\\n&=\\int_{-\\infty}^{d_{-}} e^{-r\\tau}\\left(S(t)\\exp \\left\\{ \\left(r - \\frac{\\sigma^2}{2}\\right)\\tau - \\sigma \\sqrt{\\tau}z\\right\\} - K\\right) f_Z^{\\mathbb{Q}}(z) dz \\\\\n&=\\frac{1}{\\sqrt{2\\pi}}\\int_{-\\infty}^{d_{-}}e^{-r\\tau} \\left(S(t)\\exp \\left\\{ \\left(r - \\frac{\\sigma^2}{2}\\right)\\tau - \\sigma \\sqrt{\\tau}z\\right\\} - K\\right) e^{-\\frac{z^2}{2}} dz\n\\\\\n&=\\frac{1}{\\sqrt{2\\pi}}\\int_{-\\infty}^{d_{-}} e^{-r\\tau}S(t)\\exp \\left\\{ \\left(r - \\frac{\\sigma^2}{2}\\right)\\tau - \\sigma \\sqrt{\\tau}z\\right\\}e^{-\\frac{z^2}{2}} dz \\\\\n&- Ke^{-r\\tau}\\cdot \\frac{1}{\\sqrt{2\\pi}}\\int_{-\\infty}^{d_{-}} e^{-\\frac{z^2}{2}} dz \\\\\n&=\\frac{1}{\\sqrt{2\\pi}}\\int_{-\\infty}^{d_{-}} e^{-r\\tau}S(t)\\exp \\left\\{ \\left(r - \\frac{\\sigma^2}{2}\\right)\\tau - \\sigma \\sqrt{\\tau}z\\right\\}e^{-\\frac{z^2}{2}} dz - Ke^{-r\\tau}\\Phi(d_{-})\\tag{7}\n\\end{align*}\n\\]\nWe have:\n\\[\n\\begin{align*}\n&\\exp \\left[-\\frac{\\sigma^2}{2}\\tau - \\sigma\\sqrt{\\tau} z - \\frac{z^2}{2}\\right]\\\\\n=&\\exp\\left[-\\frac{\\sigma^2 \\tau + 2\\sigma \\sqrt{\\tau}z + z^2}{2}\\right]\\\\\n=&\\exp\\left[-\\frac{(z+\\sigma\\sqrt{\\tau})^2}{2}\\right] \\tag{8}\n\\end{align*}\n\\]\nSubstituting (8) into (7), we get:\n\\[\n\\begin{align*}\nV(t) &=\\frac{1}{\\sqrt{2\\pi}}\\int_{-\\infty}^{d_{-}} S(t)\\exp\\left[-\\frac{(z+\\sigma\\sqrt{\\tau})^2}{2}\\right] dz - Ke^{-r\\tau}\\Phi(d_{-}) \\tag{9}\n\\end{align*}\n\\]\nPut \\(u = z + \\sigma \\sqrt{\\tau}\\). Then, \\(dz = du\\). The upper limit of integration is \\(d_{+} = d_{-} + \\sigma \\sqrt{\\tau}\\), which is:\n\\[\n\\begin{align*}\nd_{+} &=\\frac{\\log \\frac{S(t)}{K} + (r-\\sigma^2/2)\\tau}{\\sigma \\sqrt{\\tau}} + \\sigma \\sqrt{\\tau}\\\\\n&= \\frac{\\log \\frac{S(t)}{K} + (r+\\sigma^2/2)\\tau}{\\sigma \\sqrt{\\tau}}\n\\end{align*}\n\\]\nSo, the equation (9) can be written as:\n\\[\n\\begin{align*}\nV(t) &=\\frac{1}{\\sqrt{2\\pi}}\\int_{-\\infty}^{d_{+}} S(t)e^{-\\frac{u^2}{2}} du - Ke^{-r\\tau}\\Phi(d_{-}) \\\\\n&= S(t)\\Phi(d_{+}) - Ke^{-r\\tau} \\Phi(d_{-})\n\\end{align*}\n\\]"
  },
  {
    "objectID": "posts/black-scholes-formula-for-a-european-call/index.html#the-black-scholes-formula-for-a-european-call",
    "href": "posts/black-scholes-formula-for-a-european-call/index.html#the-black-scholes-formula-for-a-european-call",
    "title": "Black Scholes Formula for a European Call",
    "section": "",
    "text": "The mean rate of growth of all assets under the risk-neutral measure \\(\\mathbb{Q}\\) is risk-free rate \\(r\\).\nThe stock price process has the \\(\\mathbb{Q}\\)-dynamics:\n\\[dS_t = r S_t dt + \\sigma S_t dW^{\\mathbb{Q}}(t) \\tag{1}\\]\nThe solution to this SDE is:\n\\[S(t) = S(0)\\exp \\left[ \\left(r - \\frac{\\sigma^2}{2}\\right)t + \\sigma W^{\\mathbb{Q}}(t)\\right]\\tag{2}\\]\nConsider a call option with maturity time \\(T\\). Then, the stock price at \\(T\\) is:\n\\[S(T) = S(0)\\exp \\left[ \\left(r - \\frac{\\sigma^2}{2}\\right)T + \\sigma W^{\\mathbb{Q}}(T)\\right]\\tag{3}\\]\nDenoting \\(\\tau = T - t\\), we have:\n\\[S(T) = S(t)\\exp \\left[ \\left(r - \\frac{\\sigma^2}{2}\\right)\\tau + \\sigma (W^{\\mathbb{Q}}(T)-W^{\\mathbb{Q}}(t))\\right]\\tag{4}\\]\nSince, \\(W^{\\mathbb{Q}}(T)-W^{\\mathbb{Q}}(t)\\) is a gaussian random variable with mean \\(0\\) and variance \\(\\tau = T-t\\), we can write \\(-(W^{\\mathbb{Q}}(T)-W^{\\mathbb{Q}}(t)) = \\sqrt{\\tau}Z\\), where \\(Z\\) is a standard normal random variable. Thus,\n\\[S(T) = S(t)\\exp \\left[ \\left(r - \\frac{\\sigma^2}{2}\\right)\\tau - \\sigma \\sqrt{\\tau}Z\\right]\\tag{5}\\]\nBy the risk-neutral pricing formula, the time-\\(t\\) price of the European call option is:\n\\[\n\\begin{align*}\nV(t) &= \\mathbb{E}^{\\mathbb{Q}}\\left[e^{-r(T-t)}\\max(S(T) - K,0)|\\mathcal{F}_t\\right] \\\\\n&= e^{-r(T-t)}\\mathbb{E}^{\\mathbb{Q}}\\left[\\left(S(t)\\exp \\left\\{ \\left(r - \\frac{\\sigma^2}{2}\\right)\\tau - \\sigma \\sqrt{\\tau}Z\\right\\} - K\\right)\\cdot 1_{S(T)&gt;K}|\\mathcal{F}_t\\right]\\\\\n&= e^{-r(T-t)}\\mathbb{E}^{\\mathbb{Q}}\\left[\\left(S(t)\\exp \\left\\{ \\left(r - \\frac{\\sigma^2}{2}\\right)\\tau - \\sigma \\sqrt{\\tau}Z\\right\\} - K\\right)\\cdot 1_{S_t e^{(r-\\sigma^2/2) - \\sigma\\tau Z}&gt;K}\\right]\n\\end{align*}\n\\]\nIn the last-but-one step, everything is \\(\\mathcal{F}_t\\)-measurable.\nThe domain of integration is all \\(z\\) satisfying:\n\\[\n\\begin{align*}\nS(t)\\exp \\left[ \\left(r - \\frac{\\sigma^2}{2}\\right)\\tau - \\sigma \\sqrt{\\tau}Z\\right] &&gt;  K\\\\\n\\log \\frac{S(t)}{K} + \\left(r - \\frac{\\sigma^2}{2}\\right)\\tau  &&gt; \\sigma \\sqrt{\\tau}Z\n\\end{align*}\n\\]\nDefine \\(d_{-} = \\frac{\\log \\frac{S(t)}{K} +(r-\\sigma^2/2)\\tau}{\\sigma\\sqrt{\\tau}}\\).\nThen, the region \\(D\\) is:\n\\[Z &lt; d_{-}\\]\nSo, we can expand the expectation in (6) as:\n\\[\n\\begin{align*}\nV(t) &=  \\int_{-\\infty}^{d_{-}} e^{-r\\tau}\\left(S(t)\\exp \\left\\{\\left(r - \\frac{\\sigma^2}{2}\\right)\\tau - \\sigma \\sqrt{\\tau}z \\right\\} - K\\right)d\\mathbb{Q} \\\\\n&=\\int_{-\\infty}^{d_{-}} e^{-r\\tau}\\left(S(t)\\exp \\left\\{ \\left(r - \\frac{\\sigma^2}{2}\\right)\\tau - \\sigma \\sqrt{\\tau}z\\right\\} - K\\right) f_Z^{\\mathbb{Q}}(z) dz \\\\\n&=\\frac{1}{\\sqrt{2\\pi}}\\int_{-\\infty}^{d_{-}}e^{-r\\tau} \\left(S(t)\\exp \\left\\{ \\left(r - \\frac{\\sigma^2}{2}\\right)\\tau - \\sigma \\sqrt{\\tau}z\\right\\} - K\\right) e^{-\\frac{z^2}{2}} dz\n\\\\\n&=\\frac{1}{\\sqrt{2\\pi}}\\int_{-\\infty}^{d_{-}} e^{-r\\tau}S(t)\\exp \\left\\{ \\left(r - \\frac{\\sigma^2}{2}\\right)\\tau - \\sigma \\sqrt{\\tau}z\\right\\}e^{-\\frac{z^2}{2}} dz \\\\\n&- Ke^{-r\\tau}\\cdot \\frac{1}{\\sqrt{2\\pi}}\\int_{-\\infty}^{d_{-}} e^{-\\frac{z^2}{2}} dz \\\\\n&=\\frac{1}{\\sqrt{2\\pi}}\\int_{-\\infty}^{d_{-}} e^{-r\\tau}S(t)\\exp \\left\\{ \\left(r - \\frac{\\sigma^2}{2}\\right)\\tau - \\sigma \\sqrt{\\tau}z\\right\\}e^{-\\frac{z^2}{2}} dz - Ke^{-r\\tau}\\Phi(d_{-})\\tag{7}\n\\end{align*}\n\\]\nWe have:\n\\[\n\\begin{align*}\n&\\exp \\left[-\\frac{\\sigma^2}{2}\\tau - \\sigma\\sqrt{\\tau} z - \\frac{z^2}{2}\\right]\\\\\n=&\\exp\\left[-\\frac{\\sigma^2 \\tau + 2\\sigma \\sqrt{\\tau}z + z^2}{2}\\right]\\\\\n=&\\exp\\left[-\\frac{(z+\\sigma\\sqrt{\\tau})^2}{2}\\right] \\tag{8}\n\\end{align*}\n\\]\nSubstituting (8) into (7), we get:\n\\[\n\\begin{align*}\nV(t) &=\\frac{1}{\\sqrt{2\\pi}}\\int_{-\\infty}^{d_{-}} S(t)\\exp\\left[-\\frac{(z+\\sigma\\sqrt{\\tau})^2}{2}\\right] dz - Ke^{-r\\tau}\\Phi(d_{-}) \\tag{9}\n\\end{align*}\n\\]\nPut \\(u = z + \\sigma \\sqrt{\\tau}\\). Then, \\(dz = du\\). The upper limit of integration is \\(d_{+} = d_{-} + \\sigma \\sqrt{\\tau}\\), which is:\n\\[\n\\begin{align*}\nd_{+} &=\\frac{\\log \\frac{S(t)}{K} + (r-\\sigma^2/2)\\tau}{\\sigma \\sqrt{\\tau}} + \\sigma \\sqrt{\\tau}\\\\\n&= \\frac{\\log \\frac{S(t)}{K} + (r+\\sigma^2/2)\\tau}{\\sigma \\sqrt{\\tau}}\n\\end{align*}\n\\]\nSo, the equation (9) can be written as:\n\\[\n\\begin{align*}\nV(t) &=\\frac{1}{\\sqrt{2\\pi}}\\int_{-\\infty}^{d_{+}} S(t)e^{-\\frac{u^2}{2}} du - Ke^{-r\\tau}\\Phi(d_{-}) \\\\\n&= S(t)\\Phi(d_{+}) - Ke^{-r\\tau} \\Phi(d_{-})\n\\end{align*}\n\\]"
  },
  {
    "objectID": "posts/black-scholes-formula-for-a-european-call/index.html#appendix",
    "href": "posts/black-scholes-formula-for-a-european-call/index.html#appendix",
    "title": "Black Scholes Formula for a European Call",
    "section": "Appendix",
    "text": "Appendix\nLemma. The discounted stock-price process \\((D(t)S(t),t\\geq 0)\\) is a \\(\\mathbb{Q}\\)-martingale.\nSuppose we have a risk-free money-market account with the dynamics:\n\\[dM(t) = rM(t)dt\\]\nand the dynamics of the stock-price process is:\n\\[dS(t) = \\mu S(t) dt + \\sigma S(t) dW^\\mathbb{P}(t)\\]\nThus, the discounting process is:\n\\[dD(t) = -rD(t)dt\\]\nwhere the instantaneous interest rate \\(r\\) is a constant.\nBy Ito’s product rule:\n\\[\n\\begin{align*}\nd(D(t)S(t)) &= dD(t) S(t) + D(t)dS(t)\\\\\n&= -rD(t)S(t)dt + D(t)(\\mu S(t) dt + \\sigma S(t)dW^\\mathbb{P}(t))\\\\\n&= D(t)S(t)((\\mu - r)dt + \\sigma dW^\\mathbb{P}(t))\\\\\n\\end{align*}\n\\]\nWe are interested to write:\n\\[\n\\begin{align*}\nd(D(t)S(t)) &= D(t)S(t)\\sigma dW^\\mathbb{Q}(t)\n\\end{align*}\n\\]\nComparing the right hand sides, we have: \\[\n\\begin{align*}\n\\sigma dW^\\mathbb{Q}(t) &= (\\mu - r)dt + \\sigma dW^\\mathbb{P}(t)\n\\end{align*}\n\\]\nLet’s define:\n\\[dW^\\mathbb{Q}(t) = \\theta dt + dW^\\mathbb{P}(t)\\]\nwhere \\(\\theta = (\\mu - r)/\\sigma\\) and the Radon-Nikodym derivative \\(Z\\) as:\n\\[Z = \\exp\\left[-\\int_0^T \\theta dW^\\mathbb{P}(u) - \\frac{1}{2}\\int_0^T \\theta^2 du \\right]\\]\nBy the Girsanov theorem, \\(W^\\mathbb{Q}(t)\\) is a \\(\\mathbb{Q}\\)-standard brownian motion. Hence, we can write:\n\\[\n\\begin{align*}\nd(D(t)S(t)) &= D(t)S(t)\\sigma dW^\\mathbb{Q}(t)\n\\end{align*}\n\\]\nSince the Ito integral is a martingale, \\(D(t)S(t)\\) is a \\(\\mathbb{Q}\\)-martingale. This closes the proof.\nClaim. The \\(\\mathbb{Q}\\)-dynamics of \\(S_t\\) satisfy :\n\\[dS(t) = rS(t) dt + \\sigma S(t) dW^{\\mathbb{Q}}(t)\\]\nProof.\nWe have:\n\\[\n\\begin{align*}dS(t) &= d(S(t)D(t)M(t))\\\\\n&= d(S(t)D(t))M(t) + S(t)D(t)dM(t)\\\\\n&= D(t)M(t) S(t)\\sigma dW^\\mathbb{Q}(t) + S(t)D(t)r M(t)dt\\\\\n&= S(t)(rdt + \\sigma dW^\\mathbb{Q}(t))\n\\end{align*}\n\\]\nWe can easily solve this linear SDE; its solution is:\n\\[S(t) = S(0)\\exp\\left[\\left(\\mu - \\frac{\\sigma^2}{2}\\right)dt + \\sigma W^\\mathbb{Q}(t)\\right]\\]"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  },
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Welcome To My Blog",
    "section": "",
    "text": "This is the first post in a Quarto blog. Welcome!\n\nSince this post doesn’t specify an explicit image, the first image in the post will be used in the listing page of posts."
  },
  {
    "objectID": "posts/c++-refresher-part-1/index.html",
    "href": "posts/c++-refresher-part-1/index.html",
    "title": "C++ Refresher - Part I",
    "section": "",
    "text": "A dangling pointer is a pointer variable that still contains the address to the free store memory that has already been deallocated using delete or delete[]. Dereferencing a dangling pointer makes you read from, or even worse write to memory that might already be allocated to and used by other parts of the program, resulting in all kinds of unpredictable results.\nMultiple deallocations which occur when you deallocate an already deallocated memory (and hence dangling) pointer for a second time is a recipe for disaster.\nOne basic strategy to guard yourself against dangling pointers is to always reset a pointer to nullptr, after the memory it points to is released. However, in more complex programs, different parts of the code often collaborate by accessing the same memory - an object or an array of objects - all through distinct copies of the same pointer. In such cases, our simple strategy falls short. Which part of the code is going to call delete/delete[]? And when? How do you ensure that no other part of the code is still using the same dynamically allocated memory.\n\n\n\nA dynamically allocated array, allocated using new[], is captured in a regular pointer cariable. But, so is a single allocated value that is allocated using new.\ndouble* single_df {new double {0.95}};\ndouble* array_of_dfs {new double[3] {1.00, 0.95, 0.90}};\nAfter this the compiler has no way to distinguish between the two, especially once such a pointer gets passed around different parts of the program. This means that the following two statements will compile without error.\ndelete[] single_df;\ndelete array_of_dfs;\nEvery new must be paired with a single delete; every new[] must be paired with a single delete[].\n\n\n\nA memory leak occurs when you allocate memory using new or new[] and fail to release it. If you lose the address of free store memory you have allocated by overwriting the address in the pointer you were using to access it, for instance, you have a memory leak.\nWhen it comes to scope, pointers are just like any other variable. The lifetime of a pointer extends from the point at which you define it in a block to the closing brace of the block. After that it no longer exists, the free store goes out of scope and it’s no longer possible to delete the memory.\nIt’s still relatively easy to see, where you’ve simply forgotten to use delete to free memory when use of the memory ceases at a point close to where you allocated it, but you’d be surprised how often programmers make mistakes like this, especially if, for instance, return statements creep in between allocation and deallocation of your variable. And naturally, memory leaks are even more difficult to spot in complex programs, where memory may be allocated in part of the the program and should be released in a completely separate part.\nOne basic strategy for avoiding memory leaks is to immediately add delete operation at an appropriate place each time you use the new operator. But this strategy by no means is fail-safe. Even C++ programmers are fallible creatures.\n\n\n\nMemory fragmentation can arise in programs that frequently dynamically allocate and release memory blocks. Each time, the new operator is used, it allocates a contiguous block of bytes. If you create and destroy many memory blocks of different sizes, it’s possible to arrive at a situation in which the allocated memory is interspersed with small blocks of free memory, none of which is large enough to accomodate a new memory allocation request by your program. The aggregate of the free memory can be quite large, but if all the individual blocks are small (smaller than a current allocation request), the allocation request will fail."
  },
  {
    "objectID": "posts/c++-refresher-part-1/index.html#raw-pointers-and-smart-pointers.",
    "href": "posts/c++-refresher-part-1/index.html#raw-pointers-and-smart-pointers.",
    "title": "C++ Refresher - Part I",
    "section": "Raw pointers and Smart Pointers.",
    "text": "Raw pointers and Smart Pointers.\nPointer types int*, double* are referred to as raw pointers because variables of these types contain nothing more than an address. A raw pointer can store the address of an automatic variable or a memory-block allocated in the free-store.\nA smart pointer is an object that mimics a raw pointer in that, it contains an address, and you can use it in the same way in many respects. Smart pointers are normally used only to store the address of memory allocated in the free store. A smart pointer does much more than a raw pointer, though. The most notable feature of a smart pointer, is that we don’t have to worry about using the delete or delete[] operator to free memory. It will be released automatically, when it is no longer needed. This means that dangling pointers and multiple deallocations, allocation/deallocation mismatches and memory leaks will no longer be possible.\n\nA std::unique_ptr&lt;T&gt; object behaves as a pointer to type T and is unique in the sense that there can be only one single unique_ptr&lt;&gt; object containing the same address. In other words, there can never be two or more unique_ptr&lt;T&gt; objects pointing to the same memory address at the same time. A unique_ptr&lt;&gt; object is said to own the object it points to exclusively. The uniqueness is enforced by the fact, that a compiler will never allow you to copy a unique_ptr&lt;&gt;.\nA std::shared_ptr&lt;T&gt; object also behaves as a pointer to type T, but in contrast with unique_ptr&lt;T&gt; there can be any number of shared_ptr&lt;&gt; objects that allow shared ownership of an object in the free-store. At any given moment, the number of shared_ptr&lt;&gt; objects that contain a given address in time is known by the runtime. This is called reference counting. The reference count for a shared_ptr&lt;&gt; containing a given free store address is incremented each time a new shared_ptr object is creating containing that address, and its decremented when a shared_ptr containing the address is destroyed or assigned to point to a different address. When there are no shared_ptr objects containing a given address, the reference count will have dropped to zero, and the memory for the object at that address is released automatically. All shared_ptr&lt;&gt; objects that point to the same address have access to the the count of how many there are.\nA weak_ptr&lt;T&gt; is linked to a shared_ptr&lt;T&gt; and contains the same address. Creating a weak_ptr&lt;&gt; does not increment the reference count associated with the linked shared_ptr&lt;&gt; object, though, so a weak_ptr&lt;&gt; does not prevent the object pointed to from being destroyed. Its memory will still be released when the last shared_ptr&lt;&gt; referencing it is destroyed or reassigned to point to a different address, even when associated weak_ptr&lt;&gt; objects still exist. If this happens, the weak_ptr&lt;&gt; will nevertheless not contain a dangling pointer, atleast not one that you could inadvertently access. The reason is that you cannot access the address encapsulated by a weak_ptr&lt;T&gt; directly. The compiler forces you to first create a shared_ptr&lt;T&gt; object out of it that refers to the same address. If the memory address for the weak_ptr&lt;&gt; is still valid, forcing you to create a shared_ptr&lt;&gt; first ensures that the reference count is again incremented and that the pointer can be used safely again. If the memory is released already, however, this operation will result in a shared_ptr&lt;T&gt; containing a nullptr.\n\nOne use for having weak_ptr&lt;&gt; objects is to avoid so called reference cycles with shared_ptr&lt;&gt; objects. Conceptually, a reference cycle is where a shared_ptr&lt;Y&gt; inside the object x points to some other object y that contains a shared_ptr&lt;X&gt;, which points back to x. With this situation, neither x nor y can be destroyed. In practice, this may occur in many ways. weak_ptr allows you to break such cycles. Another use of weak pointers is in the implementation of object caches.\nIn the below code snippet, the destructors ~A() and ~B() are not invoked even when the objects shrd_a and shrd_b go out of scope.\n#include &lt;iostream&gt;\n#include &lt;memory&gt;\n\nusing namespace std;\n\nclass A;\nclass B;\n\nclass A{\n    public:\n    shared_ptr&lt;B&gt; m_b;\n    A() {cout &lt;&lt; \"\\nA()\";}\n    ~A() {cout &lt;&lt; \"\\n~A()\";}\n};\n\nclass B{\n    public:\n    shared_ptr&lt;A&gt; m_a;\n    B () {cout &lt;&lt; \"\\nB()\";}\n    ~B() {cout &lt;&lt; \"\\n~B()\";}\n};\n\nint main()\n{\n    {\n        shared_ptr&lt;A&gt; shrd_a {make_shared&lt;A&gt;()}; //A's ref count = 1\n        shared_ptr&lt;B&gt; shrd_b {make_shared&lt;B&gt;()}; //B's ref count = 1\n    \n        shrd_a-&gt;m_b = shrd_b; //B's ref count = 2\n        shrd_b-&gt;m_a = shrd_a; //A's ref count = 2\n    }\n    //shrd_a and shrd_b go out of scope and are destroyed\n    // A's ref count = 1\n    // B's ref count = 1\n    // ((Memory of A, B is deallocated only when ref count drops to 0))\n    return 0;\n}\nA()\nB()\nTo solve it, the programmer needs to be aware of the ownership relationship among the objects, or needs to invent an ownership relationship, if no such ownership exists. The above C++ code can be changed so that A owns B:\n#include &lt;iostream&gt;\n#include &lt;memory&gt;\n\nusing namespace std;\n\nclass A;\nclass B;\n\nclass A{\n    public:\n    shared_ptr&lt;B&gt; m_b;\n    A() {cout &lt;&lt; \"\\nA()\";}\n    ~A() {cout &lt;&lt; \"\\n~A()\";}\n};\n\nclass B{\n    public:\n    weak_ptr&lt;A&gt; m_a;\n    B () {cout &lt;&lt; \"\\nB()\";}\n    ~B() {cout &lt;&lt; \"\\n~B()\";}\n};\n\nint main()\n{\n    {\n        shared_ptr&lt;A&gt; shrd_a {make_shared&lt;A&gt;()}; //A's ref count = 1\n        shared_ptr&lt;B&gt; shrd_b {make_shared&lt;B&gt;()}; //B's ref count = 1\n    \n        shrd_a-&gt;m_b = shrd_b; //B's ref count = 2\n        shrd_b-&gt;m_a = shrd_a; //A's ref count = 1\n    }\n    //shrd_a and shrd_b go out of scope and are destroyed\n    // A's ref count = 0\n    // B's ref count = 1\n    // A is destroyed\n    // B's ref count = 0\n    // B is destroyed\n    //\n    return 0;\n}\nA()\nB()\n~A()\n~B()\n\nUsing unique_ptr&lt;T&gt; and shared_ptr&lt;T&gt; pointers.\nA unique_ptr&lt;T&gt; object stores an address uniquely, so the value to which it points is owned exlusively by the unique_ptr&lt;T&gt; smart pointer. When the unique_ptr&lt;T&gt; is destroyed, so is the value to which it points. Like all smart pointers, a unique_ptr&lt;&gt; is most useful when working with dynamically allocated objects. Objects then should not be shared by multiple parts of the program, or where the lifetime of the dynamic pobject is naturally tied to a single other object in your program.\nOne common use for a unique_ptr&lt;&gt; is to hold something called a polymorphic pointer, which in essence is a pointer to a dynamically allocated object that can be of any number of related class types.\nTo create and initialize a double variable on the free-store, we write:\n#include &lt;iostream&gt;\n#include &lt;memory&gt;\n\nint main()\n{\n    std::unique_ptr&lt;double&gt; pDiscountFactor {std::make_unique&lt;double&gt;(0.95)};\n    \n    std::cout &lt;&lt; \"Discount Factor = \" &lt;&lt; *pDiscountFactor;\n    \n    return 0;\n}\nDiscount Factor = 0.95\nThe memory allocated on the free store holding 0.95 is released once pDiscountFactor goes out of scope and is destroyed after the return statement.\nThe below code snippet shows how smart pointers work.\n#include &lt;iostream&gt;\n#include &lt;memory&gt;\n\nclass X{\n    public:\n        X()\n        {\n          std::cout &lt;&lt; \"\\nX created\";\n        }\n        \n        ~X()\n        {\n          std::cout &lt;&lt; \"\\nX destroyed\";\n        }\n};\n\nclass Y{\n    \n    public:\n        Y()\n        {\n          std::cout &lt;&lt; \"\\nY created\";\n        }\n        \n        ~Y()\n        {\n          std::cout &lt;&lt; \"\\nY destroyed\";\n        } \n};\n\nint main()\n{\n    std::cout &lt;&lt; \"\\nInside main\";\n    std::shared_ptr&lt;Y&gt; sPtrY1 {std::make_shared&lt;Y&gt;()};\n    \n    \n    {\n        //inner scope\n        std::cout &lt;&lt; \"\\nInside inner\";\n        \n        std::unique_ptr&lt;X&gt; uPtrX1 {std::make_unique&lt;X&gt;()};\n        std::shared_ptr&lt;Y&gt; sPtrY2 {sPtrY1};\n        \n        // copy assignment and copy construction is not allowed on unique_ptr objects\n        //std::unique_ptr&lt;X&gt; uPtrX2 = uPtrX1;\n        \n        std::cout &lt;&lt; \"\\nExiting inner\";\n    }\n    \n    std::cout &lt;&lt; \"\\nExiting main\";\n    return 0;\n}\nInside main\nY created\nInside inner\nX created\nExiting inner\nX destroyed\nExiting main\nY destroyed"
  },
  {
    "objectID": "posts/c++-refresher-part-1/index.html#references.",
    "href": "posts/c++-refresher-part-1/index.html#references.",
    "title": "C++ Refresher - Part I",
    "section": "References.",
    "text": "References.\nA reference is a name that you can use as an alias for another variable. Unlike a pointer, you cannot declare a reference and not initialize it. Because a reference is an alias, the variable which it is an alias must be provided when the reference is initialized. Also, a reference cannot be modified to be an alias for something else.\n#include &lt;iostream&gt;\n#include &lt;memory&gt;\n\n\nvoid swap(int& a, int& b)\n{\n    int temp {a};\n    a = b;\n    b = temp;\n}\n\nint main()\n{\n    int x {10}; \n    int y {15};\n    \n    std::cout &lt;&lt; \"\\n Before swap:\";\n    std::cout &lt;&lt; \"\\n x = \" &lt;&lt; x ;\n    std::cout &lt;&lt; \"\\n y = \" &lt;&lt; y;\n    \n    swap(x,y);\n    \n    std::cout &lt;&lt; \"\\n After swap:\";\n    std::cout &lt;&lt; \"\\n x = \" &lt;&lt; x ;\n    std::cout &lt;&lt; \"\\n y = \" &lt;&lt; y;\n    return 0;\n}\n Before swap:\n x = 10\n y = 15\n After swap:\n x = 15\n y = 10\nNever return a pointer or reference to an automatic stack-allocated local variable from within a function. Automatic variables are destroyed and the stack is popped, once the control goes outside the scope in which they are declared."
  },
  {
    "objectID": "posts/c++-refresher-part-1/index.html#function-templates.",
    "href": "posts/c++-refresher-part-1/index.html#function-templates.",
    "title": "C++ Refresher - Part I",
    "section": "Function Templates.",
    "text": "Function Templates.\nA function template itself is not a definition of a function; it is a blueprint or a recipe for definining an entire family of functions. A function template is a parametric function definition, where a particular function instance is created by one or more parameter values. The compiler uses a function template to generate a function definition when necessary. If it is never necessary, no code results from the template. A function definition that is generated from a template is an instance or instantiation of the template.\nThe parameters of a function template are usually data-types, where an instance can be generated for a parameter value of type int, for example, and another with parameter valuer of type string. But parameters are not necessarily types. They can be other things such as a dimension, for example.\ntemplate &lt;class T&gt;\nT larger(T a, T b)\n{\n    return a &gt; b ? a : b;\n}\nThe compiler creates instances of the template from any statement that uses the larger() function. Here’s an example:\nint main()\n{\n    std::cout &lt;&lt; \"\\nLarger of 1.50 and 2.50 is : \"  &lt;&lt; larger(1.5,2.5);\n    return 0;\n}\nLarger of 1.50 and 2.50 is : 2.5\nYou just use the function in the normal way. You don’t need to specify a value for the template parameter T. The compiler deduces the type that is to replace T from the arguments in the larger function call. This mechanism is referred to as template argument deduction. The arguments to larger() are literals of type double, so this call causes the compiler to search for an existing definition of larger() with double parameters. If it doesn’t find one, the compiler creates this version of larger() from the template by susbstituting double for T in the template definition.\nThe resulting function accepts arguments of type double and returs a double value.\nThe compiler makes sure to generate each template instance only once. If a subsequent function call requires the same instance, then it calls the instance that exists.\n\nTemplate type parameters.\nThe name of the template type parameter can be used anywhere in the template’s function signature, return type and body. It is a placeholder for a type and can thus be put in any context you would normally put a concrete type.\ntemplate &lt;class T&gt;\nconst T& larger(const T& a,const T& b)\n{\n    return a &gt; b ? a : b;\n}\n\n\nFunction Template overloading.\nTemplated functions can be overloaded.\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\ntemplate &lt;typename T&gt;\nconst T& largest(const T& a,const T& b)\n{\n    return a &gt; b ? a : b;\n}\n\ntemplate &lt;typename T&gt;\nconst T largest(const std::vector&lt;T&gt;& data)\n{\n    T max {};\n    for(auto v:data)\n    {\n        if (v &gt;= max)\n            max = v;\n    }\n    return max;\n}\n\nint main()\n{\n    std::cout &lt;&lt; \"\\nLarger of 1.50 and 2.50 is : \"  &lt;&lt; largest(1.5,2.5);\n    std::vector&lt;int&gt; data {\n        2, 5, 8, 4, 7, 3\n    };\n    std::cout &lt;&lt; \"\\nLargest of [2,5,8,4,7,3] is : \" &lt;&lt; largest(data);\n    return 0;\n}\nLarger of 1.50 and 2.50 is : 2.5\nLargest of [2,5,8,4,7,3] is : 8"
  },
  {
    "objectID": "posts/c++-refresher-part-1/index.html#classes-and-object-oriented-programming.",
    "href": "posts/c++-refresher-part-1/index.html#classes-and-object-oriented-programming.",
    "title": "C++ Refresher - Part I",
    "section": "Classes and Object Oriented Programming.",
    "text": "Classes and Object Oriented Programming.\nAn interesting exercise to write a Matrix&lt;T&gt; class.\n// Matrix.h\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;initializer_list&gt;\n#include &lt;stdexcept&gt;\n\ntemplate &lt;typename T = double&gt;\nclass Matrix {\npublic:\n    //Default constructor\n    Matrix() : Matrix(3, 3) {}\n\n    //Parameterized constructor with number of rows, cols as \n    // as arguments.\n    Matrix(std::size_t m, std::size_t n) : m_rows(m), m_cols(n)\n    {\n        m_data.resize(m_rows * m_cols, 0);\n    }\n\n    //Parameterized constructor with matrix elements provided \n    // in brace initializer lists.\n    Matrix(std::initializer_list&lt;std::initializer_list&lt;T&gt;&gt; m) {\n        int i{}, j{};\n        for (auto row : m)\n        {\n            for (auto el : row)\n            {\n                m_data.push_back(el);\n                if (i == 0)\n                    ++j;\n            }\n            ++i;\n        }\n\n        m_rows = i;\n        m_cols = j;\n    }\n\n\n    //Copy constructor\n    Matrix(const Matrix& A) : m_rows{ A.m_rows }, m_cols{ A.m_cols }, m_data{ A.m_data } {}\n\n    std::size_t rows() const\n    {\n        return m_rows;\n    }\n\n    std::size_t cols() const\n    {\n        return m_cols;\n    }\n\n    T& at(int i, int j)\n    {\n        return m_data[i * m_cols + j];\n    }\n\n    const T& at(int i, int j) const\n    {\n        return m_data[i * m_cols + j];\n    }\n\n    T& operator()(int i, int j)\n    {\n        if (i &lt; 0)\n            throw std::invalid_argument(\"The row index must be non-negative!\");\n\n        if (j &lt; 0)\n            throw std::invalid_argument(\"The column index must be non-negative!\");\n\n        if (i &gt;= m_rows)\n            throw std::invalid_argument(\"The row index must be less than \" + m_rows);\n\n        if (j &gt;= m_cols)\n            throw std::invalid_argument(\"The col index must be less than \" + m_cols);\n\n        return at(i, j);\n    }\n\n    const T operator()(int i, int j) const\n    {\n        if (i &lt; 0)\n            throw std::invalid_argument(\"The row index must be non-negative!\");\n\n        if (j &lt; 0)\n            throw std::invalid_argument(\"The column index must be non-negative!\");\n\n        if (i &gt;= m_rows)\n            throw std::invalid_argument(\"The row index must be less than \" + m_rows);\n\n        if (j &gt;= m_cols)\n            throw std::invalid_argument(\"The col index must be less than \" + m_cols);\n\n        return at(i, j);\n    }\n\n    const Matrix operator+(const Matrix& mat)\n    {\n        if (mat.rows() != rows())\n            throw std::runtime_error(\"In A + B, matrices A, B should have the same number of rows!\");\n\n        if (mat.cols() != cols())\n            throw std::runtime_error(\"In A + B, matrices A, B should have the same number of cols!\");\n\n        Matrix result(rows(), cols());\n\n        for (int i{}; i &lt; rows(); ++i)\n        {\n            for (int j{}; j &lt; cols(); ++j)\n            {\n                result(i, j) = at(i, j) + mat(i, j);\n            }\n        }\n        return result;\n    }\n\n    const Matrix operator-(const Matrix& mat)\n    {\n        if (mat.rows() != rows())\n            throw std::runtime_error(\"In A - B, matrices A, B should have the same number of rows!\");\n\n        if (mat.cols() != cols())\n            throw std::runtime_error(\"In A - B, matrices A, B should have the same number of cols!\");\n\n        Matrix result(rows(), cols());\n\n        for (int i{}; i &lt; rows(); ++i)\n        {\n            for (int j{}; j &lt; cols(); ++j)\n            {\n                result(i, j) = at(i, j) - mat(i, j);\n            }\n        }\n        return result;\n    }\n\n    Matrix& operator=(const Matrix& mat)\n    {\n        m_data = mat.m_data;\n        m_rows = mat.rows();\n        m_cols = mat.cols();\n\n        return *this;\n    }\n\n    const Matrix operator*(const Matrix& mat)\n    {\n        if (cols() != mat.rows())\n            throw std::runtime_error(\"In A * B, cols of A must equal rows of B!\");\n\n        Matrix result{ rows(), mat.cols() };\n\n        for (int i{}; i &lt; rows(); ++i)\n        {\n            for (int k{}; k &lt; cols(); ++k)\n            {\n                for (int j{}; j &lt; mat.cols(); ++j)\n                {\n                    result(i, j) += at(i, k) * mat(k, j);\n                }\n            }\n        }\n\n        return result;\n    }\n\n\nprivate:\n    std::vector&lt;T&gt; m_data{};\n    int m_rows;\n    int m_cols;\n};\n//Matrix.cpp\n\n#include &lt;iostream&gt;\n#include \"Matrix.h\"\n\nint main()\n{\n    Matrix&lt;double&gt; A{\n        {1, 0},\n        {0, 1}\n    };\n\n    Matrix&lt;double&gt; B{\n        {1, 0},\n        {0, 1}\n    };\n\n    Matrix&lt;double&gt; result = A + B;\n\n    std::cout &lt;&lt; result(0, 0) &lt;&lt; \"\\t\" &lt;&lt; result(0, 1) &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; result(1, 0) &lt;&lt; \"\\t\" &lt;&lt; result(1, 1);\n\n    return 0;\n}\n\nAccess specifiers and class hierarchies.\n\nThe private members of the base class are inaccessible to the derived class.\nWhen the base class specifier is public, the access status of the inherited members remains unchanged. Thus, inherited public members are public, and inherited protected members are protected in a derived class.\nWhen the base class specifier is protected, both public and protected members of the base class are inherited as protected members in the child class.\nWhen the base class specifier is private, inherited public and protected members become private to the derived class, so that they’re accessible by member functions of the the derived class, but they cannot be accessed if they’re inherited in another derived class.\n\n\n\nConstructors and Destructors in derived classes.\nEvery constructor of the derived class always starts by invoking a constructor of the base class. And that base class constructor then invokes the constructor of its base class, and so on.\nRemark. You cannot initialize the member variables of a base class in the initialization list for the derived class constructor. Not even if those members are public or protected.\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;string&gt;\n\nclass A{\n    public:\n    A(){\n        std::cout &lt;&lt; \"\\nInside A's constructor\";\n    }\n    ~A()\n    {\n        std::cout &lt;&lt; \"\\nInside A's destructor\";\n    }\n};\n\nclass B : public A\n{\n    public:\n    B()\n    {\n        std::cout &lt;&lt; \"\\nInside B's constructor\";\n    }\n    \n    ~B()\n    {\n        std::cout &lt;&lt; \"\\nInside B's destructor\";\n    }\n};\n\nint main()\n{\n    B b;\n    \n    return 0;\n}\nInside A's constructor\nInside B's constructor\nInside B's destructor\nInside A's destructor\nSuppose you have a base class Parent, two child classes Child_1 and Child_2 that inherit from Parent and a Grandchild class that inherits from Child_1 and Child_2. This is the diamond problem, named after the shape of such inheritance diagrams. The Grandchild inherits two copies of Parent : one through Child_1 and another through Child_2.\nTo prevent the duplication of the base class, we identify to the compiler that the base class should appear only once within the derived class. We do this by specifying the class as a virtual base class using the virtual keword. The Child_1 and Child_2 classes would be defined like this:\nclass Child_1 : public virtual Parent\n{\n    //...\n};\n\nclass Child_2 : public virtual Parent\n{\n    //...\n};\n\n\nPolymorphism.\nEvery derived class object is a base class object. So, you can use a base class pointer/reference to store the address of a derived class object. It is easy to implement dynamic dispatch through virtual methods.\nThe below code snippet is instructive in understanding run-time polymorphism.\n#include &lt;memory&gt;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass A {\npublic:\n    void foo() {\n        std::cout &lt;&lt; \"\\nGreetings from a!\";\n    }\n};\n\nclass B :public A {\npublic:\n    virtual void foo()\n    {\n        std::cout &lt;&lt; \"\\nGreetings from b!\";\n    }\n};\n\n\nclass C : public B {\nprivate:\n    virtual void foo()\n    {\n        std::cout &lt;&lt; \"\\nGreetings from c!\";\n    }\n};\n\nclass D : public C {\npublic:\n    void foo()\n    {\n        std::cout &lt;&lt; \"\\nGreetings from d!\";\n    }\n};\n\nint main()\n{\n    std::shared_ptr&lt;A&gt; a_ptr = std::make_shared&lt;D&gt;();\n    a_ptr -&gt;foo();\n    \n    std::shared_ptr&lt;B&gt; b_ptr = std::make_shared&lt;D&gt;();\n    b_ptr -&gt;foo();\n    \n    std::shared_ptr&lt;C&gt; c_ptr = std::make_shared&lt;D&gt;();\n    //c_ptr -&gt;foo();  //will not compile, foo() is a private member is not inherited by D\n    \n    std::shared_ptr&lt;D&gt; d_ptr = std::make_shared&lt;D&gt;();\n    d_ptr -&gt;foo();\n}\nGreetings from a!\nGreetings from d!\nGreetings from d!\nWhen you specify a function as virtual in a base class, you indicate to the compiler that you want dynamic binding for function calls in any class that’s derived from this base class. A function that you specify as virtual in the base class will be virtual in all classes that directly or indirectly derive from the base class. This is the case, whether or not you specify the function as virtual in the derived class.\nThe call to a virtual function using an object is always resolved statically. You only get dybamic resolution of calls to virtual functions through a pointer or a reference. Consider the below code snippet:\n    D d{};\n    \n    A& aRef = d;\n    B& bRef = d;\n    A a; B b;\n    \n    aRef.foo();\n    bRef.foo();\n    \n    a.foo();\n    b.foo();\nGreetings from a!\nGreetings from d!\nGreetings from a!\nGreetings from b!\n\nRequirements for a virtual function.\nFor a function to be virtual, its definition in a derived class must have the same signature as it has in the base class. If the base class function is const, for instance, then the derive class function must also be const. Generally, the return type of a virtual function in a derived class must be the same as in the base class as well, but there’s an exception when the return type in the base class is a pointer or a reference to a class type. In this case, the derived class version of a virtual function may return a pointer or a reference to a more specialized type than that of the base. This is called covariance.\nAnother restriction is that a virtual function can’t be a template function.\nIn standard object-oriented programming terms, a function in a derived class that redefines a function of the base class is said to override this function. A function with the same name as a virtual function in a base class only overrides that function if the remainder of their signatures match exactly as well; if they do not, the function in the derived class is a new function that hides the one in the base class. This means that if you try to use different parameters for a virtual function in a derived class or use different const specifiers, then the virtual function mechanism won’t work. The function in the derived class then defines, a new different function - and this new function will therefore operate with static binding that is established and fixed at compile time.\n\n\noverride specifier.\nThe override specification guarantees that you don’t make mistakes in function overrides and these exactly match the virtual function signatures in base class.\n\n\nfinal qualifier.\nSometimes, we may want to prevent a member function from being overriden in a derived class. We can do this by specifying that a function is final.\n\n\n\nVirtual destructors.\nAlong with the other function, the destructor methods of classes should also be resolved dynamically. That is, if a Base* pointer points to Derived object, the Derived class destructor method should be called first. (Object creation is top-down, destruction is bottom-up in an inheritance hierarchy). So, it’s always prudent to declare destructor methods as virtual.\n\n\nCalling the base class version of a virtual function.\nIt’s easy to call the derived class version of a virtual function through a pointer or reference to a derived class object - the call is made dynamically. However, what do you do when you actually want to call the base class function for a derived class object?\nConsider the Box and ToughPack classes.\n#include &lt;iostream&gt;\n#include &lt;memory&gt;\n#include &lt;string&gt;\n\nclass Box{\n    public:\n    \n    Box() : Box(1.0) {}\n    Box(double side) : Box(side, side, side) {}\n    Box(double length, double width, double height) : m_length(length), m_width(width), m_height(height) {}\n  \n    double virtual volume()\n    {\n        return m_length * m_width * m_height;\n    }\n    \n    ~Box()\n    {\n        std::cout &lt;&lt; \"\\nBox dtor\";\n    }\n    protected:\n    double m_length;\n    double m_width;\n    double m_height;\n};\n\nclass ToughPack : public Box\n{\n    public:\n    ToughPack() : Box() {}\n    ToughPack(double side) : Box(side) {}\n    ToughPack(double x, double y, double z) : Box(x,y,z) {}\n    \n    //Function to calculate volume allowing for 15% of packing\n    double volume() override\n    {\n        return 0.85 * m_length * m_width * m_height ;\n    }\n    \n    ~ToughPack()\n    {\n        std::cout &lt;&lt; \"\\nToughPack dtor\";\n    }\n};\nIn ToughPack’s volume() method, the m_length*m_width*m_height part of the return statement is exactly the formula used to compute the volume() inside the base class Box. In this case, the amount of code we had to retype was limited, but this won’t always be the case. It would therefore be much better if you could simply call the base class version of this function isntead.\nA plausible first attempt to do so would be:\ndouble volume() const override\n{\n    return 0.85 * volume(); // Infinite recursion!\n}\nHowever, this would call volume() override itself, which would then be calling itself again, which would then be calling itself again! This leads to infinite recursion and a crash.\nCalling the base class version from within a function override like this is common. The solution is to explicitly ask the compiler to call the base class version of the function.\ndouble volume() const override\n{\n    return 0.85 * Box::volume(); \n}\n\n\nWhen my base class’s constructor calls a virtual function on its this object, why doesn’t my derived class’s override of that virtual function get invoked?\nWhat happens when we call virtual functions from inside constructors and destructors? Calling a polymorphic function from inside a constructor/desctructor is a recipe for disaster in most cases. It should be avoided whenver possible.\nIn a constructor, the virtual call mechanism is disabled, because overriding from derived classes hasn’t happened yet. Objects are constructed from Base up, “Base before derived”.\nSince Base object must be constructed before Derived, the call to f() always resolves statically to Base::f() from inside the constructor.\n#include&lt;string&gt;\n#include&lt;iostream&gt;\nusing namespace std;\nclass B {\npublic:\n    B(const string& ss) { cout &lt;&lt; \"B constructor\\n\"; f(ss); }\n    virtual void f(const string&) { cout &lt;&lt; \"B::f\\n\";}\n};\nclass D : public B {\npublic:\n    D(const string & ss) :B(ss) { cout &lt;&lt; \"D constructor\\n\";}\n    void f(const string& ss) { cout &lt;&lt; \"D::f\\n\"; s = ss; }\nprivate:\n    string s;\n};\nint main()\n{\n    D d(\"Hello\");\n}\nB constructor\nB::f\nD constructor\n\n\nHow can I set up my class so it won’t be inherited from?\nJust declare the class as final."
  },
  {
    "objectID": "posts/c++-refresher-part-1/index.html#pure-virtual-functions.",
    "href": "posts/c++-refresher-part-1/index.html#pure-virtual-functions.",
    "title": "C++ Refresher - Part I",
    "section": "Pure virtual functions.",
    "text": "Pure virtual functions.\nThere are situations where we require a base class with a virtual function that’s redefined in each of the derived classes, but hwere there’s no meaningful definition for the function in the base class. For example, you might define a base class Shape, from which you derive classes definining specific shapes, such as Circle, Ellipse, Rectangle, Hexagon and so on. The Shape class could include a virtual function area(), that you’d call for the derived class object to compute the area of a particular shape. The Shape class itself, though, cannot possibly provide a meaningful implementation of the area() function, one that caters, for instance, to both Circles and Rectangles. This is a job for a pure virtual function.\nThe purpose of a pure virtual function is to enable the derived class versions of the function to be called polymorphically. To declare a pure virtual function rather than an ordinary virtual function that has a definition, you use the same syntax but add =0 to it’s declaration within the class.\n#include &lt;iostream&gt;\n#include &lt;memory&gt;\n#include &lt;vector&gt;\n\nclass Shape {\npublic:\n    Shape() = default;\n    virtual double area() = 0; //pure virtual function\n\n};\n\nclass Rectangle : public Shape {\npublic:\n    Rectangle(double l, double w) : m_length(l), m_width(w) {}\n\n    double area() override {\n        return m_length * m_width;\n    }\nprivate:\n    double m_length;\n    double m_width;\n};\n\nclass Circle : public Shape {\n\npublic:\n    Circle(double r) : m_radius(r) {}\n\n    double area() override {\n        return 3.14159 * m_radius * m_radius;\n    }\n\nprivate:\n    double m_radius;\n};\n\nint main()\n{\n    //Let's create a container to hold different kinds of shapes\n    std::vector&lt;std::unique_ptr&lt;Shape&gt;&gt; shapes{};\n\n    shapes.push_back(std::make_unique&lt;Rectangle&gt;(5.0, 5.0));\n    shapes.push_back(std::make_unique&lt;Circle&gt;(3.0));\n    shapes.push_back(std::make_unique&lt;Rectangle&gt;(10.0, 12.0));\n    shapes.push_back(std::make_unique&lt;Circle&gt;(5.0));\n\n    for (int i{}; i &lt; shapes.size(); ++i)\n    {\n        std::cout &lt;&lt; \"\\nArea = \" &lt;&lt; shapes[i]-&gt;area();\n    }\n\n    return 0;\n}\nArea = 25\nArea = 28.2743\nArea = 120\nArea = 78.5397"
  },
  {
    "objectID": "posts/c++-refresher-part-1/index.html#abstract-classes.",
    "href": "posts/c++-refresher-part-1/index.html#abstract-classes.",
    "title": "C++ Refresher - Part I",
    "section": "Abstract Classes.",
    "text": "Abstract Classes.\nAn abstract class purely exists for the purpose of deriving classes from it and cannot be instantiated.\nAny class that contains atleast one pure virtual function is an abstract class. Because an abstract class cannot be instantiated, you cannot pass it by value to a function, a parameter of type Shape will not compile. Similarly, you cannot return a Shape object from a functiojn. However, pointers or references to an abstract class can be used as parameter or return types, so types such as Shape* std::shared_ptr&lt;Shape&gt; and Shape& are fine in these settings.\nAny class that inherits from Shape is obligated to provide an implementation of the area() method. If it doesn’t, it too is an abstract class. More specifically, if any pure virtual function of an abstract base class isn’t in a derived class, then the pure virtual function will be inherited as such, and the derived class becomes an abstract class.\nThus, abstract base classes (ABCs) are often used as interfaces."
  },
  {
    "objectID": "posts/cpp-refresher-part-1/index.html",
    "href": "posts/cpp-refresher-part-1/index.html",
    "title": "C++ Refresher - Part I",
    "section": "",
    "text": "A dangling pointer is a pointer variable that still contains the address to the free store memory that has already been deallocated using delete or delete[]. Dereferencing a dangling pointer makes you read from, or even worse write to memory that might already be allocated to and used by other parts of the program, resulting in all kinds of unpredictable results.\nMultiple deallocations which occur when you deallocate an already deallocated memory (and hence dangling) pointer for a second time is a recipe for disaster.\nOne basic strategy to guard yourself against dangling pointers is to always reset a pointer to nullptr, after the memory it points to is released. However, in more complex programs, different parts of the code often collaborate by accessing the same memory - an object or an array of objects - all through distinct copies of the same pointer. In such cases, our simple strategy falls short. Which part of the code is going to call delete/delete[]? And when? How do you ensure that no other part of the code is still using the same dynamically allocated memory.\n\n\n\nA dynamically allocated array, allocated using new[], is captured in a regular pointer cariable. But, so is a single allocated value that is allocated using new.\ndouble* single_df {new double {0.95}};\ndouble* array_of_dfs {new double[3] {1.00, 0.95, 0.90}};\nAfter this the compiler has no way to distinguish between the two, especially once such a pointer gets passed around different parts of the program. This means that the following two statements will compile without error.\ndelete[] single_df;\ndelete array_of_dfs;\nEvery new must be paired with a single delete; every new[] must be paired with a single delete[].\n\n\n\nA memory leak occurs when you allocate memory using new or new[] and fail to release it. If you lose the address of free store memory you have allocated by overwriting the address in the pointer you were using to access it, for instance, you have a memory leak.\nWhen it comes to scope, pointers are just like any other variable. The lifetime of a pointer extends from the point at which you define it in a block to the closing brace of the block. After that it no longer exists, the free store goes out of scope and it’s no longer possible to delete the memory.\nIt’s still relatively easy to see, where you’ve simply forgotten to use delete to free memory when use of the memory ceases at a point close to where you allocated it, but you’d be surprised how often programmers make mistakes like this, especially if, for instance, return statements creep in between allocation and deallocation of your variable. And naturally, memory leaks are even more difficult to spot in complex programs, where memory may be allocated in part of the the program and should be released in a completely separate part.\nOne basic strategy for avoiding memory leaks is to immediately add delete operation at an appropriate place each time you use the new operator. But this strategy by no means is fail-safe. Even C++ programmers are fallible creatures.\n\n\n\nMemory fragmentation can arise in programs that frequently dynamically allocate and release memory blocks. Each time, the new operator is used, it allocates a contiguous block of bytes. If you create and destroy many memory blocks of different sizes, it’s possible to arrive at a situation in which the allocated memory is interspersed with small blocks of free memory, none of which is large enough to accomodate a new memory allocation request by your program. The aggregate of the free memory can be quite large, but if all the individual blocks are small (smaller than a current allocation request), the allocation request will fail.\n\n\n\nNever use the operators new, new[], delete and delete[] directly in day-to-day coding. These operators have no place in modern C++ code. Always use either the std::vector&lt;T&gt; container to replace dynamic arrays or a smart pointer to dynamically allocate individual objects and manage their lifetimes."
  },
  {
    "objectID": "posts/cpp-refresher-part-1/index.html#raw-pointers-and-smart-pointers.",
    "href": "posts/cpp-refresher-part-1/index.html#raw-pointers-and-smart-pointers.",
    "title": "C++ Refresher - Part I",
    "section": "Raw pointers and Smart Pointers.",
    "text": "Raw pointers and Smart Pointers.\nPointer types int*, double* are referred to as raw pointers because variables of these types contain nothing more than an address. A raw pointer can store the address of an automatic variable or a memory-block allocated in the free-store.\nA smart pointer is an object that mimics a raw pointer in that, it contains an address, and you can use it in the same way in many respects. Smart pointers are normally used only to store the address of memory allocated in the free store. A smart pointer does much more than a raw pointer, though. The most notable feature of a smart pointer, is that we don’t have to worry about using the delete or delete[] operator to free memory. It will be released automatically, when it is no longer needed. This means that dangling pointers and multiple deallocations, allocation/deallocation mismatches and memory leaks will no longer be possible.\n\nA std::unique_ptr&lt;T&gt; object behaves as a pointer to type T and is unique in the sense that there can be only one single unique_ptr&lt;&gt; object containing the same address. In other words, there can never be two or more unique_ptr&lt;T&gt; objects pointing to the same memory address at the same time. A unique_ptr&lt;&gt; object is said to own the object it points to exclusively. The uniqueness is enforced by the fact, that a compiler will never allow you to copy a unique_ptr&lt;&gt;.\nA std::shared_ptr&lt;T&gt; object also behaves as a pointer to type T, but in contrast with unique_ptr&lt;T&gt; there can be any number of shared_ptr&lt;&gt; objects that allow shared ownership of an object in the free-store. At any given moment, the number of shared_ptr&lt;&gt; objects that contain a given address in time is known by the runtime. This is called reference counting. The reference count for a shared_ptr&lt;&gt; containing a given free store address is incremented each time a new shared_ptr object is creating containing that address, and its decremented when a shared_ptr containing the address is destroyed or assigned to point to a different address. When there are no shared_ptr objects containing a given address, the reference count will have dropped to zero, and the memory for the object at that address is released automatically. All shared_ptr&lt;&gt; objects that point to the same address have access to the the count of how many there are.\nA weak_ptr&lt;T&gt; is linked to a shared_ptr&lt;T&gt; and contains the same address. Creating a weak_ptr&lt;&gt; does not increment the reference count associated with the linked shared_ptr&lt;&gt; object, though, so a weak_ptr&lt;&gt; does not prevent the object pointed to from being destroyed. Its memory will still be released when the last shared_ptr&lt;&gt; referencing it is destroyed or reassigned to point to a different address, even when associated weak_ptr&lt;&gt; objects still exist. If this happens, the weak_ptr&lt;&gt; will nevertheless not contain a dangling pointer, atleast not one that you could inadvertently access. The reason is that you cannot access the address encapsulated by a weak_ptr&lt;T&gt; directly. The compiler forces you to first create a shared_ptr&lt;T&gt; object out of it that refers to the same address. If the memory address for the weak_ptr&lt;&gt; is still valid, forcing you to create a shared_ptr&lt;&gt; first ensures that the reference count is again incremented and that the pointer can be used safely again. If the memory is released already, however, this operation will result in a shared_ptr&lt;T&gt; containing a nullptr.\n\nOne use for having weak_ptr&lt;&gt; objects is to avoid so called reference cycles with shared_ptr&lt;&gt; objects. Conceptually, a reference cycle is where a shared_ptr&lt;Y&gt; inside the object x points to some other object y that contains a shared_ptr&lt;X&gt;, which points back to x. With this situation, neither x nor y can be destroyed. In practice, this may occur in many ways. weak_ptr allows you to break such cycles. Another use of weak pointers is in the implementation of object caches.\nIn the below code snippet, the destructors ~A() and ~B() are not invoked even when the objects shrd_a and shrd_b go out of scope.\n#include &lt;iostream&gt;\n#include &lt;memory&gt;\n\nusing namespace std;\n\nclass A;\nclass B;\n\nclass A{\n    public:\n    shared_ptr&lt;B&gt; m_b;\n    A() {cout &lt;&lt; \"\\nA()\";}\n    ~A() {cout &lt;&lt; \"\\n~A()\";}\n};\n\nclass B{\n    public:\n    shared_ptr&lt;A&gt; m_a;\n    B () {cout &lt;&lt; \"\\nB()\";}\n    ~B() {cout &lt;&lt; \"\\n~B()\";}\n};\n\nint main()\n{\n    {\n        shared_ptr&lt;A&gt; shrd_a {make_shared&lt;A&gt;()}; //A's ref count = 1\n        shared_ptr&lt;B&gt; shrd_b {make_shared&lt;B&gt;()}; //B's ref count = 1\n    \n        shrd_a-&gt;m_b = shrd_b; //B's ref count = 2\n        shrd_b-&gt;m_a = shrd_a; //A's ref count = 2\n    }\n    //shrd_a and shrd_b go out of scope and are destroyed\n    // A's ref count = 1\n    // B's ref count = 1\n    // ((Memory of A, B is deallocated only when ref count drops to 0))\n    return 0;\n}\nA()\nB()\nTo solve it, the programmer needs to be aware of the ownership relationship among the objects, or needs to invent an ownership relationship, if no such ownership exists. The above C++ code can be changed so that A owns B:\n#include &lt;iostream&gt;\n#include &lt;memory&gt;\n\nusing namespace std;\n\nclass A;\nclass B;\n\nclass A{\n    public:\n    shared_ptr&lt;B&gt; m_b;\n    A() {cout &lt;&lt; \"\\nA()\";}\n    ~A() {cout &lt;&lt; \"\\n~A()\";}\n};\n\nclass B{\n    public:\n    weak_ptr&lt;A&gt; m_a;\n    B () {cout &lt;&lt; \"\\nB()\";}\n    ~B() {cout &lt;&lt; \"\\n~B()\";}\n};\n\nint main()\n{\n    {\n        shared_ptr&lt;A&gt; shrd_a {make_shared&lt;A&gt;()}; //A's ref count = 1\n        shared_ptr&lt;B&gt; shrd_b {make_shared&lt;B&gt;()}; //B's ref count = 1\n    \n        shrd_a-&gt;m_b = shrd_b; //B's ref count = 2\n        shrd_b-&gt;m_a = shrd_a; //A's ref count = 1\n    }\n    //shrd_a and shrd_b go out of scope and are destroyed\n    // A's ref count = 0\n    // B's ref count = 1\n    // A is destroyed\n    // B's ref count = 0\n    // B is destroyed\n    //\n    return 0;\n}\nA()\nB()\n~A()\n~B()\n\nUsing unique_ptr&lt;T&gt; and shared_ptr&lt;T&gt; pointers.\nA unique_ptr&lt;T&gt; object stores an address uniquely, so the value to which it points is owned exlusively by the unique_ptr&lt;T&gt; smart pointer. When the unique_ptr&lt;T&gt; is destroyed, so is the value to which it points. Like all smart pointers, a unique_ptr&lt;&gt; is most useful when working with dynamically allocated objects. Objects then should not be shared by multiple parts of the program, or where the lifetime of the dynamic pobject is naturally tied to a single other object in your program.\nOne common use for a unique_ptr&lt;&gt; is to hold something called a polymorphic pointer, which in essence is a pointer to a dynamically allocated object that can be of any number of related class types.\nTo create and initialize a double variable on the free-store, we write:\n#include &lt;iostream&gt;\n#include &lt;memory&gt;\n\nint main()\n{\n    std::unique_ptr&lt;double&gt; pDiscountFactor {std::make_unique&lt;double&gt;(0.95)};\n    \n    std::cout &lt;&lt; \"Discount Factor = \" &lt;&lt; *pDiscountFactor;\n    \n    return 0;\n}\nDiscount Factor = 0.95\nThe memory allocated on the free store holding 0.95 is released once pDiscountFactor goes out of scope and is destroyed after the return statement.\nThe below code snippet shows how smart pointers work.\n#include &lt;iostream&gt;\n#include &lt;memory&gt;\n\nclass X{\n    public:\n        X()\n        {\n          std::cout &lt;&lt; \"\\nX created\";\n        }\n        \n        ~X()\n        {\n          std::cout &lt;&lt; \"\\nX destroyed\";\n        }\n};\n\nclass Y{\n    \n    public:\n        Y()\n        {\n          std::cout &lt;&lt; \"\\nY created\";\n        }\n        \n        ~Y()\n        {\n          std::cout &lt;&lt; \"\\nY destroyed\";\n        } \n};\n\nint main()\n{\n    std::cout &lt;&lt; \"\\nInside main\";\n    std::shared_ptr&lt;Y&gt; sPtrY1 {std::make_shared&lt;Y&gt;()};\n    \n    \n    {\n        //inner scope\n        std::cout &lt;&lt; \"\\nInside inner\";\n        \n        std::unique_ptr&lt;X&gt; uPtrX1 {std::make_unique&lt;X&gt;()};\n        std::shared_ptr&lt;Y&gt; sPtrY2 {sPtrY1};\n        \n        // copy assignment and copy construction is not allowed on unique_ptr objects\n        //std::unique_ptr&lt;X&gt; uPtrX2 = uPtrX1;\n        \n        std::cout &lt;&lt; \"\\nExiting inner\";\n    }\n    \n    std::cout &lt;&lt; \"\\nExiting main\";\n    return 0;\n}\nInside main\nY created\nInside inner\nX created\nExiting inner\nX destroyed\nExiting main\nY destroyed"
  },
  {
    "objectID": "posts/cpp-refresher-part-1/index.html#references.",
    "href": "posts/cpp-refresher-part-1/index.html#references.",
    "title": "C++ Refresher - Part I",
    "section": "References.",
    "text": "References.\nA reference is a name that you can use as an alias for another variable. Unlike a pointer, you cannot declare a reference and not initialize it. Because a reference is an alias, the variable which it is an alias must be provided when the reference is initialized. Also, a reference cannot be modified to be an alias for something else.\n#include &lt;iostream&gt;\n#include &lt;memory&gt;\n\n\nvoid swap(int& a, int& b)\n{\n    int temp {a};\n    a = b;\n    b = temp;\n}\n\nint main()\n{\n    int x {10}; \n    int y {15};\n    \n    std::cout &lt;&lt; \"\\n Before swap:\";\n    std::cout &lt;&lt; \"\\n x = \" &lt;&lt; x ;\n    std::cout &lt;&lt; \"\\n y = \" &lt;&lt; y;\n    \n    swap(x,y);\n    \n    std::cout &lt;&lt; \"\\n After swap:\";\n    std::cout &lt;&lt; \"\\n x = \" &lt;&lt; x ;\n    std::cout &lt;&lt; \"\\n y = \" &lt;&lt; y;\n    return 0;\n}\n Before swap:\n x = 10\n y = 15\n After swap:\n x = 15\n y = 10\nNever return a pointer or reference to an automatic stack-allocated local variable from within a function. Automatic variables are destroyed and the stack is popped, once the control goes outside the scope in which they are declared."
  },
  {
    "objectID": "posts/cpp-refresher-part-1/index.html#function-templates.",
    "href": "posts/cpp-refresher-part-1/index.html#function-templates.",
    "title": "C++ Refresher - Part I",
    "section": "Function Templates.",
    "text": "Function Templates.\nA function template itself is not a definition of a function; it is a blueprint or a recipe for definining an entire family of functions. A function template is a parametric function definition, where a particular function instance is created by one or more parameter values. The compiler uses a function template to generate a function definition when necessary. If it is never necessary, no code results from the template. A function definition that is generated from a template is an instance or instantiation of the template.\nThe parameters of a function template are usually data-types, where an instance can be generated for a parameter value of type int, for example, and another with parameter valuer of type string. But parameters are not necessarily types. They can be other things such as a dimension, for example.\ntemplate &lt;class T&gt;\nT larger(T a, T b)\n{\n    return a &gt; b ? a : b;\n}\nThe compiler creates instances of the template from any statement that uses the larger() function. Here’s an example:\nint main()\n{\n    std::cout &lt;&lt; \"\\nLarger of 1.50 and 2.50 is : \"  &lt;&lt; larger(1.5,2.5);\n    return 0;\n}\nLarger of 1.50 and 2.50 is : 2.5\nYou just use the function in the normal way. You don’t need to specify a value for the template parameter T. The compiler deduces the type that is to replace T from the arguments in the larger function call. This mechanism is referred to as template argument deduction. The arguments to larger() are literals of type double, so this call causes the compiler to search for an existing definition of larger() with double parameters. If it doesn’t find one, the compiler creates this version of larger() from the template by susbstituting double for T in the template definition.\nThe resulting function accepts arguments of type double and returs a double value.\nThe compiler makes sure to generate each template instance only once. If a subsequent function call requires the same instance, then it calls the instance that exists.\n\nTemplate type parameters.\nThe name of the template type parameter can be used anywhere in the template’s function signature, return type and body. It is a placeholder for a type and can thus be put in any context you would normally put a concrete type.\ntemplate &lt;class T&gt;\nconst T& larger(const T& a,const T& b)\n{\n    return a &gt; b ? a : b;\n}\n\n\nFunction Template overloading.\nTemplated functions can be overloaded.\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\ntemplate &lt;typename T&gt;\nconst T& largest(const T& a,const T& b)\n{\n    return a &gt; b ? a : b;\n}\n\ntemplate &lt;typename T&gt;\nconst T largest(const std::vector&lt;T&gt;& data)\n{\n    T max {};\n    for(auto v:data)\n    {\n        if (v &gt;= max)\n            max = v;\n    }\n    return max;\n}\n\nint main()\n{\n    std::cout &lt;&lt; \"\\nLarger of 1.50 and 2.50 is : \"  &lt;&lt; largest(1.5,2.5);\n    std::vector&lt;int&gt; data {\n        2, 5, 8, 4, 7, 3\n    };\n    std::cout &lt;&lt; \"\\nLargest of [2,5,8,4,7,3] is : \" &lt;&lt; largest(data);\n    return 0;\n}\nLarger of 1.50 and 2.50 is : 2.5\nLargest of [2,5,8,4,7,3] is : 8"
  },
  {
    "objectID": "posts/cpp-refresher-part-1/index.html#classes-and-object-oriented-programming.",
    "href": "posts/cpp-refresher-part-1/index.html#classes-and-object-oriented-programming.",
    "title": "C++ Refresher - Part I",
    "section": "Classes and Object Oriented Programming.",
    "text": "Classes and Object Oriented Programming.\nAn interesting exercise to write a Matrix&lt;T&gt; class.\n// Matrix.h\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;initializer_list&gt;\n#include &lt;stdexcept&gt;\n\ntemplate &lt;typename T = double&gt;\nclass Matrix {\npublic:\n    //Default constructor\n    Matrix() : Matrix(3, 3) {}\n\n    //Parameterized constructor with number of rows, cols as \n    // as arguments.\n    Matrix(std::size_t m, std::size_t n) : m_rows(m), m_cols(n)\n    {\n        m_data.resize(m_rows * m_cols, 0);\n    }\n\n    //Parameterized constructor with matrix elements provided \n    // in brace initializer lists.\n    Matrix(std::initializer_list&lt;std::initializer_list&lt;T&gt;&gt; m) {\n        int i{}, j{};\n        for (auto row : m)\n        {\n            for (auto el : row)\n            {\n                m_data.push_back(el);\n                if (i == 0)\n                    ++j;\n            }\n            ++i;\n        }\n\n        m_rows = i;\n        m_cols = j;\n    }\n\n\n    //Copy constructor\n    Matrix(const Matrix& A) : m_rows{ A.m_rows }, m_cols{ A.m_cols }, m_data{ A.m_data } {}\n\n    std::size_t rows() const\n    {\n        return m_rows;\n    }\n\n    std::size_t cols() const\n    {\n        return m_cols;\n    }\n\n    T& at(int i, int j)\n    {\n        return m_data[i * m_cols + j];\n    }\n\n    const T& at(int i, int j) const\n    {\n        return m_data[i * m_cols + j];\n    }\n\n    T& operator()(int i, int j)\n    {\n        if (i &lt; 0)\n            throw std::invalid_argument(\"The row index must be non-negative!\");\n\n        if (j &lt; 0)\n            throw std::invalid_argument(\"The column index must be non-negative!\");\n\n        if (i &gt;= m_rows)\n            throw std::invalid_argument(\"The row index must be less than \" + m_rows);\n\n        if (j &gt;= m_cols)\n            throw std::invalid_argument(\"The col index must be less than \" + m_cols);\n\n        return at(i, j);\n    }\n\n    const T operator()(int i, int j) const\n    {\n        if (i &lt; 0)\n            throw std::invalid_argument(\"The row index must be non-negative!\");\n\n        if (j &lt; 0)\n            throw std::invalid_argument(\"The column index must be non-negative!\");\n\n        if (i &gt;= m_rows)\n            throw std::invalid_argument(\"The row index must be less than \" + m_rows);\n\n        if (j &gt;= m_cols)\n            throw std::invalid_argument(\"The col index must be less than \" + m_cols);\n\n        return at(i, j);\n    }\n\n    const Matrix operator+(const Matrix& mat)\n    {\n        if (mat.rows() != rows())\n            throw std::runtime_error(\"In A + B, matrices A, B should have the same number of rows!\");\n\n        if (mat.cols() != cols())\n            throw std::runtime_error(\"In A + B, matrices A, B should have the same number of cols!\");\n\n        Matrix result(rows(), cols());\n\n        for (int i{}; i &lt; rows(); ++i)\n        {\n            for (int j{}; j &lt; cols(); ++j)\n            {\n                result(i, j) = at(i, j) + mat(i, j);\n            }\n        }\n        return result;\n    }\n\n    const Matrix operator-(const Matrix& mat)\n    {\n        if (mat.rows() != rows())\n            throw std::runtime_error(\"In A - B, matrices A, B should have the same number of rows!\");\n\n        if (mat.cols() != cols())\n            throw std::runtime_error(\"In A - B, matrices A, B should have the same number of cols!\");\n\n        Matrix result(rows(), cols());\n\n        for (int i{}; i &lt; rows(); ++i)\n        {\n            for (int j{}; j &lt; cols(); ++j)\n            {\n                result(i, j) = at(i, j) - mat(i, j);\n            }\n        }\n        return result;\n    }\n\n    Matrix& operator=(const Matrix& mat)\n    {\n        m_data = mat.m_data;\n        m_rows = mat.rows();\n        m_cols = mat.cols();\n\n        return *this;\n    }\n\n    const Matrix operator*(const Matrix& mat)\n    {\n        if (cols() != mat.rows())\n            throw std::runtime_error(\"In A * B, cols of A must equal rows of B!\");\n\n        Matrix result{ rows(), mat.cols() };\n\n        for (int i{}; i &lt; rows(); ++i)\n        {\n            for (int k{}; k &lt; cols(); ++k)\n            {\n                for (int j{}; j &lt; mat.cols(); ++j)\n                {\n                    result(i, j) += at(i, k) * mat(k, j);\n                }\n            }\n        }\n\n        return result;\n    }\n\n\nprivate:\n    std::vector&lt;T&gt; m_data{};\n    int m_rows;\n    int m_cols;\n};\n//Matrix.cpp\n\n#include &lt;iostream&gt;\n#include \"Matrix.h\"\n\nint main()\n{\n    Matrix&lt;double&gt; A{\n        {1, 0},\n        {0, 1}\n    };\n\n    Matrix&lt;double&gt; B{\n        {1, 0},\n        {0, 1}\n    };\n\n    Matrix&lt;double&gt; result = A + B;\n\n    std::cout &lt;&lt; result(0, 0) &lt;&lt; \"\\t\" &lt;&lt; result(0, 1) &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; result(1, 0) &lt;&lt; \"\\t\" &lt;&lt; result(1, 1);\n\n    return 0;\n}\n\nAccess specifiers and class hierarchies.\n\nThe private members of the base class are inaccessible to the derived class.\nWhen the base class specifier is public, the access status of the inherited members remains unchanged. Thus, inherited public members are public, and inherited protected members are protected in a derived class.\nWhen the base class specifier is protected, both public and protected members of the base class are inherited as protected members in the child class.\nWhen the base class specifier is private, inherited public and protected members become private to the derived class, so that they’re accessible by member functions of the the derived class, but they cannot be accessed if they’re inherited in another derived class.\n\n\n\nConstructors and Destructors in derived classes.\nEvery constructor of the derived class always starts by invoking a constructor of the base class. And that base class constructor then invokes the constructor of its base class, and so on.\nRemark. You cannot initialize the member variables of a base class in the initialization list for the derived class constructor. Not even if those members are public or protected.\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;string&gt;\n\nclass A{\n    public:\n    A(){\n        std::cout &lt;&lt; \"\\nInside A's constructor\";\n    }\n    ~A()\n    {\n        std::cout &lt;&lt; \"\\nInside A's destructor\";\n    }\n};\n\nclass B : public A\n{\n    public:\n    B()\n    {\n        std::cout &lt;&lt; \"\\nInside B's constructor\";\n    }\n    \n    ~B()\n    {\n        std::cout &lt;&lt; \"\\nInside B's destructor\";\n    }\n};\n\nint main()\n{\n    B b;\n    \n    return 0;\n}\nInside A's constructor\nInside B's constructor\nInside B's destructor\nInside A's destructor\nSuppose you have a base class Parent, two child classes Child_1 and Child_2 that inherit from Parent and a Grandchild class that inherits from Child_1 and Child_2. This is the diamond problem, named after the shape of such inheritance diagrams. The Grandchild inherits two copies of Parent : one through Child_1 and another through Child_2.\nTo prevent the duplication of the base class, we identify to the compiler that the base class should appear only once within the derived class. We do this by specifying the class as a virtual base class using the virtual keword. The Child_1 and Child_2 classes would be defined like this:\nclass Child_1 : public virtual Parent\n{\n    //...\n};\n\nclass Child_2 : public virtual Parent\n{\n    //...\n};\n\n\nPolymorphism.\nEvery derived class object is a base class object. So, you can use a base class pointer/reference to store the address of a derived class object. It is easy to implement dynamic dispatch through virtual methods.\nThe below code snippet is instructive in understanding run-time polymorphism.\n#include &lt;memory&gt;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass A {\npublic:\n    void foo() {\n        std::cout &lt;&lt; \"\\nGreetings from a!\";\n    }\n};\n\nclass B :public A {\npublic:\n    virtual void foo()\n    {\n        std::cout &lt;&lt; \"\\nGreetings from b!\";\n    }\n};\n\n\nclass C : public B {\nprivate:\n    virtual void foo()\n    {\n        std::cout &lt;&lt; \"\\nGreetings from c!\";\n    }\n};\n\nclass D : public C {\npublic:\n    void foo()\n    {\n        std::cout &lt;&lt; \"\\nGreetings from d!\";\n    }\n};\n\nint main()\n{\n    std::shared_ptr&lt;A&gt; a_ptr = std::make_shared&lt;D&gt;();\n    a_ptr -&gt;foo();\n    \n    std::shared_ptr&lt;B&gt; b_ptr = std::make_shared&lt;D&gt;();\n    b_ptr -&gt;foo();\n    \n    std::shared_ptr&lt;C&gt; c_ptr = std::make_shared&lt;D&gt;();\n    //c_ptr -&gt;foo();  //will not compile, foo() is a private member is not inherited by D\n    \n    std::shared_ptr&lt;D&gt; d_ptr = std::make_shared&lt;D&gt;();\n    d_ptr -&gt;foo();\n}\nGreetings from a!\nGreetings from d!\nGreetings from d!\nWhen you specify a function as virtual in a base class, you indicate to the compiler that you want dynamic binding for function calls in any class that’s derived from this base class. A function that you specify as virtual in the base class will be virtual in all classes that directly or indirectly derive from the base class. This is the case, whether or not you specify the function as virtual in the derived class.\nThe call to a virtual function using an object is always resolved statically. You only get dybamic resolution of calls to virtual functions through a pointer or a reference. Consider the below code snippet:\n    D d{};\n    \n    A& aRef = d;\n    B& bRef = d;\n    A a; B b;\n    \n    aRef.foo();\n    bRef.foo();\n    \n    a.foo();\n    b.foo();\nGreetings from a!\nGreetings from d!\nGreetings from a!\nGreetings from b!\n\nRequirements for a virtual function.\nFor a function to be virtual, its definition in a derived class must have the same signature as it has in the base class. If the base class function is const, for instance, then the derive class function must also be const. Generally, the return type of a virtual function in a derived class must be the same as in the base class as well, but there’s an exception when the return type in the base class is a pointer or a reference to a class type. In this case, the derived class version of a virtual function may return a pointer or a reference to a more specialized type than that of the base. This is called covariance.\nAnother restriction is that a virtual function can’t be a template function.\nIn standard object-oriented programming terms, a function in a derived class that redefines a function of the base class is said to override this function. A function with the same name as a virtual function in a base class only overrides that function if the remainder of their signatures match exactly as well; if they do not, the function in the derived class is a new function that hides the one in the base class. This means that if you try to use different parameters for a virtual function in a derived class or use different const specifiers, then the virtual function mechanism won’t work. The function in the derived class then defines, a new different function - and this new function will therefore operate with static binding that is established and fixed at compile time.\n\n\noverride specifier.\nThe override specification guarantees that you don’t make mistakes in function overrides and these exactly match the virtual function signatures in base class.\n\n\nfinal qualifier.\nSometimes, we may want to prevent a member function from being overriden in a derived class. We can do this by specifying that a function is final.\n\n\n\nVirtual destructors.\nAlong with the other function, the destructor methods of classes should also be resolved dynamically. That is, if a Base* pointer points to Derived object, the Derived class destructor method should be called first. (Object creation is top-down, destruction is bottom-up in an inheritance hierarchy). So, it’s always prudent to declare destructor methods as virtual.\n\n\nCalling the base class version of a virtual function.\nIt’s easy to call the derived class version of a virtual function through a pointer or reference to a derived class object - the call is made dynamically. However, what do you do when you actually want to call the base class function for a derived class object?\nConsider the Box and ToughPack classes.\n#include &lt;iostream&gt;\n#include &lt;memory&gt;\n#include &lt;string&gt;\n\nclass Box{\n    public:\n    \n    Box() : Box(1.0) {}\n    Box(double side) : Box(side, side, side) {}\n    Box(double length, double width, double height) : m_length(length), m_width(width), m_height(height) {}\n  \n    double virtual volume()\n    {\n        return m_length * m_width * m_height;\n    }\n    \n    ~Box()\n    {\n        std::cout &lt;&lt; \"\\nBox dtor\";\n    }\n    protected:\n    double m_length;\n    double m_width;\n    double m_height;\n};\n\nclass ToughPack : public Box\n{\n    public:\n    ToughPack() : Box() {}\n    ToughPack(double side) : Box(side) {}\n    ToughPack(double x, double y, double z) : Box(x,y,z) {}\n    \n    //Function to calculate volume allowing for 15% of packing\n    double volume() override\n    {\n        return 0.85 * m_length * m_width * m_height ;\n    }\n    \n    ~ToughPack()\n    {\n        std::cout &lt;&lt; \"\\nToughPack dtor\";\n    }\n};\nIn ToughPack’s volume() method, the m_length*m_width*m_height part of the return statement is exactly the formula used to compute the volume() inside the base class Box. In this case, the amount of code we had to retype was limited, but this won’t always be the case. It would therefore be much better if you could simply call the base class version of this function isntead.\nA plausible first attempt to do so would be:\ndouble volume() const override\n{\n    return 0.85 * volume(); // Infinite recursion!\n}\nHowever, this would call volume() override itself, which would then be calling itself again, which would then be calling itself again! This leads to infinite recursion and a crash.\nCalling the base class version from within a function override like this is common. The solution is to explicitly ask the compiler to call the base class version of the function.\ndouble volume() const override\n{\n    return 0.85 * Box::volume(); \n}\n\n\nWhen my base class’s constructor calls a virtual function on its this object, why doesn’t my derived class’s override of that virtual function get invoked?\nWhat happens when we call virtual functions from inside constructors and destructors? Calling a polymorphic function from inside a constructor/desctructor is a recipe for disaster in most cases. It should be avoided whenver possible.\nIn a constructor, the virtual call mechanism is disabled, because overriding from derived classes hasn’t happened yet. Objects are constructed from Base up, “Base before derived”.\nSince Base object must be constructed before Derived, the call to f() always resolves statically to Base::f() from inside the constructor.\n#include&lt;string&gt;\n#include&lt;iostream&gt;\nusing namespace std;\nclass B {\npublic:\n    B(const string& ss) { cout &lt;&lt; \"B constructor\\n\"; f(ss); }\n    virtual void f(const string&) { cout &lt;&lt; \"B::f\\n\";}\n};\nclass D : public B {\npublic:\n    D(const string & ss) :B(ss) { cout &lt;&lt; \"D constructor\\n\";}\n    void f(const string& ss) { cout &lt;&lt; \"D::f\\n\"; s = ss; }\nprivate:\n    string s;\n};\nint main()\n{\n    D d(\"Hello\");\n}\nB constructor\nB::f\nD constructor\n\n\nHow can I set up my class so it won’t be inherited from?\nJust declare the class as final."
  },
  {
    "objectID": "posts/cpp-refresher-part-1/index.html#pure-virtual-functions.",
    "href": "posts/cpp-refresher-part-1/index.html#pure-virtual-functions.",
    "title": "C++ Refresher - Part I",
    "section": "Pure virtual functions.",
    "text": "Pure virtual functions.\nThere are situations where we require a base class with a virtual function that’s redefined in each of the derived classes, but hwere there’s no meaningful definition for the function in the base class. For example, you might define a base class Shape, from which you derive classes definining specific shapes, such as Circle, Ellipse, Rectangle, Hexagon and so on. The Shape class could include a virtual function area(), that you’d call for the derived class object to compute the area of a particular shape. The Shape class itself, though, cannot possibly provide a meaningful implementation of the area() function, one that caters, for instance, to both Circles and Rectangles. This is a job for a pure virtual function.\nThe purpose of a pure virtual function is to enable the derived class versions of the function to be called polymorphically. To declare a pure virtual function rather than an ordinary virtual function that has a definition, you use the same syntax but add =0 to it’s declaration within the class.\n#include &lt;iostream&gt;\n#include &lt;memory&gt;\n#include &lt;vector&gt;\n\nclass Shape {\npublic:\n    Shape() = default;\n    virtual double area() = 0; //pure virtual function\n\n};\n\nclass Rectangle : public Shape {\npublic:\n    Rectangle(double l, double w) : m_length(l), m_width(w) {}\n\n    double area() override {\n        return m_length * m_width;\n    }\nprivate:\n    double m_length;\n    double m_width;\n};\n\nclass Circle : public Shape {\n\npublic:\n    Circle(double r) : m_radius(r) {}\n\n    double area() override {\n        return 3.14159 * m_radius * m_radius;\n    }\n\nprivate:\n    double m_radius;\n};\n\nint main()\n{\n    //Let's create a container to hold different kinds of shapes\n    std::vector&lt;std::unique_ptr&lt;Shape&gt;&gt; shapes{};\n\n    shapes.push_back(std::make_unique&lt;Rectangle&gt;(5.0, 5.0));\n    shapes.push_back(std::make_unique&lt;Circle&gt;(3.0));\n    shapes.push_back(std::make_unique&lt;Rectangle&gt;(10.0, 12.0));\n    shapes.push_back(std::make_unique&lt;Circle&gt;(5.0));\n\n    for (int i{}; i &lt; shapes.size(); ++i)\n    {\n        std::cout &lt;&lt; \"\\nArea = \" &lt;&lt; shapes[i]-&gt;area();\n    }\n\n    return 0;\n}\nArea = 25\nArea = 28.2743\nArea = 120\nArea = 78.5397"
  },
  {
    "objectID": "posts/cpp-refresher-part-1/index.html#abstract-classes.",
    "href": "posts/cpp-refresher-part-1/index.html#abstract-classes.",
    "title": "C++ Refresher - Part I",
    "section": "Abstract Classes.",
    "text": "Abstract Classes.\nAn abstract class purely exists for the purpose of deriving classes from it and cannot be instantiated.\nAny class that contains atleast one pure virtual function is an abstract class. Because an abstract class cannot be instantiated, you cannot pass it by value to a function, a parameter of type Shape will not compile. Similarly, you cannot return a Shape object from a functiojn. However, pointers or references to an abstract class can be used as parameter or return types, so types such as Shape* std::shared_ptr&lt;Shape&gt; and Shape& are fine in these settings.\nAny class that inherits from Shape is obligated to provide an implementation of the area() method. If it doesn’t, it too is an abstract class. More specifically, if any pure virtual function of an abstract base class isn’t in a derived class, then the pure virtual function will be inherited as such, and the derived class becomes an abstract class.\nThus, abstract base classes (ABCs) are often used as interfaces."
  },
  {
    "objectID": "posts/cpp-refresher-part-1/index.html#hazards-of-dynamic-memory-allocation.",
    "href": "posts/cpp-refresher-part-1/index.html#hazards-of-dynamic-memory-allocation.",
    "title": "C++ Refresher - Part I",
    "section": "",
    "text": "A dangling pointer is a pointer variable that still contains the address to the free store memory that has already been deallocated using delete or delete[]. Dereferencing a dangling pointer makes you read from, or even worse write to memory that might already be allocated to and used by other parts of the program, resulting in all kinds of unpredictable results.\nMultiple deallocations which occur when you deallocate an already deallocated memory (and hence dangling) pointer for a second time is a recipe for disaster.\nOne basic strategy to guard yourself against dangling pointers is to always reset a pointer to nullptr, after the memory it points to is released. However, in more complex programs, different parts of the code often collaborate by accessing the same memory - an object or an array of objects - all through distinct copies of the same pointer. In such cases, our simple strategy falls short. Which part of the code is going to call delete/delete[]? And when? How do you ensure that no other part of the code is still using the same dynamically allocated memory.\n\n\n\nA dynamically allocated array, allocated using new[], is captured in a regular pointer cariable. But, so is a single allocated value that is allocated using new.\ndouble* single_df {new double {0.95}};\ndouble* array_of_dfs {new double[3] {1.00, 0.95, 0.90}};\nAfter this the compiler has no way to distinguish between the two, especially once such a pointer gets passed around different parts of the program. This means that the following two statements will compile without error.\ndelete[] single_df;\ndelete array_of_dfs;\nEvery new must be paired with a single delete; every new[] must be paired with a single delete[].\n\n\n\nA memory leak occurs when you allocate memory using new or new[] and fail to release it. If you lose the address of free store memory you have allocated by overwriting the address in the pointer you were using to access it, for instance, you have a memory leak.\nWhen it comes to scope, pointers are just like any other variable. The lifetime of a pointer extends from the point at which you define it in a block to the closing brace of the block. After that it no longer exists, the free store goes out of scope and it’s no longer possible to delete the memory.\nIt’s still relatively easy to see, where you’ve simply forgotten to use delete to free memory when use of the memory ceases at a point close to where you allocated it, but you’d be surprised how often programmers make mistakes like this, especially if, for instance, return statements creep in between allocation and deallocation of your variable. And naturally, memory leaks are even more difficult to spot in complex programs, where memory may be allocated in part of the the program and should be released in a completely separate part.\nOne basic strategy for avoiding memory leaks is to immediately add delete operation at an appropriate place each time you use the new operator. But this strategy by no means is fail-safe. Even C++ programmers are fallible creatures.\n\n\n\nMemory fragmentation can arise in programs that frequently dynamically allocate and release memory blocks. Each time, the new operator is used, it allocates a contiguous block of bytes. If you create and destroy many memory blocks of different sizes, it’s possible to arrive at a situation in which the allocated memory is interspersed with small blocks of free memory, none of which is large enough to accomodate a new memory allocation request by your program. The aggregate of the free memory can be quite large, but if all the individual blocks are small (smaller than a current allocation request), the allocation request will fail.\n\n\n\nNever use the operators new, new[], delete and delete[] directly in day-to-day coding. These operators have no place in modern C++ code. Always use either the std::vector&lt;T&gt; container to replace dynamic arrays or a smart pointer to dynamically allocate individual objects and manage their lifetimes."
  },
  {
    "objectID": "posts/cox-ingersoll-ross-model/index.html",
    "href": "posts/cox-ingersoll-ross-model/index.html",
    "title": "Cox-Ingersoll-Ross (CIR) model",
    "section": "",
    "text": "The short rate under the CIR model has the dynamics:\n\\[dr_t = \\kappa (\\theta - r_t)dt + \\sigma \\sqrt{r_t}dB_t\\]\nFor a moment, if we drop the stochastic term, and merely consider the first order linear ODE \\(\\frac{dr_t}{dt} + \\kappa r_t = \\kappa \\theta\\), the integrating factor for this differential equation is \\(e^{\\int \\kappa dt} = e^{\\kappa t}\\). Multiplying both sides by the integrating factor, we have:\n\\[\\begin{align*}\ne^{\\kappa t} dr_t &= \\kappa(\\theta - r_t) e^{\\kappa t}dt + \\sigma e^{\\kappa t}\\sqrt{r_t} dB_t \\\\\ne^{\\kappa t} dr_t + r_t e^{\\kappa t}dt &= \\kappa e^{\\kappa t}\\theta dt + \\sigma e^{\\kappa t}\\sqrt{r_t} dB_t \\\\\nd(e^{\\kappa t} r_t) &= \\kappa e^{\\kappa t}\\theta dt + \\sigma e^{\\kappa t}\\sqrt{r_t} dB_t \\\\\n\\int_{0}^{t} d(e^{\\kappa s} r_s) &= \\theta \\kappa\\int_{0}^{t}  e^{\\kappa s} ds + \\sigma \\int_{0}^{t}  e^{\\kappa s}\\sqrt{r_s} dB_s \\\\\n[e^{\\kappa s} r_s]_{0}^{t} &= \\kappa \\theta \\left[\\frac{e^{\\kappa s}}{\\kappa}\\right]_{0}^{t} + \\sigma \\int_{0}^{t}  e^{\\kappa s}\\sqrt{r_s} dB_s\\\\\ne^{\\kappa t}r_t - r_0 &= \\theta (e^{\\kappa t} - 1) + \\sigma \\int_{0}^{t}  e^{\\kappa s}\\sqrt{r_s} dB_s \\\\\ne^{\\kappa t} r_t &= r_0 + \\theta (e^{\\kappa t} - 1) + \\sigma \\int_{0}^{t}  e^{\\kappa s}\\sqrt{r_s} dB_s \\\\\nr_t &= r_0 e^{-\\kappa t} + \\theta (1 - e^{-\\kappa t}) + \\sigma \\int_{0}^{t}  e^{-\\kappa (t-s)}\\sqrt{r_s} dB_s\n\\end{align*}\\]\nThe mean is given by:\n\\[\\begin{align*}\n\\mathbf{E}[r_t] &= r_0 e^{-\\kappa t} + \\theta (1 - e^{-\\kappa t})\n\\end{align*}\\]\nThe random variable \\(\\sigma \\int_{0}^{t} e^{-\\kappa (t-s)}\\sqrt{r_s} dB_s\\) has mean \\(0\\) and variance:\n\\[\\begin{align*}\n\\mathbf{E}\\left[\\left(\\sigma \\int_{0}^{t}  e^{-\\kappa (t-s)}\\sqrt{r_s} dB_s\\right)^2\\right] &= \\sigma^2 \\int_{0}^{t}e^{-2\\kappa(t-s)} \\mathbf{E}[r_s] ds \\\\\n&= \\sigma^2 e^{-2\\kappa t}\\int_{0}^{t}e^{2\\kappa s} \\left(r_0 e^{-\\kappa s} + \\theta(1-e^{-\\kappa s})\\right) ds\\\\\n&= \\sigma^2 r_0 e^{-2\\kappa t} \\int_{0}^{t} e^{\\kappa s} ds + \\sigma^2 \\theta e^{-2\\kappa t} \\int_{0}^{t}(e^{2\\kappa s}-e^{\\kappa s}) ds \\\\\n&= \\sigma^2 r_0 e^{-2\\kappa t} \\left[\\frac{e^{\\kappa s}}{\\kappa} \\right]_{0}^{t} +\\sigma^2 \\theta e^{-2\\kappa t} \\left[\\frac{e^{2\\kappa s}}{2\\kappa} - \\frac{e^{\\kappa s}}{\\kappa}\\right]_{0}^{t}\\\\\n&= \\frac{\\sigma^2 r_0}{\\kappa} e^{-2\\kappa t} (e^{\\kappa t} - 1)+\\sigma^2 \\theta e^{-2\\kappa t} \\left[\\frac{e^{2\\kappa s}}{2\\kappa} - \\frac{2e^{\\kappa s}}{2\\kappa}\\right]_{0}^{t}\\\\\n&= \\frac{\\sigma^2 r_0}{\\kappa} e^{-2\\kappa t}(e^{\\kappa t} - 1)+\\frac{\\sigma^2 \\theta}{2\\kappa} e^{-2\\kappa t}(e^{2\\kappa t} - 2e^{\\kappa t} - (1 - 2))\\\\\n&= \\frac{\\sigma^2 r_0}{\\kappa} e^{-2\\kappa t}(e^{\\kappa t} - 1)+\\frac{\\sigma^2 \\theta}{2\\kappa}e^{-2\\kappa t} (1 + e^{2\\kappa t} - 2e^{\\kappa t})\\\\\n&= \\frac{\\sigma^2 r_0}{\\kappa} (e^{-\\kappa t} - e^{-2\\kappa t})+\\frac{\\sigma^2 \\theta}{2\\kappa} (1 - e^{-\\kappa t})^2\n\\end{align*}\\]"
  },
  {
    "objectID": "posts/cox-ingersoll-ross-model/index.html#short-rate-dynamics-mean-and-variance",
    "href": "posts/cox-ingersoll-ross-model/index.html#short-rate-dynamics-mean-and-variance",
    "title": "Cox-Ingersoll-Ross (CIR) model",
    "section": "",
    "text": "The short rate under the CIR model has the dynamics:\n\\[dr_t = \\kappa (\\theta - r_t)dt + \\sigma \\sqrt{r_t}dB_t\\]\nFor a moment, if we drop the stochastic term, and merely consider the first order linear ODE \\(\\frac{dr_t}{dt} + \\kappa r_t = \\kappa \\theta\\), the integrating factor for this differential equation is \\(e^{\\int \\kappa dt} = e^{\\kappa t}\\). Multiplying both sides by the integrating factor, we have:\n\\[\\begin{align*}\ne^{\\kappa t} dr_t &= \\kappa(\\theta - r_t) e^{\\kappa t}dt + \\sigma e^{\\kappa t}\\sqrt{r_t} dB_t \\\\\ne^{\\kappa t} dr_t + r_t e^{\\kappa t}dt &= \\kappa e^{\\kappa t}\\theta dt + \\sigma e^{\\kappa t}\\sqrt{r_t} dB_t \\\\\nd(e^{\\kappa t} r_t) &= \\kappa e^{\\kappa t}\\theta dt + \\sigma e^{\\kappa t}\\sqrt{r_t} dB_t \\\\\n\\int_{0}^{t} d(e^{\\kappa s} r_s) &= \\theta \\kappa\\int_{0}^{t}  e^{\\kappa s} ds + \\sigma \\int_{0}^{t}  e^{\\kappa s}\\sqrt{r_s} dB_s \\\\\n[e^{\\kappa s} r_s]_{0}^{t} &= \\kappa \\theta \\left[\\frac{e^{\\kappa s}}{\\kappa}\\right]_{0}^{t} + \\sigma \\int_{0}^{t}  e^{\\kappa s}\\sqrt{r_s} dB_s\\\\\ne^{\\kappa t}r_t - r_0 &= \\theta (e^{\\kappa t} - 1) + \\sigma \\int_{0}^{t}  e^{\\kappa s}\\sqrt{r_s} dB_s \\\\\ne^{\\kappa t} r_t &= r_0 + \\theta (e^{\\kappa t} - 1) + \\sigma \\int_{0}^{t}  e^{\\kappa s}\\sqrt{r_s} dB_s \\\\\nr_t &= r_0 e^{-\\kappa t} + \\theta (1 - e^{-\\kappa t}) + \\sigma \\int_{0}^{t}  e^{-\\kappa (t-s)}\\sqrt{r_s} dB_s\n\\end{align*}\\]\nThe mean is given by:\n\\[\\begin{align*}\n\\mathbf{E}[r_t] &= r_0 e^{-\\kappa t} + \\theta (1 - e^{-\\kappa t})\n\\end{align*}\\]\nThe random variable \\(\\sigma \\int_{0}^{t} e^{-\\kappa (t-s)}\\sqrt{r_s} dB_s\\) has mean \\(0\\) and variance:\n\\[\\begin{align*}\n\\mathbf{E}\\left[\\left(\\sigma \\int_{0}^{t}  e^{-\\kappa (t-s)}\\sqrt{r_s} dB_s\\right)^2\\right] &= \\sigma^2 \\int_{0}^{t}e^{-2\\kappa(t-s)} \\mathbf{E}[r_s] ds \\\\\n&= \\sigma^2 e^{-2\\kappa t}\\int_{0}^{t}e^{2\\kappa s} \\left(r_0 e^{-\\kappa s} + \\theta(1-e^{-\\kappa s})\\right) ds\\\\\n&= \\sigma^2 r_0 e^{-2\\kappa t} \\int_{0}^{t} e^{\\kappa s} ds + \\sigma^2 \\theta e^{-2\\kappa t} \\int_{0}^{t}(e^{2\\kappa s}-e^{\\kappa s}) ds \\\\\n&= \\sigma^2 r_0 e^{-2\\kappa t} \\left[\\frac{e^{\\kappa s}}{\\kappa} \\right]_{0}^{t} +\\sigma^2 \\theta e^{-2\\kappa t} \\left[\\frac{e^{2\\kappa s}}{2\\kappa} - \\frac{e^{\\kappa s}}{\\kappa}\\right]_{0}^{t}\\\\\n&= \\frac{\\sigma^2 r_0}{\\kappa} e^{-2\\kappa t} (e^{\\kappa t} - 1)+\\sigma^2 \\theta e^{-2\\kappa t} \\left[\\frac{e^{2\\kappa s}}{2\\kappa} - \\frac{2e^{\\kappa s}}{2\\kappa}\\right]_{0}^{t}\\\\\n&= \\frac{\\sigma^2 r_0}{\\kappa} e^{-2\\kappa t}(e^{\\kappa t} - 1)+\\frac{\\sigma^2 \\theta}{2\\kappa} e^{-2\\kappa t}(e^{2\\kappa t} - 2e^{\\kappa t} - (1 - 2))\\\\\n&= \\frac{\\sigma^2 r_0}{\\kappa} e^{-2\\kappa t}(e^{\\kappa t} - 1)+\\frac{\\sigma^2 \\theta}{2\\kappa}e^{-2\\kappa t} (1 + e^{2\\kappa t} - 2e^{\\kappa t})\\\\\n&= \\frac{\\sigma^2 r_0}{\\kappa} (e^{-\\kappa t} - e^{-2\\kappa t})+\\frac{\\sigma^2 \\theta}{2\\kappa} (1 - e^{-\\kappa t})^2\n\\end{align*}\\]"
  },
  {
    "objectID": "posts/cox-ingersoll-ross-model/index.html#naive-python-implementation",
    "href": "posts/cox-ingersoll-ross-model/index.html#naive-python-implementation",
    "title": "Cox-Ingersoll-Ross (CIR) model",
    "section": "Naive python implementation",
    "text": "Naive python implementation\n\nimport math\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport functools\n\n\nclass CIRProcess:\n    \"\"\"An engine for generating sample paths of the Cox-Ingersoll-Ross process\"\"\"\n\n    def __init__(\n        self,\n        kappa: float,\n        theta: float,\n        sigma: float,\n        num_paths: int,\n        step_size: float,\n        total_time: float,\n    ):\n        self.kappa = kappa\n        self.theta = theta\n        self.sigma = sigma\n        self.num_paths = num_paths\n        self.step_size = step_size\n        self.total_time = total_time\n\n    def generate_paths(self):\n        num_steps = int(self.total_time / self.step_size)\n        dz = np.random.standard_normal((self.num_paths, num_steps))\n        r_t = np.zeros((self.num_paths, num_steps))\n        zero_vector = np.full(self.num_paths, 0.0)\n        prev_r = zero_vector\n        for i in range(num_steps):\n            r_t[:, i] = (\n                prev_r\n                + self.kappa * np.subtract(self.theta, prev_r) * self.step_size\n                + self.sigma\n                * np.sqrt(np.abs(prev_r))\n                * math.sqrt(self.step_size)\n                * dz[:, i]\n            )\n\n            prev_r = r_t[:, i]\n\n        return r_t\n\n\ncir_process = CIRProcess(\n    kappa=0.1, theta=0.5, sigma=0.5, num_paths=10, step_size=0.01, total_time=1.0\n)\n\npaths = cir_process.generate_paths()\nt = np.linspace(0.01, 1.0, 100)\n\nplt.grid(True)\nfor path in paths:\n    plt.plot(t, path)\n\nplt.show()"
  }
]