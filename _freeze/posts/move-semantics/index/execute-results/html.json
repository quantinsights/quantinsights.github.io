{
  "hash": "91b626f4882e76233b5e8cbc38491fb9",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Move Semantics\"\nauthor: \"Quasar\"\ndate: \"2024-10-26\"\ncategories: [C++]      \nimage: \"cpp.jpg\"\ntoc: true\ntoc-depth: 3\nformat:\n    html:\n        code-tools: true\n        code-block-border-left: true\n        code-annotations: below\n        highlight-style: pygments\n---\n\n\n## Motivation for Move Semantics\n\nTo understand the basic principles of move semantics, let's look at the execution of a small piece of code. I've written a toy `Vector` class. I choose the manage the memory myself, so I will follow the [rule of three](https://en.wikipedia.org/wiki/Rule_of_three_%28C++_programming%29). I will supply a copy-constructor, copy-assignment operator and a destructor. I have also overloaded `operator+()` to support element-wise addition of two vectors. \n\n::: {#656c0c63 .cell execution_count=1}\n``` {.python .cell-code}\n%load_ext itikz\n```\n:::\n\n\n### Value Semantics\n\nAssume that we have the following program:\n\n```cpp\n//basics/copy_semantics.cpp\n#include <iostream>\n#include <stdexcept>\n#include <initializer_list>\n\n\ntemplate <typename T>\nclass Vector {\nprivate:\n    int capacity_;\n    int size_;\n    T* ptr_;\n\npublic:\n    Vector() :capacity_{ 0 }, size_{ 0 }, ptr_{ nullptr } {}\n    Vector(int size) : capacity_{ size }, ptr_{ new T[size] }, size_{ size } {}\n    Vector(int size, T data) : Vector(size) {\n        for (int i{ 0 }; i < size; ++i)\n            ptr_[i] = data;\n    }\n\n    Vector(std::initializer_list<T> list) {\n        clear();\n        for (const T& elem : list)\n            push_back(elem);\n    }\n\n    //Destructor\n    ~Vector()\n    {\n        clear();\n    }\n\n    //Copy constructor\n    Vector(const Vector& v)\n    {\n        if (this == &v)\n            return;\n\n        capacity_ = v.capacity_;\n        size_ = v.size_;\n        ptr_ = new T[v.size_];\n\n        for (int i{ 0 }; i < v.size_; ++i)\n            ptr_[i] = v.ptr_[i];\n    }\n\n    //Copy assignment operator\n    Vector<T>& operator=(const Vector<T>& v)\n    {\n        if (this != &v)\n        {\n            delete[] ptr_;\n            ptr_ = nullptr;\n\n            capacity_ = v.capacity_;\n            size_ = v.size_;\n            ptr_ = new T[capacity_];\n\n            for (int i{ 0 }; i < v.size_; ++i)\n                ptr_[i] = v.ptr_[i];\n        }\n\n        return *this;\n    }\n\n    T& operator[](int i)\n    {\n        if (i >= 0 && i < size_)\n            return ptr_[i];\n        else\n            throw std::out_of_range(\"Index out of bounds.\");\n    }\n\n    T& operator[](int i) const\n    {\n        if (i >= 0 && i < size_)\n            return ptr_[i];\n        else\n            throw std::out_of_range(\"Index out of bounds.\");\n    }\n\n    void reserve(int size)\n    {\n        if (size_ < capacity_) return;\n\n        if (ptr_ == nullptr)\n        {\n            size_ = 0;\n            capacity_ = 0;\n        }\n\n        T* bufferNew = new T[size];\n        unsigned int l_size = std::min(capacity_, size);\n        for (int i{ 0 }; i < l_size; ++i)\n        {\n            bufferNew[i] = ptr_[i];\n        }\n\n        if (ptr_ != nullptr)\n            delete[] ptr_;\n\n        ptr_ = bufferNew;\n        capacity_ = size;\n    }\n\n    void clear()\n    {\n        if (ptr_ != nullptr)\n            delete[] ptr_;\n        ptr_ = nullptr;\n        size_ = 0;\n        capacity_ = 0;\n    }\n\n    int size() const\n    {\n        return size_;\n    }\n\n    int capacity()\n    {\n        return capacity_;\n    }\n\n    void push_back(const T& elem)\n    {\n        if (size_ >= capacity_) {\n            reserve(capacity_ + 5); // Double the capacity\n        }\n\n        ptr_[size_++] = elem;\n    }\n\n    void pop_back()\n    {\n        --size_;\n    }\n\n    T front()\n    {\n        if (size_ > 0)\n            return ptr_[0];\n        else\n            throw std::out_of_range(\"Index out of bounds.\");\n    }\n\n    T back()\n    {\n        if (size_ > 0)\n            return ptr_[size_ - 1];\n        else\n            throw std::out_of_range(\"Index out of bounds.\");\n    }\n\n    T* getRawPointer()\n    {\n        return ptr_;\n    }\n};\n\ntemplate <typename T>\nVector<T> operator+(const Vector<T>& v1, const Vector<T>& v2)\n{\n    if (v1.size() != v2.size())\n        throw std::logic_error(\"Vector lengths must be equal.\");\n    Vector<T> result;\n    for (int i{ 0 }; i < v1.size(); ++i)\n        result.push_back(v1[i] + v2[i]);\n\n    return result;\n}\n\nVector<Vector<double>> createAndInsert()\n{\n    Vector<Vector<double>> pts;\n    pts.reserve(3);\n    Vector<double> x{ 1.0, 1.0 };\n    std::cout << \"\\nCheckpoint #1\";\n    std::cout << \"\\npts->ptr_ = \"<<pts.getRawPointer();\n    std::cout << \"\\nx->ptr_ = \"<<x.getRawPointer();\n    pts.push_back(x);\n    std::cout << \"\\nCheckpoint #2\";\n    std::cout << \"\\npts[0]->ptr_ = \" << pts[0].getRawPointer();\n    pts.push_back(x + x);\n    std::cout << \"\\npts[1]->ptr_ = \" << pts[1].getRawPointer();\n    pts.push_back(x);\n    std::cout << \"\\nCheckpoint #3\";\n    std::cout << \"\\npts[2]->ptr_ = \" << pts[2].getRawPointer();\n    return pts;\n}\n\nint main()\n{\n    Vector<Vector<double>> result = createAndInsert();\n    return 0;\n}\n```\n\n[Compiler Explorer](https://godbolt.org/z/TTfKs4seP){target=\"_blank\"}\n\nLet us look at the individual steps of the program (inspecting both stack and the heap) when we compile this program with a C++ compiler.\n\nFirst in `main`, we create the empty vector `pts` which will be used to store points in the euclidean space $\\mathbf{R}^2$:\n\n```\nVector<Vector<double>> pts;\n```\n\nwhich is placed on the stack as an object that has `size_ = 0`, `capacity_ = 0` and no memory allocated for elements.\n\nThen, we call \n\n```\npts.reserve(3);\n```\n\nThis allocates memory for `3` elements on the heap. The member `pts_->capacity_` equals `3`, `pts->size_` equals `0` and `pts_->ptr_` contains the address to heap block. The allocated memory is not initialized, because the number of elements is still `0`.\n\nThen, we create a $2$-tuple to hold the cartesian coordinates of a point $(1.0,1.0)$. We create a `Vector<double>` initialized to `{1.0,1.0}`. Essentially, we create an object `x` on the stack with its members `x->size_ = 2`, `x->capacity_ = 5` and a pointer `x->ptr_` containing the address of newly allocated memory on the heap for `5` elements. Further, `ptr_[0]=1.0`, `ptr_[1]=1.0`. \n\n```\nVector<double> x{1.0, 1.0};\n```\n\nAfter this statement, the program has the following state: we have two objects on the stack : `pts` and `x`. Both of them have memory allocated on the heap. \n\n![Checkpoint #1](move_semantics_00.png)\n\nThe next step is the command to insert `x` into the `pts` vector. \n\n```\npts.push_back(x);\n```\n\nMy toy `Vector` class is said to have value semantics, which means it creates copies of the values passed to it. As a result, we get a first element in the vector, which is a full(deep) copy of the passed value/object `x`:\n\n![Checkpoint #2](move_semantics_01.png)\n\nThe current state is that we have a vector `pts` and two copies of `x={1.0,1.0}`, one of which is the first element in `pts`. \n\nLet's now look at the next statement, which creates a new temporary vector and again inserts it into the `pts` vector:\n\n```\npts.push_back(x + x);\n```\n\nThis statement is performed in three steps:\n\n*Step 1*. We create a temporary `Vector<double>` object `x + x`. \n\n![Step #1](move_semantics_02.png)\n\n*Step 2*.  `x+x` is a temporary.  The `Vector<T>::push_back(const T&)` function accepts a reference-to-`const` as an argument. Since `x+x` is a temporary, it cannot be modified and binds to a reference-to-`const`. Moreover, being a temporary object, it is likely to die soon. Referencing it extends the lifetime of the temporary x + x={2.0,2.0}. \n\nNow, the statement `pts_[size++] = elem` will invoke the copy-assignment operator on the yet uninitialized second element  `pts[1]` which is of type `Vector<double>`. This will force a full (deep) copy of `x + x={2.0,2.0}`. At this time, two copies of `{2.0,2.0}`  exist on the heap. One of these is assigned to pts[1]. \n\n![Step #2](move_semantics_03.png)\n\n*Step 3*. When `push_back(const T&)` returns, the temporary `x + x` will die and its destructor is called and the memory allocated on the heap is freed.\n\nOur code is clearly not performing well: we create a copy of the temporary `x + x` and destroy the source of the copy immediately afterwards, which means we unnecessarily allocate and free memory that we could have just moved from source to the copy.\n\n![Step #3](move_semantics_04.png)\n\nWith the next statement, again we insert `x` into `pts`:\n\n```\npts.push_back(x)\n```\n\nAgain, `pts` copies `x`.\n\n![Checkpoint #3](move_semantics_05.png)\n\nThis is also something to improve. Because the value of `x` is no longer needed, some optimization could use the memory of `x` as the memory for the new element instead. \n\nAt the end of `createAndInsert()` we come to the return statement:\n\n```\nreturn pts;\n```\n\nHere, the behaviour of the program is a bit more complicated. We return by value (the return type is not a reference), which should be a copy of the value in the `return` statement. Creating a copy of `pts` means that we have create a deep copy of the whole vector with all of its elements. Thus, we have to allocate heap memory for the array of elements in the `pts` and heap memory for the value of each 2-tuple. Here, we would have to allocate memory 4 times.\n\nHowever, since at the same time `pts` is destroyed because we leave the scope where it is declared, the compiler is allowed to perform *named return value optimization (NRVO)*. This means that the compiler can generate code so that `pts` is used as the return value.  \n\nLet us assume that we have the named return value optimization. In that case, at the end of the `return` statement, `pts` simply becomes the return value and the destructor of `x` is called, which frees the memory allocated when it was declared.\n\n![Return statement](move_semantics_06.png)\n\nFinally, we come to the assignment of the return value to `result`:\n\n```\nresult = createAndInsert()\n```\n\nHere, we really get behavior that can be improved: the usual assignment operator has the goal of giving `result` the same value as the source value that is assigned. In general, any source(assigned) value should not be modified and should independent from the object that the value was assigned to. So, the assignment operator will create a deep-copy of the whole return value:\n\n![Return statement](move_semantics_07.png)\n\nHowever, right after that we no longer need the temporary return value and we destroy it:\n\nAgain, we create a copy of a temporary object and destroy the source of the copy immediately afterwards, which means that we again unnecessarily allocate and free memory. This time it applies to four allocations\n\nFor the state of the program after this assignment in `main()`, we allocated memory numerous times and released it. Unnecessary memory allocations were caused by:\n\n- Inserting a temporary object into `pts`.\n- Inserting an object into `pts` where we no longer need the value.\n- Assigning a temporary vector with all its elements.\n\nWe can more or less avoid these performance pennalties. \n\n## Copy and swap idiom\n\nAny class which manages resources (a wrapper like a *smart pointer*) needs to implement [The Big Three](https://stackoverflow.com/questions/4172722/what-is-the-rule-of-three). While the goals of the copy constructor and destructor are straightforward, the copy-assignment operator is arguably the most nuanced and difficult. What pitfalls need to be avoided?\n\nConsider our naive implementation of the assignment operator:\n\n```cpp\n//Copy assignment operator\nVector<T>& operator=(const Vector<T>& v)\n{\n    if (this != &v)     //(1)\n    {\n        delete[] ptr_;  //(2)\n        ptr_ = nullptr;\n\n        capacity_ = v.capacity_;    //(3)\n        size_ = v.size_;            //(3)\n        ptr_ = new T[capacity_];    //(3)\n\n        for (int i{ 0 }; i < v.size_; ++i)\n            ptr_[i] = v.ptr_[i];\n    }\n\n    return *this;\n}\n```\n\nWhile this manages the heap memory without leaks, it suffers from three problems, marked sequentially in the code as `(n)`.\n\n1. The first is the self-assignment test. This check is an easy way to prevent us from running needless code on self-assignment. But, in all other cases, it merely serves to slow down the program and acts as noise in the code; self-assignment rarely occurs, so most of the time this check is a waste.\n2. The seond is, it only provides a basic exception guarantee. If `new T[capacity_]` fails, `*this` will have been modified. Namely, the `size_` and `capacity_` are wrong and the old data referenced by `ptr_` is gone! For a strong exception guarantee, we need something akin to:\n\n```cpp\n//Copy assignment operator\nVector<T>& operator=(const Vector<T>& v)\n{\n    if (this != &v)     //(1)\n    {\n        // get the new data ready, before we replace the old data\n        int newCapacity = v.capacity_;\n        int newSize = v.size_;\n        T* newPtr_ = new T[newCapacity]();\n\n        for (int i{ 0 }; i < v.size_; ++i)\n            newPtr_[i] = v.ptr_[i];\n\n        //replace the old data (all are non-throwing)\n        delete[] ptr_;\n        size_ = newSize;\n        capacity_ = newCapacity_;\n        ptr_ = newPtr;\n    }\n\n    return *this;\n}\n```\n\n3. Our code has expanded! This leads us to the third problem: code duplication. \n\nIn our case, the core of it is only two lines (the allocation and the copy), but with more complex resources, this code bloat can be quite a hassle. What if my class manages more than one resource?\n\nThe *copy-and-swap* idiom is the solution, and elegantly assists the assignment operator in achieving two things: avoiding code duplication and providing a strong exception guarantee.\n\nWhile, the *rule-of-three* successfully entails our copy-constructor, assignment and destructor, it should really be called *The Big Three and A Half*: any time your class manages a resource, it also makes sense to provide a `swap` function. \n\nWe need to add `swap` functionality to our class, and we do that as follows:\n\n\n\nConceptually, it works by using the copy-constructor's functionality to create a local copy of the data, then takes the copied data with a `swap()` function swapping the old data with the new data. \n\nIn order to use the copy-and-swap idiom, we need three things: a working copy-constructor, working destructor (both are the basis of any wrapper, so should be complete anyway), and a `swap` function.\n\nA swap function is a *non-throwing* function that swaps two objects of a class member-for-member. \n\n\n\n## Value Categories\n\nIn C++, every expression is either an `lvalue` or an `rvalue`. Consider an object that owns some resources(file-descriptors, sockets, memory buffer).\n\n- An `lvalue` denotes an object whose resources cannot be reused. The object is an `lvalue`, if you can't take the guts(resources) out of this object and donate it to someone else. `lvalue`s include expressions that designate objects by their name. For example, in the expression `double y = f(x)`, `y` is an `lvalue`. Moreover, `lvalue`s have persistent storage and an identifiable memory address. For instance, if I declare `std::vector<double> v{1.0,2.0,3.0,4.0,5.0};`, then `v[0]` is an `lvalue`.\n\n- An `rvalue` denotes an object whose resources can be reused. The object is an `rvalue`, if you can take the guts(resources) out of it and donate it to another object. `rvalue`s typically include temporary objects as they can't manipulated at the place they are created and are likely to be destroyed soon. For instance, if declare `int x = 5;`, `5` is an `rvalue`. Moreover, in the statement `double y = f(x);`, the expression `f(x)` is an `rvalue`. \n\n## Writing a move constructor\n\nApart from the copy-constructor, you can provide a move constructor for your class. The purpose of the move-constructor is to steal as many resources as it can from the original object, as fast as possible, because the original is going to be destroyed (or sometimes assigned to) in a moment anyway. Note that, stealing has certain constraints. While we can steal the resources, we must leave the object in a valid (but unspecified state), such that it can correctly (without leaking resources or triggering undefined behavior) be destroyed or assigned to. How is such stealing implemented?\n\n```cpp\n\nvoid swap(Vector&& other)\n{\n    std::swap(size_, other.size_);\n    std::swap(capacity_,other.capacity_);\n    std::swap(ptr_, other.ptr_);\n}\n```\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}