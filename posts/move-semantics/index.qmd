---
title: "Move Semantics"
author: "Quasar"
date: "2024-10-26"
categories: [C++]      
image: "cpp.jpg"
toc: true
toc-depth: 3
format:
    html:
        code-tools: true
        code-block-border-left: true
        code-annotations: below
        highlight-style: pygments
---

## Motivation for Move Semantics

To understand the basic principles of move semantics, let's look at the execution of a small piece of code, first without move semantics (compiled with an old C++ compiler that only supports C++ 03) and then with move semantics (compiled with a modern C++ compiler) that supports C++11 or later.

### Before move semantics

Assume that we have the following program:

```cpp
#include <vector>
#include <string>

std::vector<std::string> createAndInsert()
{
    std::vector<std::string> coll;      //create a vector of strings
    coll.reserve(3);                    //reserve memory for 3 elements
    std::string s {"data"};             //create string object
    coll.push_back(s);                  //insert string object
    coll.push_back(s+s);                //insert temporary string
    coll.push_back(s);                  //insert string
    return coll;                        //return vector of strings
}

int main()
{
    std::vector<std::string> v;         //create empty vector of strings
    v = createAndInsert();              //assign returned vector of strings
    return 0;
}
```

Let us look at the individual steps of the program (inspecting both stack and the heap) when we compile this program with a C++ compiler that does **not** support move semantics.

First in `main`, we create the empty vector `v`:

```
std::vector<std::string> v;
```

which is placed on the stack as an object that has 0 as the number of elements and no memory allocated for elements.

Then, we call 

```
v = createAndInsert();
```

where we create another empty vector `coll` on the stack and reserve memory for three elements on the heap:

```
std::vector<std::string> coll;
coll.reserve(3);
```

The allocated memory is not initialized because the number of elements is still 0. Then, we create a string initialized with `"data"`:

```
std::string s = "data";
```

A string is something like a vector with `char` elements. Essentially, we create an object on the stack  