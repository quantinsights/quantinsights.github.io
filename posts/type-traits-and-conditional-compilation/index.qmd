---
title: "Type Traits"
author: "Quasar"
date: "2024-11-25"
categories: [C++]      
image: "cpp.jpg"
toc: true
toc-depth: 3
format:
    html:
        code-tools: true
        code-block-border-left: true
        code-annotations: below
        highlight-style: pygments
---

*Meta-programs* are programs that treat other programs as data. They could be other programs or itself. A *meta-function* is not a function, but a `class` or `struct`. *Metafunctions* are not part of the language and have no formal language support. They exist purely as an idiomatic use of the existing language features. Now, since their use is not enforced by the language, their used has to be dictated by a convention. Over the years, the C++ community has created common set of standard conventions. Actually this work goes back all the way to [Boost `type_traits`](https://www.boost.org/doc/libs/1_79_0/libs/type_traits/doc/html/index.html).

*Metafunctions* are not functions. Technically, they are a class with zero or more template parameters and zero+ return types and values. The convention is that a *metafunction* should return just one thing, like a regular function. The convention was developed over time, so there are plenty of existing examples that do not follow this convention. More modern *metafunctions* do follow this convention. 

## How do we `return` from a metafunction

If we have to return a value, basically, we are going to expose a `public` field named `value`.

```cpp
template<typename T>
struct TheAnswer{
    static constexpr int value = 42;
};
```

And if we are going to return a type, we are going to expose a `public` field named `type`.

```cpp
template<typename T>
struct Echo{
    using type = T;
};
```

Now, here's kind of the difference between regular functions and *metafunctions*. A regular function in C++ always works on some form of data and it's always going to return to you some piece of data as well. Amongst *metafunctions*, we have value *metafunctions* that work on values like we are used to and then we have *metafunctions* that work entirely on types and they yield back some type to you. And so in the both of the examples above, we return something by exposing the public members of a class.

## Value metafunctions

A value *metafunction* is kind of like a simple regular function. Let's look at a simple regular function - the integer identity function. 

```cpp
int int_identity(int x)
{
    return x;
}

assert(42 == int_identity(42));
```

This function just applies the identity transformation on any integer passed to it, and spits out the same number. A simple *metafunction* for identity - we can call it the `intIdentity` metafunction would look like this:

```cpp
template<int X>
struct intIdentity{
    static constexpr int value = X;
};

static_assert(42 == IntIdentity<42>::value);
```

We see that it's not that much different. You return a value by having a `static` data-member called `value` and it has the *metafunction*'s return value. `IntIdentity<42>::value` is where we are calling the *metafunction*. Now, this convention needs to be adhered to, because if you give your *metafunction* some other name such as `my_value`, for example, if you write:

```cpp
template<int X>
struct intIdentity{
    static constexpr int my_value = X;
};

static_assert(42 == IntIdentity<42>::value);
```

it's not going to work well with other things. 

### Generic Identity Function 

Let's look at the generic identity function.

```cpp
template<typename T>
T identity(T x){
    return x;
}

//Returned type will be 42
assert(42 == identity(42));

// Returned type will be unsigned long long
assert(42ul == identity(42ul))
```

This is just a function that will be an identity for any type. You give me a value of any type and I will give you that value back. Now we can create a generic identity *metafunction* as well:

```cpp
template<typename T, T x>
struct ValueIdentity{
    static constexpr T value = x;
};

// The type of value will be int
static_assert(42 == identity<int,42>::value);

// The type of value will unsigned long long
static_assert(42ull == identity<unsigned long long,42ull>::value);
```

`ValueIdentity` is a generic metafunction, so we have to first feed it the type `int` and then the value `42`. It's a little cumbersome, but you get used to it after a while.

In C++17, things get a little bit easier with generic *metafunctions*, because we have this cool keyword called `auto`. I won't go into all the details of `auto`. For now, it basically means that the template will accept and deduce the type of any non-type template parameter.

```cpp
template<auto X>
struct ValueIdentity{
    static constexpr auto value = X;
};

// The type of value will be int
static_assert(42 == identity<int,42>::value);

// The type of value will unsigned long long
static_assert(42ull == identity<unsigned long long,42ull>::value);
```

Let's look at another function `sum()`. We can do this in a regular function, and we can do this in a *metafunction* as well.

```cpp
int sum(int x, int y){
    return x + y;
}

template<int X, int Y>
struct intSum{
    static constexpr int value = X + Y;
};

static_assert(42 == IntSum<30,12>::value);
```

So, we can also create a generic version of this:

```cpp
template<typename X, typename Y>
auto sum(T x, Ty){
    return x + y;
}

template<auto X, auto Y>
struct Sum{
    static constexpr auto value = X + Y;
};
```

## Type metafunctions

Type metafunctions are the workhorse of doing type transformations. You can manipulate types through type *metafunctions*. Type *metafunctions are going to return just a type.

Here's our `TypeIdentity` function:

```cpp
template<typename T>
struct TypeIdentity{
    using type = T;
}
```

Just like we have `ValueIdentity`, where given any value, it's going you the value back; we have `TypeIdentity`, where you give it any type, and it's going to give you the type back.

C++20 actually introduces `std::type_identity`, which is pretty much what we see above.

### Calling Type Metafunctions

When we call a value *metafunction*, 